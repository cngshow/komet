#
# 
#
# Generated by <a href="http://enunciate.webcohesion.com">Enunciate</a>.
#
require 'json'

# adding necessary json serialization methods to standard classes.
class Object
  def to_jaxb_json_hash
    return self
  end
  def self.from_json o
    return o
  end
end

class String
  def self.from_json o
    return o
  end
end

class Boolean
  def self.from_json o
    return o
  end
end

class Numeric
  def self.from_json o
    return o
  end
end

class Time
  #json time is represented as number of milliseconds since epoch
  def to_jaxb_json_hash
    return (to_i * 1000) + (usec / 1000)
  end
  def self.from_json o
    if o.nil?
      return nil
    else
      return Time.at(o / 1000, (o % 1000) * 1000)
    end
  end
end

class Array
  def to_jaxb_json_hash
    a = Array.new
    each { | _item | a.push _item.to_jaxb_json_hash }
    return a
  end
end

class Hash
  def to_jaxb_json_hash
    h = Hash.new
    each { | _key, _value | h[_key.to_jaxb_json_hash] = _value.to_jaxb_json_hash }
    return h
  end
end

module EnunciateHelpers
  LAMB_CLASS_AWARE = ->(_item) do
    java_clazz = _item['@class']
    clazz_array_parts = java_clazz.split('.')
    short_clazz = clazz_array_parts.pop
    clazz_package = clazz_array_parts.map do |e| e[0] = e.first.capitalize; e end.join("::")
    clazz = clazz_package + "::" + short_clazz
    Object.const_get(clazz).send(:from_json, _item)
  end
end


module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingSetVersionBase 

    # The primary name of this map set.
    attr_accessor :name
    # The (optional) inverse name of this map set.  Used when a map set is of the pattern:
    # ingredient-of &lt;--&gt; has-ingredient
    attr_accessor :inverseName
    # The description of this map set
    attr_accessor :description
    # The (optional) purpose of this map set - or extended description of this map set.
    attr_accessor :purpose
    # True to indicate the mapping set should be set as active, false for inactive.
    # This field is optional, if not provided, it will be assumed to be active.  On return,
    # this field duplicates information provided in the stamp.
    attr_accessor :active

    # the json hash for this RestMappingSetVersionBase
    def to_jaxb_json_hash
      _h = {}
      _h['name'] = name.to_jaxb_json_hash unless name.nil?
      _h['inverseName'] = inverseName.to_jaxb_json_hash unless inverseName.nil?
      _h['description'] = description.to_jaxb_json_hash unless description.nil?
      _h['purpose'] = purpose.to_jaxb_json_hash unless purpose.nil?
      _h['active'] = active.to_jaxb_json_hash unless active.nil?
      return _h
    end

    # the json (string form) for this RestMappingSetVersionBase
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestMappingSetVersionBase with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['name'].nil?
          _oa = _o['name']
            if(_oa.is_a? Hash)
              @name = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @name =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @name = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @name.push String.from_json(_item)
                 else
                   @name.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @name = _oa
            end
          end
        if !_o['inverseName'].nil?
          _oa = _o['inverseName']
            if(_oa.is_a? Hash)
              @inverseName = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @inverseName =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @inverseName = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @inverseName.push String.from_json(_item)
                 else
                   @inverseName.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @inverseName = _oa
            end
          end
        if !_o['description'].nil?
          _oa = _o['description']
            if(_oa.is_a? Hash)
              @description = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @description =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @description = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @description.push String.from_json(_item)
                 else
                   @description.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @description = _oa
            end
          end
        if !_o['purpose'].nil?
          _oa = _o['purpose']
            if(_oa.is_a? Hash)
              @purpose = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @purpose =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @purpose = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @purpose.push String.from_json(_item)
                 else
                   @purpose.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @purpose = _oa
            end
          end
        if !_o['active'].nil?
          _oa = _o['active']
            if(_oa.is_a? Hash)
              @active = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @active =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @active = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @active.push Boolean.from_json(_item)
                 else
                   @active.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @active = _oa
            end
          end
    end

    # constructs a RestMappingSetVersionBase from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

  # (no documentation provided)
  class RestOptionalIdentifiedObject 

    # An object containing a type, description and set of identifiers for an object.
    # Null if no corresponding object exists.
    attr_accessor :object

    # the json hash for this RestOptionalIdentifiedObject
    def to_jaxb_json_hash
      _h = {}
      _h['object'] = object.to_jaxb_json_hash unless object.nil?
      return _h
    end

    # the json (string form) for this RestOptionalIdentifiedObject
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestOptionalIdentifiedObject with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['object'].nil?
          _oa = _o['object']
            if(_oa.is_a? Hash)
              @object = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @object =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @object = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @object.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @object.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @object = _oa
            end
          end
    end

    # constructs a RestOptionalIdentifiedObject from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Association

  # (no documentation provided)
  class RestAssociationItemVersionUpdate 

    # The uuid or nid of the target item in the association.  Typically this is a concept, but it may also be a sememe.  Note that
    # this may be null, in the case where the association intends to represent that no target is available for a particular
    # association type and source component.  May not be a sequence.
    attr_accessor :targetId
    # True to indicate the association should be set as active, false for inactive.
    # This field is optional, if not provided, it will be assumed to be active.
    attr_accessor :active

    # the json hash for this RestAssociationItemVersionUpdate
    def to_jaxb_json_hash
      _h = {}
      _h['targetId'] = targetId.to_jaxb_json_hash unless targetId.nil?
      _h['active'] = active.to_jaxb_json_hash unless active.nil?
      return _h
    end

    # the json (string form) for this RestAssociationItemVersionUpdate
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestAssociationItemVersionUpdate with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['targetId'].nil?
          _oa = _o['targetId']
            if(_oa.is_a? Hash)
              @targetId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @targetId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @targetId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @targetId.push String.from_json(_item)
                 else
                   @targetId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @targetId = _oa
            end
          end
        if !_o['active'].nil?
          _oa = _o['active']
            if(_oa.is_a? Hash)
              @active = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @active =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @active = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @active.push Boolean.from_json(_item)
                 else
                   @active.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @active = _oa
            end
          end
    end

    # constructs a RestAssociationItemVersionUpdate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Comment

  # (no documentation provided)
  class RestCommentVersionBase 

    # The comment (required)
    attr_accessor :comment
    # An (optional) comment context to store with the comment.  Typically used for key words, etc.
    attr_accessor :commentContext
    # True to indicate the comment should be set as active, false for inactive.
    # This field is optional, if not provided, it will be assumed to be active.
    attr_accessor :active

    # the json hash for this RestCommentVersionBase
    def to_jaxb_json_hash
      _h = {}
      _h['comment'] = comment.to_jaxb_json_hash unless comment.nil?
      _h['commentContext'] = commentContext.to_jaxb_json_hash unless commentContext.nil?
      _h['active'] = active.to_jaxb_json_hash unless active.nil?
      return _h
    end

    # the json (string form) for this RestCommentVersionBase
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestCommentVersionBase with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['comment'].nil?
          _oa = _o['comment']
            if(_oa.is_a? Hash)
              @comment = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @comment =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @comment = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @comment.push String.from_json(_item)
                 else
                   @comment.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @comment = _oa
            end
          end
        if !_o['commentContext'].nil?
          _oa = _o['commentContext']
            if(_oa.is_a? Hash)
              @commentContext = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @commentContext =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @commentContext = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @commentContext.push String.from_json(_item)
                 else
                   @commentContext.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @commentContext = _oa
            end
          end
        if !_o['active'].nil?
          _oa = _o['active']
            if(_oa.is_a? Hash)
              @active = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @active =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @active = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @active.push Boolean.from_json(_item)
                 else
                   @active.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @active = _oa
            end
          end
    end

    # constructs a RestCommentVersionBase from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestDynamicSememeBase 

    # The data to attach with this sememe instance (if any).  This may be null, empty, or a length up to the defined length of the sememe definition.
    # 
    # The supplied data must match the definition of the sememe - which can be read via SememeAPIs#getSememeDefinition(String, String)
    # (1/sememe/sememeDefinition/{assemblageId})
    # 
    # RestDynamicSememeData is an abstract type.  The data passed here, must be of a concrete type.  For the server to deserialize the type properly,
    # a field must be included of the form &quot;@class&quot;: &quot;gov.vha.isaac.rest.api1.data.sememe.dataTypes.CLASSTYPE&quot;
    # 
    # where CLASSTYPE is one of:
    # - RestDynamicSememeArray
    # - RestDynamicSememeBoolean
    # - RestDynamicSememeByteArray
    # - RestDynamicSememeDouble
    # - RestDynamicSememeFloat
    # - RestDynamicSememeInteger,
    # - RestDynamicSememeLong,
    # - RestDynamicSememeString,
    # - RestDynamicSememeNid
    # - RestDynamicSememeSequence
    # - RestDynamicSememeUUID
    # 
    # The class type strings are also available in the /rest/1/system/enumeration/restDynamicSememeDataType call, which returns all of the available data
    # types, names, ids, and class type information.
    # 
    # Example JSON that provides two columns of differing types:
    # 
    # {
    # &quot;assemblageConcept&quot;: &quot;-2147483449&quot;,
    # &quot;referencedComponent&quot;: &quot;-2147483557&quot;,
    # &quot;columnData&quot;: [{
    # &quot;@class&quot;: &quot;gov.vha.isaac.rest.api1.data.sememe.dataTypes.RestDynamicSememeString&quot;,
    # &quot;data&quot;: &quot;test&quot;
    # &quot;columnNumber&quot;: &quot;0&quot;
    # }, {
    # &quot;@class&quot;: &quot;gov.vha.isaac.rest.api1.data.sememe.dataTypes.RestDynamicSememeLong&quot;,
    # &quot;data&quot;: 5
    # &quot;columnNumber&quot;: &quot;1&quot;
    # }]
    # }
    # 
    # If the sememe definition contains a column that is optional, and the optional column is at the end of the set of fields, you may omit the field
    # from the array entirely.  If the optional field is in the middle of the columnData list, you may either pass a concrete type with a null data field,
    # sush as a RestDyanamicSememeString - or, you may simply pass null in the array.  However, the column number will have to be assumed from the position
    # of the null within the array, as it arrives, in this case.
    # 
    # Column numbers are required whenever a non-null element is passed in the array, and the column number has precedence over the array position order
    # when it comes to aligning the data for storage.
    attr_accessor :columnData
    # True to indicate the sememe should be set as active, false for inactive.
    # This field is optional, if not provided, it will be assumed to be active.
    attr_accessor :active

    # the json hash for this RestDynamicSememeBase
    def to_jaxb_json_hash
      _h = {}
      if !columnData.nil?
        _ha = Array.new
        columnData.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['columnData'] = _ha
      end
      _h['active'] = active.to_jaxb_json_hash unless active.nil?
      return _h
    end

    # the json (string form) for this RestDynamicSememeBase
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestDynamicSememeBase with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['columnData'].nil?
          _oa = _o['columnData']
            if(_oa.is_a? Hash)
              @columnData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnData =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnData = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnData.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                 else
                   @columnData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnData = _oa
            end
          end
        if !_o['active'].nil?
          _oa = _o['active']
            if(_oa.is_a? Hash)
              @active = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @active =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @active = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @active.push Boolean.from_json(_item)
                 else
                   @active.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @active = _oa
            end
          end
    end

    # constructs a RestDynamicSememeBase from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api

module Data

module Vuid

  # (no documentation provided)
  class RestVuidBlockData 

    # (no documentation provided)
    attr_accessor :endInclusive
    # (no documentation provided)
    attr_accessor :startInclusive

    # the json hash for this RestVuidBlockData
    def to_jaxb_json_hash
      _h = {}
      _h['endInclusive'] = endInclusive.to_jaxb_json_hash unless endInclusive.nil?
      _h['startInclusive'] = startInclusive.to_jaxb_json_hash unless startInclusive.nil?
      return _h
    end

    # the json (string form) for this RestVuidBlockData
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestVuidBlockData with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['endInclusive'].nil?
          _oa = _o['endInclusive']
            if(_oa.is_a? Hash)
              @endInclusive = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @endInclusive =  Bignum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @endInclusive = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @endInclusive.push Bignum.from_json(_item)
                 else
                   @endInclusive.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @endInclusive = _oa
            end
          end
        if !_o['startInclusive'].nil?
          _oa = _o['startInclusive']
            if(_oa.is_a? Hash)
              @startInclusive = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @startInclusive =  Bignum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @startInclusive = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @startInclusive.push Bignum.from_json(_item)
                 else
                   @startInclusive.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @startInclusive = _oa
            end
          end
    end

    # constructs a RestVuidBlockData from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Concept

  # (no documentation provided)
  class RestConceptVersion 

    # The data that was not expanded as part of this call (but can be)
    attr_accessor :expandables
    # The concept chronology for this concept.  Depending on the expand parameter, may be empty.
    attr_accessor :conChronology
    # The StampedVersion details for this version of this concept.
    attr_accessor :conVersion
    # A boolean indicating whether the concept is fully-defined or primitive.  true for fully-defined, false for primitive
    # This value is not populated / returned if the concept does not contain a logic graph from which to derive the information.
    attr_accessor :isConceptDefined
    # The parent concepts(s) of the concept at this point in time (&#39;is a&#39; relationships).  Depending on the expand parameter, this may not be returned.
    attr_accessor :parents
    # The child concepts(s) of the concept at this point in time (&#39;is a&#39; relationships).  Depending on the expand parameter, this may not be returned.
    attr_accessor :children
    # The number of child concept(s) of the concept at this point in time (&#39;is a&#39; relationships).  Depending on the expand parameter, this may not be returned.
    # This will not be returned if the children field is populated.
    attr_accessor :childCount
    # The number of parent concept(s) of the concept at this point in time (&#39;is a&#39; relationships).  Depending on the expand parameter, this may not be returned.
    # This will not be returned if the parents field is populated.
    attr_accessor :parentCount
    # The identifiers of the sememe assemblage concepts that this concept is a member of (there exists a sememe instance where the referencedComponent
    # is this concept, and the assemblage is the value returned).  Note that this field is typically not populated - and when it is populated, it is only
    # in response to a request via the Taxonomy or Concept APIs, when the parameter &#39;sememeMembership=true&#39; is passed.
    # See more details on TaxonomyAPIs#getConceptVersionTaxonomy(String, String, int, String, int, String, String, String)
    attr_accessor :sememeMembership
    # The identifiers of the terminologies (concepts that represent terminologies) that this concept is part of.  This is determined by whether or not there is
    # version of this concept present with a module that extends from one of the children of the MetaData#MODULE concepts.  Note that this field is typically
    # not populated - and when it is populated, it is only in response to a request via the Taxonomy or Concept APIs, when the parameter &#39;terminologyTypes=true&#39; is passed.
    # 
    # Note that this is calculated WITH taking into account the view coordinate, including the active / inactive state of the concept in any particular terminology.
    # This means that if a concept is present in both Snomed CT and the US Extension modules, but your view coordinate excludes the US Extension, this will not
    # include the US Extension module.
    # 
    # For behavior that ignores stamp, request the same value on the ConceptChronology, instead.
    # 
    # See 1/system/terminologyTypes for more details on the potential terminology concepts that will be returned.
    attr_accessor :terminologyTypes

    # the json hash for this RestConceptVersion
    def to_jaxb_json_hash
      _h = {}
      _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
      _h['conChronology'] = conChronology.to_jaxb_json_hash unless conChronology.nil?
      _h['conVersion'] = conVersion.to_jaxb_json_hash unless conVersion.nil?
      _h['isConceptDefined'] = isConceptDefined.to_jaxb_json_hash unless isConceptDefined.nil?
      if !parents.nil?
        _ha = Array.new
        parents.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['parents'] = _ha
      end
      if !children.nil?
        _ha = Array.new
        children.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['children'] = _ha
      end
      _h['childCount'] = childCount.to_jaxb_json_hash unless childCount.nil?
      _h['parentCount'] = parentCount.to_jaxb_json_hash unless parentCount.nil?
      if !sememeMembership.nil?
        _ha = Array.new
        sememeMembership.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['sememeMembership'] = _ha
      end
      if !terminologyTypes.nil?
        _ha = Array.new
        terminologyTypes.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['terminologyTypes'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestConceptVersion
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestConceptVersion with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['expandables'].nil?
          _oa = _o['expandables']
            if(_oa.is_a? Hash)
              @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @expandables = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                 else
                   @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @expandables = _oa
            end
          end
        if !_o['conChronology'].nil?
          _oa = _o['conChronology']
            if(_oa.is_a? Hash)
              @conChronology = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @conChronology =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @conChronology = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @conChronology.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_item)
                 else
                   @conChronology.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @conChronology = _oa
            end
          end
        if !_o['conVersion'].nil?
          _oa = _o['conVersion']
            if(_oa.is_a? Hash)
              @conVersion = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @conVersion =  Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @conVersion = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @conVersion.push Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_item)
                 else
                   @conVersion.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @conVersion = _oa
            end
          end
        if !_o['isConceptDefined'].nil?
          _oa = _o['isConceptDefined']
            if(_oa.is_a? Hash)
              @isConceptDefined = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @isConceptDefined =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @isConceptDefined = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @isConceptDefined.push Boolean.from_json(_item)
                 else
                   @isConceptDefined.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @isConceptDefined = _oa
            end
          end
        if !_o['parents'].nil?
          _oa = _o['parents']
            if(_oa.is_a? Hash)
              @parents = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @parents =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @parents = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @parents.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_item)
                 else
                   @parents.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @parents = _oa
            end
          end
        if !_o['children'].nil?
          _oa = _o['children']
            if(_oa.is_a? Hash)
              @children = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @children =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @children = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @children.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_item)
                 else
                   @children.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @children = _oa
            end
          end
        if !_o['childCount'].nil?
          _oa = _o['childCount']
            if(_oa.is_a? Hash)
              @childCount = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @childCount =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @childCount = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @childCount.push Fixnum.from_json(_item)
                 else
                   @childCount.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @childCount = _oa
            end
          end
        if !_o['parentCount'].nil?
          _oa = _o['parentCount']
            if(_oa.is_a? Hash)
              @parentCount = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @parentCount =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @parentCount = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @parentCount.push Fixnum.from_json(_item)
                 else
                   @parentCount.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @parentCount = _oa
            end
          end
        if !_o['sememeMembership'].nil?
          _oa = _o['sememeMembership']
            if(_oa.is_a? Hash)
              @sememeMembership = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @sememeMembership =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @sememeMembership = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @sememeMembership.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @sememeMembership.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @sememeMembership = _oa
            end
          end
        if !_o['terminologyTypes'].nil?
          _oa = _o['terminologyTypes']
            if(_oa.is_a? Hash)
              @terminologyTypes = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @terminologyTypes =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @terminologyTypes = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @terminologyTypes.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @terminologyTypes.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @terminologyTypes = _oa
            end
          end
    end

    # constructs a RestConceptVersion from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Workflow

  # (no documentation provided)
  class RestWorkflowProcessBaseCreate 

    # The workflow definition id
    attr_accessor :definitionId
    # The process name
    attr_accessor :name
    # The process description
    attr_accessor :description

    # the json hash for this RestWorkflowProcessBaseCreate
    def to_jaxb_json_hash
      _h = {}
      _h['definitionId'] = definitionId.to_jaxb_json_hash unless definitionId.nil?
      _h['name'] = name.to_jaxb_json_hash unless name.nil?
      _h['description'] = description.to_jaxb_json_hash unless description.nil?
      return _h
    end

    # the json (string form) for this RestWorkflowProcessBaseCreate
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestWorkflowProcessBaseCreate with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['definitionId'].nil?
          _oa = _o['definitionId']
            if(_oa.is_a? Hash)
              @definitionId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @definitionId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @definitionId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @definitionId.push String.from_json(_item)
                 else
                   @definitionId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @definitionId = _oa
            end
          end
        if !_o['name'].nil?
          _oa = _o['name']
            if(_oa.is_a? Hash)
              @name = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @name =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @name = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @name.push String.from_json(_item)
                 else
                   @name.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @name = _oa
            end
          end
        if !_o['description'].nil?
          _oa = _o['description']
            if(_oa.is_a? Hash)
              @description = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @description =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @description = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @description.push String.from_json(_item)
                 else
                   @description.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @description = _oa
            end
          end
    end

    # constructs a RestWorkflowProcessBaseCreate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Workflow

  # (no documentation provided)
  class RestWorkflowProcessAdvancementData 

    # The advancement action requested
    attr_accessor :actionRequested
    # The comment associated with the advancement
    attr_accessor :comment

    # the json hash for this RestWorkflowProcessAdvancementData
    def to_jaxb_json_hash
      _h = {}
      _h['actionRequested'] = actionRequested.to_jaxb_json_hash unless actionRequested.nil?
      _h['comment'] = comment.to_jaxb_json_hash unless comment.nil?
      return _h
    end

    # the json (string form) for this RestWorkflowProcessAdvancementData
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestWorkflowProcessAdvancementData with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['actionRequested'].nil?
          _oa = _o['actionRequested']
            if(_oa.is_a? Hash)
              @actionRequested = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @actionRequested =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @actionRequested = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @actionRequested.push String.from_json(_item)
                 else
                   @actionRequested.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @actionRequested = _oa
            end
          end
        if !_o['comment'].nil?
          _oa = _o['comment']
            if(_oa.is_a? Hash)
              @comment = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @comment =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @comment = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @comment.push String.from_json(_item)
                 else
                   @comment.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @comment = _oa
            end
          end
    end

    # constructs a RestWorkflowProcessAdvancementData from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Concept

  # (no documentation provided)
  class RestConceptChronology 

    # The &quot;best&quot; description for this concept.  This is selected based on the attributes within the session for
    # stamp and language coordinates - or - if none present - the server default.
    attr_accessor :description
    # The data that was not expanded as part of this call (but can be)
    attr_accessor :expandables
    # The identifiers for the concept
    attr_accessor :identifiers
    # The list of concept versions.  Depending on the expand parameter, may be empty, the latest only, or all versions.
    attr_accessor :versions
    # The identifiers of the terminologies (concepts that represent terminologies) that this concept is part of.  This is determined by whether or not there is
    # version of this concept present with a module that extends from one of the children of the MetaData#MODULE concepts.  Note that this field is typically
    # not populated - and when it is populated, it is only in response to a request via the Taxonomy or Concept APIs, when the parameter &#39;terminologyTypes=true&#39; is passed.
    # 
    # Note that this is calculated WITHOUT taking into account the view coordinate, or the active / inactive state of the concept in any particular terminology.
    # 
    # See 1/system/terminologyTypes for more details on the potential terminology concepts that will be returned.
    attr_accessor :terminologyTypes

    # the json hash for this RestConceptChronology
    def to_jaxb_json_hash
      _h = {}
      _h['description'] = description.to_jaxb_json_hash unless description.nil?
      _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
      _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
      if !versions.nil?
        _ha = Array.new
        versions.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['versions'] = _ha
      end
      if !terminologyTypes.nil?
        _ha = Array.new
        terminologyTypes.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['terminologyTypes'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestConceptChronology
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestConceptChronology with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['description'].nil?
          _oa = _o['description']
            if(_oa.is_a? Hash)
              @description = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @description =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @description = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @description.push String.from_json(_item)
                 else
                   @description.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @description = _oa
            end
          end
        if !_o['expandables'].nil?
          _oa = _o['expandables']
            if(_oa.is_a? Hash)
              @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @expandables = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                 else
                   @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @expandables = _oa
            end
          end
        if !_o['identifiers'].nil?
          _oa = _o['identifiers']
            if(_oa.is_a? Hash)
              @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @identifiers = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @identifiers = _oa
            end
          end
        if !_o['versions'].nil?
          _oa = _o['versions']
            if(_oa.is_a? Hash)
              @versions = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @versions =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @versions = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @versions.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_item)
                 else
                   @versions.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @versions = _oa
            end
          end
        if !_o['terminologyTypes'].nil?
          _oa = _o['terminologyTypes']
            if(_oa.is_a? Hash)
              @terminologyTypes = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @terminologyTypes =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @terminologyTypes = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @terminologyTypes.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @terminologyTypes.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @terminologyTypes = _oa
            end
          end
    end

    # constructs a RestConceptChronology from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Search

  # (no documentation provided)
  class RestSearchResult 

    # The internal identifier of the sememe that matched the query
    attr_accessor :matchNid
    # The text of the description that matched the query (may be blank, if the description is not available/active on the path used to populate this)
    attr_accessor :matchText
    # The Lucene Score for this result.  This value is only useful for ranking search results relative to other search results within the SAME QUERY
    # execution.  It may not be used to rank one query against another.
    attr_accessor :score
    # Returns true if the sememe that matched the query is active (with the specified of default stamp,
    # false if inactive.
    attr_accessor :active
    # The data that was not expanded as part of this call (but can be)
    attr_accessor :expandables
    # The (optionally) populated identifiers (UUIDs, nid and sequence) of the sememe that matched the query.  Must pass expand=&#39;uuid&#39; to have
    # this populated.  When populated, the nid here is identical to matchNid - but this is significantly more expensive to populate than matchNid
    # (because that comes directly from the search index) - hence, this field is only optionally populated.
    attr_accessor :identifiers
    # The (optionally) populated concept that is referenced (indirectly) by the sememe that matched the query.  This is calculated by
    # looking up the sememe of the matchNid, and then getting the referenced component of that sememe.  If the referenced component
    # is a concept, that is the concept that is returned.  If the referenced component is a sememe, then the process is repeated (following
    # the referenced component reference of the sememe) - continuing until a concept is found.  If an (unusual) case occurs where the
    # sememe chain doesn&#39;t lead to a concept, this will not be populated.  This is populated by passing the expand parameter &#39;referencedConcept&#39;.
    # If this is passed, you may also (optionally) pass the parameters &#39;versionsLatestOnly&#39; or &#39;versionsAll&#39;
    attr_accessor :referencedConcept

    # the json hash for this RestSearchResult
    def to_jaxb_json_hash
      _h = {}
      _h['matchNid'] = matchNid.to_jaxb_json_hash unless matchNid.nil?
      _h['matchText'] = matchText.to_jaxb_json_hash unless matchText.nil?
      _h['score'] = score.to_jaxb_json_hash unless score.nil?
      _h['active'] = active.to_jaxb_json_hash unless active.nil?
      _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
      _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
      _h['referencedConcept'] = referencedConcept.to_jaxb_json_hash unless referencedConcept.nil?
      return _h
    end

    # the json (string form) for this RestSearchResult
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestSearchResult with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['matchNid'].nil?
          _oa = _o['matchNid']
            if(_oa.is_a? Hash)
              @matchNid = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @matchNid =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @matchNid = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @matchNid.push Fixnum.from_json(_item)
                 else
                   @matchNid.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @matchNid = _oa
            end
          end
        if !_o['matchText'].nil?
          _oa = _o['matchText']
            if(_oa.is_a? Hash)
              @matchText = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @matchText =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @matchText = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @matchText.push String.from_json(_item)
                 else
                   @matchText.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @matchText = _oa
            end
          end
        if !_o['score'].nil?
          _oa = _o['score']
            if(_oa.is_a? Hash)
              @score = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @score =  Float.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @score = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @score.push Float.from_json(_item)
                 else
                   @score.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @score = _oa
            end
          end
        if !_o['active'].nil?
          _oa = _o['active']
            if(_oa.is_a? Hash)
              @active = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @active =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @active = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @active.push Boolean.from_json(_item)
                 else
                   @active.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @active = _oa
            end
          end
        if !_o['expandables'].nil?
          _oa = _o['expandables']
            if(_oa.is_a? Hash)
              @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @expandables = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                 else
                   @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @expandables = _oa
            end
          end
        if !_o['identifiers'].nil?
          _oa = _o['identifiers']
            if(_oa.is_a? Hash)
              @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @identifiers = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @identifiers = _oa
            end
          end
        if !_o['referencedConcept'].nil?
          _oa = _o['referencedConcept']
            if(_oa.is_a? Hash)
              @referencedConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @referencedConcept =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @referencedConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @referencedConcept.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_item)
                 else
                   @referencedConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @referencedConcept = _oa
            end
          end
    end

    # constructs a RestSearchResult from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Coordinate

  # (no documentation provided)
  class RestLogicCoordinate 

    # Identifiers of the STATED assemblage concept.
    attr_accessor :statedAssemblage
    # Identifiers of the INFERRED assemblage concept.
    attr_accessor :inferredAssemblage
    # Identifiers of the description profile assemblage concept.
    attr_accessor :descriptionLogicProfile
    # Identifiers of the classifier assemblage concept.
    attr_accessor :classifier

    # the json hash for this RestLogicCoordinate
    def to_jaxb_json_hash
      _h = {}
      _h['statedAssemblage'] = statedAssemblage.to_jaxb_json_hash unless statedAssemblage.nil?
      _h['inferredAssemblage'] = inferredAssemblage.to_jaxb_json_hash unless inferredAssemblage.nil?
      _h['descriptionLogicProfile'] = descriptionLogicProfile.to_jaxb_json_hash unless descriptionLogicProfile.nil?
      _h['classifier'] = classifier.to_jaxb_json_hash unless classifier.nil?
      return _h
    end

    # the json (string form) for this RestLogicCoordinate
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestLogicCoordinate with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['statedAssemblage'].nil?
          _oa = _o['statedAssemblage']
            if(_oa.is_a? Hash)
              @statedAssemblage = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @statedAssemblage =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @statedAssemblage = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @statedAssemblage.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @statedAssemblage.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @statedAssemblage = _oa
            end
          end
        if !_o['inferredAssemblage'].nil?
          _oa = _o['inferredAssemblage']
            if(_oa.is_a? Hash)
              @inferredAssemblage = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @inferredAssemblage =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @inferredAssemblage = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @inferredAssemblage.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @inferredAssemblage.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @inferredAssemblage = _oa
            end
          end
        if !_o['descriptionLogicProfile'].nil?
          _oa = _o['descriptionLogicProfile']
            if(_oa.is_a? Hash)
              @descriptionLogicProfile = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @descriptionLogicProfile =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @descriptionLogicProfile = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @descriptionLogicProfile.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @descriptionLogicProfile.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @descriptionLogicProfile = _oa
            end
          end
        if !_o['classifier'].nil?
          _oa = _o['classifier']
            if(_oa.is_a? Hash)
              @classifier = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @classifier =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @classifier = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @classifier.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @classifier.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @classifier = _oa
            end
          end
    end

    # constructs a RestLogicCoordinate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Coordinate

  # (no documentation provided)
  class RestTaxonomyCoordinate 

    # Boolean indicating whether or not RestTaxonomyCoordinate is of STATED PremiseType.
    # If TRUE then RestTaxonomyCoordinate is of PremiseType STATED.
    # If FALSE then RestTaxonomyCoordinate is of PremiseType INFERRED.
    attr_accessor :stated
    # RestStampCoordinate component of RestTaxonomyCoordinate
    attr_accessor :stampCoordinate
    # RestLanguageCoordinate component of RestTaxonomyCoordinate
    attr_accessor :languageCoordinate
    # RestLogicCoordinate component of RestTaxonomyCoordinate
    attr_accessor :logicCoordinate

    # the json hash for this RestTaxonomyCoordinate
    def to_jaxb_json_hash
      _h = {}
      _h['stated'] = stated.to_jaxb_json_hash unless stated.nil?
      _h['stampCoordinate'] = stampCoordinate.to_jaxb_json_hash unless stampCoordinate.nil?
      _h['languageCoordinate'] = languageCoordinate.to_jaxb_json_hash unless languageCoordinate.nil?
      _h['logicCoordinate'] = logicCoordinate.to_jaxb_json_hash unless logicCoordinate.nil?
      return _h
    end

    # the json (string form) for this RestTaxonomyCoordinate
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestTaxonomyCoordinate with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['stated'].nil?
          _oa = _o['stated']
            if(_oa.is_a? Hash)
              @stated = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @stated =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @stated = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @stated.push Boolean.from_json(_item)
                 else
                   @stated.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @stated = _oa
            end
          end
        if !_o['stampCoordinate'].nil?
          _oa = _o['stampCoordinate']
            if(_oa.is_a? Hash)
              @stampCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @stampCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestStampCoordinate.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @stampCoordinate = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @stampCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestStampCoordinate.from_json(_item)
                 else
                   @stampCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @stampCoordinate = _oa
            end
          end
        if !_o['languageCoordinate'].nil?
          _oa = _o['languageCoordinate']
            if(_oa.is_a? Hash)
              @languageCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @languageCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLanguageCoordinate.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @languageCoordinate = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @languageCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLanguageCoordinate.from_json(_item)
                 else
                   @languageCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @languageCoordinate = _oa
            end
          end
        if !_o['logicCoordinate'].nil?
          _oa = _o['logicCoordinate']
            if(_oa.is_a? Hash)
              @logicCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @logicCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLogicCoordinate.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @logicCoordinate = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @logicCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLogicCoordinate.from_json(_item)
                 else
                   @logicCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @logicCoordinate = _oa
            end
          end
    end

    # constructs a RestTaxonomyCoordinate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api

module Data

  # (no documentation provided)
  class RestBoolean 

    # (no documentation provided)
    attr_accessor :value

    # the json hash for this RestBoolean
    def to_jaxb_json_hash
      _h = {}
      _h['value'] = value.to_jaxb_json_hash unless value.nil?
      return _h
    end

    # the json (string form) for this RestBoolean
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestBoolean with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['value'].nil?
          _oa = _o['value']
            if(_oa.is_a? Hash)
              @value = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @value =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @value = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @value.push Boolean.from_json(_item)
                 else
                   @value.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @value = _oa
            end
          end
    end

    # constructs a RestBoolean from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

  # (no documentation provided)
  class RestCoordinatesToken 

    # Serialized coordinates token
    attr_accessor :token

    # the json hash for this RestCoordinatesToken
    def to_jaxb_json_hash
      _h = {}
      _h['token'] = token.to_jaxb_json_hash unless token.nil?
      return _h
    end

    # the json (string form) for this RestCoordinatesToken
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestCoordinatesToken with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['token'].nil?
          _oa = _o['token']
            if(_oa.is_a? Hash)
              @token = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @token =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @token = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @token.push String.from_json(_item)
                 else
                   @token.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @token = _oa
            end
          end
    end

    # constructs a RestCoordinatesToken from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Workflow

  # (no documentation provided)
  class RestWorkflowProcessHistory 

    # The identifier data
    attr_accessor :id
    # The process id
    attr_accessor :processId
    # The workflow user
    attr_accessor :userId
    # The time advanced
    attr_accessor :timeAdvanced
    # The state
    attr_accessor :initialState
    # The action
    attr_accessor :action
    # The outcome
    attr_accessor :outcomeState
    # The comment
    attr_accessor :comment

    # the json hash for this RestWorkflowProcessHistory
    def to_jaxb_json_hash
      _h = {}
      _h['id'] = id.to_jaxb_json_hash unless id.nil?
      _h['processId'] = processId.to_jaxb_json_hash unless processId.nil?
      _h['userId'] = userId.to_jaxb_json_hash unless userId.nil?
      _h['timeAdvanced'] = timeAdvanced.to_jaxb_json_hash unless timeAdvanced.nil?
      _h['initialState'] = initialState.to_jaxb_json_hash unless initialState.nil?
      _h['action'] = action.to_jaxb_json_hash unless action.nil?
      _h['outcomeState'] = outcomeState.to_jaxb_json_hash unless outcomeState.nil?
      _h['comment'] = comment.to_jaxb_json_hash unless comment.nil?
      return _h
    end

    # the json (string form) for this RestWorkflowProcessHistory
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestWorkflowProcessHistory with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['id'].nil?
          _oa = _o['id']
            if(_oa.is_a? Hash)
              @id = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @id =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @id = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @id.push String.from_json(_item)
                 else
                   @id.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @id = _oa
            end
          end
        if !_o['processId'].nil?
          _oa = _o['processId']
            if(_oa.is_a? Hash)
              @processId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @processId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @processId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @processId.push String.from_json(_item)
                 else
                   @processId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @processId = _oa
            end
          end
        if !_o['userId'].nil?
          _oa = _o['userId']
            if(_oa.is_a? Hash)
              @userId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @userId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @userId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @userId.push String.from_json(_item)
                 else
                   @userId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @userId = _oa
            end
          end
        if !_o['timeAdvanced'].nil?
          _oa = _o['timeAdvanced']
            if(_oa.is_a? Hash)
              @timeAdvanced = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @timeAdvanced =  Bignum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @timeAdvanced = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @timeAdvanced.push Bignum.from_json(_item)
                 else
                   @timeAdvanced.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @timeAdvanced = _oa
            end
          end
        if !_o['initialState'].nil?
          _oa = _o['initialState']
            if(_oa.is_a? Hash)
              @initialState = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @initialState =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @initialState = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @initialState.push String.from_json(_item)
                 else
                   @initialState.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @initialState = _oa
            end
          end
        if !_o['action'].nil?
          _oa = _o['action']
            if(_oa.is_a? Hash)
              @action = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @action =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @action = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @action.push String.from_json(_item)
                 else
                   @action.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @action = _oa
            end
          end
        if !_o['outcomeState'].nil?
          _oa = _o['outcomeState']
            if(_oa.is_a? Hash)
              @outcomeState = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @outcomeState =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @outcomeState = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @outcomeState.push String.from_json(_item)
                 else
                   @outcomeState.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @outcomeState = _oa
            end
          end
        if !_o['comment'].nil?
          _oa = _o['comment']
            if(_oa.is_a? Hash)
              @comment = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @comment =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @comment = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @comment.push String.from_json(_item)
                 else
                   @comment.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @comment = _oa
            end
          end
    end

    # constructs a RestWorkflowProcessHistory from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestDynamicSememeColumnInfo 

    # The concept sequence number of the concept that represents the column within the dynamic sememe.
    attr_accessor :columnLabelConcept
    # The user-friendly name to display for this column.
    attr_accessor :columnName
    # The user friendly description for this column.  Suitable for things like tooltip descriptions.
    attr_accessor :columnDescription
    # The 0 indexed order of this column within the dynamic sememe.
    attr_accessor :columnOrder
    # The type of data that will be found in this column.  String, Integer, etc.  See
    # rest/1/enumeration/restDynamicSememeDataType for a list of all of the possible data types.
    attr_accessor :columnDataType
    # The default value to use for this column when creating a new sememe (if no user value is specified).
    # This field is optional and may be null.
    attr_accessor :columnDefaultData
    # Does the user have to provide a value for this column in order to create an instance of this sememe.
    attr_accessor :columnRequired
    # The validators types that are attached to this sememe (if any).  Interval, &lt;, etc.  See
    # rest/1/enumeration/restDynamicSememeValidatorType for a list of all possible validator types.
    attr_accessor :columnValidatorTypes
    # The data required to execute the validator type specified in columnValidatorTypes.  The format and type of this field
    # will depend on the columnValidatorTypes field.  The positions within this array will match with the columnValidatorTypes
    # array.
    attr_accessor :columnValidatorData

    # the json hash for this RestDynamicSememeColumnInfo
    def to_jaxb_json_hash
      _h = {}
      _h['columnLabelConcept'] = columnLabelConcept.to_jaxb_json_hash unless columnLabelConcept.nil?
      _h['columnName'] = columnName.to_jaxb_json_hash unless columnName.nil?
      _h['columnDescription'] = columnDescription.to_jaxb_json_hash unless columnDescription.nil?
      _h['columnOrder'] = columnOrder.to_jaxb_json_hash unless columnOrder.nil?
      _h['columnDataType'] = columnDataType.to_jaxb_json_hash unless columnDataType.nil?
      _h['columnDefaultData'] = columnDefaultData.to_jaxb_json_hash unless columnDefaultData.nil?
      _h['columnRequired'] = columnRequired.to_jaxb_json_hash unless columnRequired.nil?
      if !columnValidatorTypes.nil?
        _ha = Array.new
        columnValidatorTypes.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['columnValidatorTypes'] = _ha
      end
      if !columnValidatorData.nil?
        _ha = Array.new
        columnValidatorData.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['columnValidatorData'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestDynamicSememeColumnInfo
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestDynamicSememeColumnInfo with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['columnLabelConcept'].nil?
          _oa = _o['columnLabelConcept']
            if(_oa.is_a? Hash)
              @columnLabelConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnLabelConcept =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnLabelConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnLabelConcept.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @columnLabelConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnLabelConcept = _oa
            end
          end
        if !_o['columnName'].nil?
          _oa = _o['columnName']
            if(_oa.is_a? Hash)
              @columnName = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnName =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnName = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnName.push String.from_json(_item)
                 else
                   @columnName.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnName = _oa
            end
          end
        if !_o['columnDescription'].nil?
          _oa = _o['columnDescription']
            if(_oa.is_a? Hash)
              @columnDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnDescription =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnDescription = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnDescription.push String.from_json(_item)
                 else
                   @columnDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnDescription = _oa
            end
          end
        if !_o['columnOrder'].nil?
          _oa = _o['columnOrder']
            if(_oa.is_a? Hash)
              @columnOrder = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnOrder =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnOrder = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnOrder.push Fixnum.from_json(_item)
                 else
                   @columnOrder.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnOrder = _oa
            end
          end
        if !_o['columnDataType'].nil?
          _oa = _o['columnDataType']
            if(_oa.is_a? Hash)
              @columnDataType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnDataType =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeDataType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnDataType = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnDataType.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeDataType.from_json(_item)
                 else
                   @columnDataType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnDataType = _oa
            end
          end
        if !_o['columnDefaultData'].nil?
          _oa = _o['columnDefaultData']
            if(_oa.is_a? Hash)
              @columnDefaultData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnDefaultData =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnDefaultData = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnDefaultData.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                 else
                   @columnDefaultData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnDefaultData = _oa
            end
          end
        if !_o['columnRequired'].nil?
          _oa = _o['columnRequired']
            if(_oa.is_a? Hash)
              @columnRequired = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnRequired =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnRequired = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnRequired.push Boolean.from_json(_item)
                 else
                   @columnRequired.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnRequired = _oa
            end
          end
        if !_o['columnValidatorTypes'].nil?
          _oa = _o['columnValidatorTypes']
            if(_oa.is_a? Hash)
              @columnValidatorTypes = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnValidatorTypes =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeValidatorType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnValidatorTypes = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnValidatorTypes.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeValidatorType.from_json(_item)
                 else
                   @columnValidatorTypes.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnValidatorTypes = _oa
            end
          end
        if !_o['columnValidatorData'].nil?
          _oa = _o['columnValidatorData']
            if(_oa.is_a? Hash)
              @columnValidatorData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnValidatorData =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnValidatorData = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnValidatorData.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                 else
                   @columnValidatorData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnValidatorData = _oa
            end
          end
    end

    # constructs a RestDynamicSememeColumnInfo from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Systeminfo

  # (no documentation provided)
  class RestIdentifiedObjectsResult 

    # Zero or one concept chronology
    attr_accessor :concept
    # Zero or one sememe chronology
    attr_accessor :sememe

    # the json hash for this RestIdentifiedObjectsResult
    def to_jaxb_json_hash
      _h = {}
      _h['concept'] = concept.to_jaxb_json_hash unless concept.nil?
      _h['sememe'] = sememe.to_jaxb_json_hash unless sememe.nil?
      return _h
    end

    # the json (string form) for this RestIdentifiedObjectsResult
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestIdentifiedObjectsResult with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['concept'].nil?
          _oa = _o['concept']
            if(_oa.is_a? Hash)
              @concept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @concept =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @concept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @concept.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_item)
                 else
                   @concept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @concept = _oa
            end
          end
        if !_o['sememe'].nil?
          _oa = _o['sememe']
            if(_oa.is_a? Hash)
              @sememe = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @sememe =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeChronology.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @sememe = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @sememe.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeChronology.from_json(_item)
                 else
                   @sememe.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @sememe = _oa
            end
          end
    end

    # constructs a RestIdentifiedObjectsResult from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Association

  # (no documentation provided)
  class RestAssociationItemVersionPage 

    # Link to retrieve current page
    attr_accessor :paginationData
    # The contained results
    attr_accessor :results

    # the json hash for this RestAssociationItemVersionPage
    def to_jaxb_json_hash
      _h = {}
      _h['paginationData'] = paginationData.to_jaxb_json_hash unless paginationData.nil?
      if !results.nil?
        _ha = Array.new
        results.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['results'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestAssociationItemVersionPage
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestAssociationItemVersionPage with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['paginationData'].nil?
          _oa = _o['paginationData']
            if(_oa.is_a? Hash)
              @paginationData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @paginationData =  Gov::Vha::Isaac::Rest::Api::Data::Pagination.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @paginationData = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @paginationData.push Gov::Vha::Isaac::Rest::Api::Data::Pagination.from_json(_item)
                 else
                   @paginationData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @paginationData = _oa
            end
          end
        if !_o['results'].nil?
          _oa = _o['results']
            if(_oa.is_a? Hash)
              @results = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @results =  Gov::Vha::Isaac::Rest::Api1::Data::Association::RestAssociationItemVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @results = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @results.push Gov::Vha::Isaac::Rest::Api1::Data::Association::RestAssociationItemVersion.from_json(_item)
                 else
                   @results.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @results = _oa
            end
          end
    end

    # constructs a RestAssociationItemVersionPage from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Coordinate

  # (no documentation provided)
  class RestLanguageCoordinate 

    # Identifier of the language concept associated with the language coordinate.
    # The language will be something like
    # english, spanish, french, danish, polish, dutch,
    # lithuanian, chinese, japanese, or swedish.
    attr_accessor :language
    # Ordered list of dialect assemblage concept identifiers. Order determines preference.
    # A dialect assemblage will be something like US (US Dialect) or GB (Great Britain Dialect).
    attr_accessor :dialectAssemblagePreferences
    # Ordered list of description type concept identifiers. Order determines preference.
    # A description type will be something like FSN (Fully Specified Name), Synonym or Definition.
    attr_accessor :descriptionTypePreferences

    # the json hash for this RestLanguageCoordinate
    def to_jaxb_json_hash
      _h = {}
      _h['language'] = language.to_jaxb_json_hash unless language.nil?
      if !dialectAssemblagePreferences.nil?
        _ha = Array.new
        dialectAssemblagePreferences.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['dialectAssemblagePreferences'] = _ha
      end
      if !descriptionTypePreferences.nil?
        _ha = Array.new
        descriptionTypePreferences.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['descriptionTypePreferences'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestLanguageCoordinate
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestLanguageCoordinate with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['language'].nil?
          _oa = _o['language']
            if(_oa.is_a? Hash)
              @language = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @language =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @language = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @language.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @language.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @language = _oa
            end
          end
        if !_o['dialectAssemblagePreferences'].nil?
          _oa = _o['dialectAssemblagePreferences']
            if(_oa.is_a? Hash)
              @dialectAssemblagePreferences = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @dialectAssemblagePreferences =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @dialectAssemblagePreferences = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @dialectAssemblagePreferences.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @dialectAssemblagePreferences.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @dialectAssemblagePreferences = _oa
            end
          end
        if !_o['descriptionTypePreferences'].nil?
          _oa = _o['descriptionTypePreferences']
            if(_oa.is_a? Hash)
              @descriptionTypePreferences = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @descriptionTypePreferences =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @descriptionTypePreferences = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @descriptionTypePreferences.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @descriptionTypePreferences.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @descriptionTypePreferences = _oa
            end
          end
    end

    # constructs a RestLanguageCoordinate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingSetExtensionValueBase 

    # The value to store for this mapping set extension.  By the API, this could support any implementing type of RestDynamicSememeData - but
    # in practice, the only currently supported types are:
    # RestDynamicSememeString (for arbitrary values) and RestDynamicSememeNid, RestDynamicSememeUUID for storing a reference
    # to another concept or sememe.  Internally, the  UUID type will be mapped to nid - and a read operation will only return RestDynamicSememeString
    # or RestDynamicSememeNid
    attr_accessor :extensionValue
    # The state of the extensionValue.  On read, it will always be returned - true for active, false for inactive.
    # On create or update, true to indicate the extension value should be set as active, false for inactive.
    # This field is optional on create or update, if not provided, it will be assumed to be active.
    attr_accessor :active

    # the json hash for this RestMappingSetExtensionValueBase
    def to_jaxb_json_hash
      _h = {}
      _h['extensionValue'] = extensionValue.to_jaxb_json_hash unless extensionValue.nil?
      _h['active'] = active.to_jaxb_json_hash unless active.nil?
      return _h
    end

    # the json (string form) for this RestMappingSetExtensionValueBase
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestMappingSetExtensionValueBase with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['extensionValue'].nil?
          _oa = _o['extensionValue']
            if(_oa.is_a? Hash)
              @extensionValue = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @extensionValue =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @extensionValue = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @extensionValue.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                 else
                   @extensionValue.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @extensionValue = _oa
            end
          end
        if !_o['active'].nil?
          _oa = _o['active']
            if(_oa.is_a? Hash)
              @active = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @active =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @active = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @active.push Boolean.from_json(_item)
                 else
                   @active.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @active = _oa
            end
          end
    end

    # constructs a RestMappingSetExtensionValueBase from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Association

  # (no documentation provided)
  class RestAssociationItemVersion 

    # The data that was not expanded as part of this call (but can be)
    attr_accessor :expandables
    # The target item in the association.  Typically this is a concept, but it may also be a sememe.  Note that
    # this may be null, in the case where the association intends to represent that no target is available for a particular
    # association type and source component.
    attr_accessor :targetId
    # The concept identifiers of the association type
    attr_accessor :associationType
    # The identifiers of the source item in the association.  Typically this is a concept, but it may also be a sememe.
    attr_accessor :sourceId
    # The sememe identifiers of the sememe that represents this association
    attr_accessor :identifiers
    # The StampedVersion details for this association entry
    attr_accessor :associationItemStamp
    # The Concept Chronology of the concept represented by sourceNid - if the the sourceNid represents a concept.  Blank, unless requested via the expand parameter
    # &#39;source&#39; and the nid represents a concept.  If &#39;source&#39; is passed, you can also pass &#39;versionsAll&#39; or &#39;versionsLatestOnly&#39;
    attr_accessor :sourceConcept
    # The Sememe Chronology of the sememe represented by sourceNid - if the sourceNid represents a sememe.  Blank, unless requested via the expand parameter
    # &#39;source&#39; and the nid represents a sememe.  If &#39;source&#39; is passed, you can also pass &#39;versionsAll&#39;, &#39;versionsLatestOnly&#39;, &#39;nestedSememes&#39;, &#39;referencedDetails&#39;
    attr_accessor :sourceSememe
    # The Concept Chronology of the concept represented by sourceNid.  Typically blank, unless requested via the expand parameter
    # &#39;target&#39;  If &#39;target&#39; is passed, you can also pass &#39;versionsAll&#39; or &#39;versionsLatestOnly&#39;
    attr_accessor :targetConcept
    # The Sememe Chronology of the sememe represented by targetNid - if the targetNid represents a sememe.  Blank, unless requested via the expand parameter
    # &#39;target&#39; and the nid represents a sememe.  If &#39;target&#39; is passed, you can also pass &#39;versionsAll&#39;, &#39;versionsLatestOnly&#39;, &#39;nestedSememes&#39;, &#39;referencedDetails&#39;
    attr_accessor :targetSememe
    # The nested sememes (if any) attached to this association.  Not populated by default, include expand=nestedSememes to expand these.  When &#39;nestedSememes&#39; is passed,
    # you can also pass &#39;referencedDetails&#39; and &#39;chronology&#39;
    attr_accessor :nestedSememes

    # the json hash for this RestAssociationItemVersion
    def to_jaxb_json_hash
      _h = {}
      _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
      _h['targetId'] = targetId.to_jaxb_json_hash unless targetId.nil?
      _h['associationType'] = associationType.to_jaxb_json_hash unless associationType.nil?
      _h['sourceId'] = sourceId.to_jaxb_json_hash unless sourceId.nil?
      _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
      _h['associationItemStamp'] = associationItemStamp.to_jaxb_json_hash unless associationItemStamp.nil?
      _h['sourceConcept'] = sourceConcept.to_jaxb_json_hash unless sourceConcept.nil?
      _h['sourceSememe'] = sourceSememe.to_jaxb_json_hash unless sourceSememe.nil?
      _h['targetConcept'] = targetConcept.to_jaxb_json_hash unless targetConcept.nil?
      _h['targetSememe'] = targetSememe.to_jaxb_json_hash unless targetSememe.nil?
      if !nestedSememes.nil?
        _ha = Array.new
        nestedSememes.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['nestedSememes'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestAssociationItemVersion
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestAssociationItemVersion with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['expandables'].nil?
          _oa = _o['expandables']
            if(_oa.is_a? Hash)
              @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @expandables = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                 else
                   @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @expandables = _oa
            end
          end
        if !_o['targetId'].nil?
          _oa = _o['targetId']
            if(_oa.is_a? Hash)
              @targetId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @targetId =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @targetId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @targetId.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @targetId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @targetId = _oa
            end
          end
        if !_o['associationType'].nil?
          _oa = _o['associationType']
            if(_oa.is_a? Hash)
              @associationType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @associationType =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @associationType = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @associationType.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @associationType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @associationType = _oa
            end
          end
        if !_o['sourceId'].nil?
          _oa = _o['sourceId']
            if(_oa.is_a? Hash)
              @sourceId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @sourceId =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @sourceId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @sourceId.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @sourceId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @sourceId = _oa
            end
          end
        if !_o['identifiers'].nil?
          _oa = _o['identifiers']
            if(_oa.is_a? Hash)
              @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @identifiers = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @identifiers = _oa
            end
          end
        if !_o['associationItemStamp'].nil?
          _oa = _o['associationItemStamp']
            if(_oa.is_a? Hash)
              @associationItemStamp = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @associationItemStamp =  Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @associationItemStamp = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @associationItemStamp.push Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_item)
                 else
                   @associationItemStamp.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @associationItemStamp = _oa
            end
          end
        if !_o['sourceConcept'].nil?
          _oa = _o['sourceConcept']
            if(_oa.is_a? Hash)
              @sourceConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @sourceConcept =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @sourceConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @sourceConcept.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_item)
                 else
                   @sourceConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @sourceConcept = _oa
            end
          end
        if !_o['sourceSememe'].nil?
          _oa = _o['sourceSememe']
            if(_oa.is_a? Hash)
              @sourceSememe = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @sourceSememe =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeChronology.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @sourceSememe = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @sourceSememe.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeChronology.from_json(_item)
                 else
                   @sourceSememe.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @sourceSememe = _oa
            end
          end
        if !_o['targetConcept'].nil?
          _oa = _o['targetConcept']
            if(_oa.is_a? Hash)
              @targetConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @targetConcept =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @targetConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @targetConcept.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_item)
                 else
                   @targetConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @targetConcept = _oa
            end
          end
        if !_o['targetSememe'].nil?
          _oa = _o['targetSememe']
            if(_oa.is_a? Hash)
              @targetSememe = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @targetSememe =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeChronology.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @targetSememe = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @targetSememe.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeChronology.from_json(_item)
                 else
                   @targetSememe.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @targetSememe = _oa
            end
          end
        if !_o['nestedSememes'].nil?
          _oa = _o['nestedSememes']
            if(_oa.is_a? Hash)
              @nestedSememes = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @nestedSememes =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @nestedSememes = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @nestedSememes.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion.from_json(_item)
                 else
                   @nestedSememes.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @nestedSememes = _oa
            end
          end
    end

    # constructs a RestAssociationItemVersion from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api

module Data

module Wrappers

  # (no documentation provided)
  class RestWriteResponse 

    # The RestEditToken value - updated to be valid for a future submit.
    attr_accessor :editToken
    # The UUID value of the item that was created or updated.
    attr_accessor :uuid
    # The Integer NID value of the item created or updated (if applicable, may be null)
    attr_accessor :nid
    # The Integer sequence value of the item created or updated (if applicable, may be null)
    attr_accessor :sequence
    # The type of this object - concept, sememe, or unknown.  (if applicable, may be null)
    attr_accessor :type
    # The type of this object - concept, sememe, or unknown.  (if applicable, may be null)
    attr_accessor :detail

    # the json hash for this RestWriteResponse
    def to_jaxb_json_hash
      _h = {}
      _h['editToken'] = editToken.to_jaxb_json_hash unless editToken.nil?
      _h['uuid'] = uuid.to_jaxb_json_hash unless uuid.nil?
      _h['nid'] = nid.to_jaxb_json_hash unless nid.nil?
      _h['sequence'] = sequence.to_jaxb_json_hash unless sequence.nil?
      _h['type'] = type.to_jaxb_json_hash unless type.nil?
      _h['detail'] = detail.to_jaxb_json_hash unless detail.nil?
      return _h
    end

    # the json (string form) for this RestWriteResponse
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestWriteResponse with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['editToken'].nil?
          _oa = _o['editToken']
            if(_oa.is_a? Hash)
              @editToken = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @editToken =  Gov::Vha::Isaac::Rest::Api1::Data::RestEditToken.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @editToken = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @editToken.push Gov::Vha::Isaac::Rest::Api1::Data::RestEditToken.from_json(_item)
                 else
                   @editToken.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @editToken = _oa
            end
          end
        if !_o['uuid'].nil?
          _oa = _o['uuid']
            if(_oa.is_a? Hash)
              @uuid = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @uuid =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @uuid = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @uuid.push String.from_json(_item)
                 else
                   @uuid.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @uuid = _oa
            end
          end
        if !_o['nid'].nil?
          _oa = _o['nid']
            if(_oa.is_a? Hash)
              @nid = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @nid =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @nid = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @nid.push Fixnum.from_json(_item)
                 else
                   @nid.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @nid = _oa
            end
          end
        if !_o['sequence'].nil?
          _oa = _o['sequence']
            if(_oa.is_a? Hash)
              @sequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @sequence =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @sequence = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @sequence.push Fixnum.from_json(_item)
                 else
                   @sequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @sequence = _oa
            end
          end
        if !_o['type'].nil?
          _oa = _o['type']
            if(_oa.is_a? Hash)
              @type = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @type =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @type = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @type.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_item)
                 else
                   @type.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @type = _oa
            end
          end
        if !_o['detail'].nil?
          _oa = _o['detail']
            if(_oa.is_a? Hash)
              @detail = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @detail =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @detail = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @detail.push String.from_json(_item)
                 else
                   @detail.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @detail = _oa
            end
          end
    end

    # constructs a RestWriteResponse from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Association

  # (no documentation provided)
  class RestAssociationTypeVersionCreate 

    # The best (primary) name of the association, per the user specified stamp coordinates.
    # This would typically be a value like &quot;broader than&quot;
    attr_accessor :associationName
    # The inverse name (if any) of the association, per the user specified stamp coordinates.  This optional
    # field may not be present.  This would typically be a value like &quot;narrower than&quot;
    attr_accessor :associationInverseName
    # The description of the purpose of this association.
    attr_accessor :description

    # the json hash for this RestAssociationTypeVersionCreate
    def to_jaxb_json_hash
      _h = {}
      _h['associationName'] = associationName.to_jaxb_json_hash unless associationName.nil?
      _h['associationInverseName'] = associationInverseName.to_jaxb_json_hash unless associationInverseName.nil?
      _h['description'] = description.to_jaxb_json_hash unless description.nil?
      return _h
    end

    # the json (string form) for this RestAssociationTypeVersionCreate
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestAssociationTypeVersionCreate with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['associationName'].nil?
          _oa = _o['associationName']
            if(_oa.is_a? Hash)
              @associationName = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @associationName =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @associationName = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @associationName.push String.from_json(_item)
                 else
                   @associationName.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @associationName = _oa
            end
          end
        if !_o['associationInverseName'].nil?
          _oa = _o['associationInverseName']
            if(_oa.is_a? Hash)
              @associationInverseName = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @associationInverseName =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @associationInverseName = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @associationInverseName.push String.from_json(_item)
                 else
                   @associationInverseName.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @associationInverseName = _oa
            end
          end
        if !_o['description'].nil?
          _oa = _o['description']
            if(_oa.is_a? Hash)
              @description = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @description =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @description = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @description.push String.from_json(_item)
                 else
                   @description.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @description = _oa
            end
          end
    end

    # constructs a RestAssociationTypeVersionCreate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Workflow

  # (no documentation provided)
  class RestWorkflowDefinition 

    # The definition identifier
    attr_accessor :id
    # The bpmn2 id that contains the definition if it exists.
    attr_accessor :bpmn2Id
    # The definition name.
    attr_accessor :name
    # The definition namespace.
    attr_accessor :namespace
    # The version of the definition.
    attr_accessor :version
    # The workflow roles available defined via the definition .
    attr_accessor :roles

    # the json hash for this RestWorkflowDefinition
    def to_jaxb_json_hash
      _h = {}
      _h['id'] = id.to_jaxb_json_hash unless id.nil?
      _h['bpmn2Id'] = bpmn2Id.to_jaxb_json_hash unless bpmn2Id.nil?
      _h['name'] = name.to_jaxb_json_hash unless name.nil?
      _h['namespace'] = namespace.to_jaxb_json_hash unless namespace.nil?
      _h['version'] = version.to_jaxb_json_hash unless version.nil?
      if !roles.nil?
        _ha = Array.new
        roles.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['roles'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestWorkflowDefinition
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestWorkflowDefinition with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['id'].nil?
          _oa = _o['id']
            if(_oa.is_a? Hash)
              @id = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @id =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @id = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @id.push String.from_json(_item)
                 else
                   @id.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @id = _oa
            end
          end
        if !_o['bpmn2Id'].nil?
          _oa = _o['bpmn2Id']
            if(_oa.is_a? Hash)
              @bpmn2Id = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @bpmn2Id =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @bpmn2Id = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @bpmn2Id.push String.from_json(_item)
                 else
                   @bpmn2Id.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @bpmn2Id = _oa
            end
          end
        if !_o['name'].nil?
          _oa = _o['name']
            if(_oa.is_a? Hash)
              @name = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @name =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @name = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @name.push String.from_json(_item)
                 else
                   @name.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @name = _oa
            end
          end
        if !_o['namespace'].nil?
          _oa = _o['namespace']
            if(_oa.is_a? Hash)
              @namespace = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @namespace =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @namespace = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @namespace.push String.from_json(_item)
                 else
                   @namespace.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @namespace = _oa
            end
          end
        if !_o['version'].nil?
          _oa = _o['version']
            if(_oa.is_a? Hash)
              @version = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @version =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @version = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @version.push String.from_json(_item)
                 else
                   @version.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @version = _oa
            end
          end
        if !_o['roles'].nil?
          _oa = _o['roles']
            if(_oa.is_a? Hash)
              @roles = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @roles =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestUserRoleType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @roles = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @roles.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestUserRoleType.from_json(_item)
                 else
                   @roles.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @roles = _oa
            end
          end
    end

    # constructs a RestWorkflowDefinition from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Systeminfo

  # (no documentation provided)
  class RestLicenseInfo 

    # Name of the license
    attr_accessor :name
    # URL to the license text
    attr_accessor :url
    # Comments related to the license
    attr_accessor :comments

    # the json hash for this RestLicenseInfo
    def to_jaxb_json_hash
      _h = {}
      _h['name'] = name.to_jaxb_json_hash unless name.nil?
      _h['url'] = url.to_jaxb_json_hash unless url.nil?
      _h['comments'] = comments.to_jaxb_json_hash unless comments.nil?
      return _h
    end

    # the json (string form) for this RestLicenseInfo
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestLicenseInfo with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['name'].nil?
          _oa = _o['name']
            if(_oa.is_a? Hash)
              @name = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @name =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @name = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @name.push String.from_json(_item)
                 else
                   @name.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @name = _oa
            end
          end
        if !_o['url'].nil?
          _oa = _o['url']
            if(_oa.is_a? Hash)
              @url = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @url =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @url = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @url.push String.from_json(_item)
                 else
                   @url.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @url = _oa
            end
          end
        if !_o['comments'].nil?
          _oa = _o['comments']
            if(_oa.is_a? Hash)
              @comments = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @comments =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @comments = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @comments.push String.from_json(_item)
                 else
                   @comments.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @comments = _oa
            end
          end
    end

    # constructs a RestLicenseInfo from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Workflow

  # (no documentation provided)
  class RestWorkflowStatusCount 

    # Status of the workflow.
    attr_accessor :processStatus
    # Count of workflow processes instances.
    attr_accessor :count

    # the json hash for this RestWorkflowStatusCount
    def to_jaxb_json_hash
      _h = {}
      _h['processStatus'] = processStatus.to_jaxb_json_hash unless processStatus.nil?
      _h['count'] = count.to_jaxb_json_hash unless count.nil?
      return _h
    end

    # the json (string form) for this RestWorkflowStatusCount
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestWorkflowStatusCount with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['processStatus'].nil?
          _oa = _o['processStatus']
            if(_oa.is_a? Hash)
              @processStatus = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @processStatus =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestWorkflowProcessStatusType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @processStatus = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @processStatus.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestWorkflowProcessStatusType.from_json(_item)
                 else
                   @processStatus.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @processStatus = _oa
            end
          end
        if !_o['count'].nil?
          _oa = _o['count']
            if(_oa.is_a? Hash)
              @count = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @count =  Bignum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @count = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @count.push Bignum.from_json(_item)
                 else
                   @count.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @count = _oa
            end
          end
    end

    # constructs a RestWorkflowStatusCount from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

  # (no documentation provided)
  class RestStampedVersion 

    # The State of this version (active, inactive, primordial or cancelled)
    attr_accessor :state
    # The time stamp of this version (in standard java form)
    attr_accessor :time
    # The UUID of the concept that identifies the author of this version
    attr_accessor :authorUUID
    # The UUID of the concept that identifies the module that this version is in
    attr_accessor :moduleUUID
    # The UUID of the concept that identifies the path that this version is in
    attr_accessor :pathUUID

    # the json hash for this RestStampedVersion
    def to_jaxb_json_hash
      _h = {}
      _h['state'] = state.to_jaxb_json_hash unless state.nil?
      _h['time'] = time.to_jaxb_json_hash unless time.nil?
      _h['authorUUID'] = authorUUID.to_jaxb_json_hash unless authorUUID.nil?
      _h['moduleUUID'] = moduleUUID.to_jaxb_json_hash unless moduleUUID.nil?
      _h['pathUUID'] = pathUUID.to_jaxb_json_hash unless pathUUID.nil?
      return _h
    end

    # the json (string form) for this RestStampedVersion
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestStampedVersion with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['state'].nil?
          _oa = _o['state']
            if(_oa.is_a? Hash)
              @state = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @state =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStateType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @state = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @state.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStateType.from_json(_item)
                 else
                   @state.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @state = _oa
            end
          end
        if !_o['time'].nil?
          _oa = _o['time']
            if(_oa.is_a? Hash)
              @time = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @time =  Bignum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @time = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @time.push Bignum.from_json(_item)
                 else
                   @time.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @time = _oa
            end
          end
        if !_o['authorUUID'].nil?
          _oa = _o['authorUUID']
            if(_oa.is_a? Hash)
              @authorUUID = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @authorUUID =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @authorUUID = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @authorUUID.push String.from_json(_item)
                 else
                   @authorUUID.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @authorUUID = _oa
            end
          end
        if !_o['moduleUUID'].nil?
          _oa = _o['moduleUUID']
            if(_oa.is_a? Hash)
              @moduleUUID = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @moduleUUID =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @moduleUUID = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @moduleUUID.push String.from_json(_item)
                 else
                   @moduleUUID.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @moduleUUID = _oa
            end
          end
        if !_o['pathUUID'].nil?
          _oa = _o['pathUUID']
            if(_oa.is_a? Hash)
              @pathUUID = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @pathUUID =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @pathUUID = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @pathUUID.push String.from_json(_item)
                 else
                   @pathUUID.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @pathUUID = _oa
            end
          end
    end

    # constructs a RestStampedVersion from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api

module Data

  # (no documentation provided)
  class Expandables 

    # The list of data types that were not expanded on this request that could be expanded directly, or can
    # be expanded with a second trip by calling the provided URL
    attr_accessor :items

    # the json hash for this Expandables
    def to_jaxb_json_hash
      _h = {}
      if !items.nil?
        _ha = Array.new
        items.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['items'] = _ha
      end
      return _h
    end

    # the json (string form) for this Expandables
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this Expandables with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['items'].nil?
          _oa = _o['items']
            if(_oa.is_a? Hash)
              @items = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @items =  Gov::Vha::Isaac::Rest::Api::Data::Expandable.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @items = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @items.push Gov::Vha::Isaac::Rest::Api::Data::Expandable.from_json(_item)
                 else
                   @items.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @items = _oa
            end
          end
    end

    # constructs a Expandables from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Search

  # (no documentation provided)
  class RestSearchResultPage 

    # Link to retrieve current page
    attr_accessor :paginationData
    # The contained results
    attr_accessor :results

    # the json hash for this RestSearchResultPage
    def to_jaxb_json_hash
      _h = {}
      _h['paginationData'] = paginationData.to_jaxb_json_hash unless paginationData.nil?
      if !results.nil?
        _ha = Array.new
        results.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['results'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestSearchResultPage
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestSearchResultPage with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['paginationData'].nil?
          _oa = _o['paginationData']
            if(_oa.is_a? Hash)
              @paginationData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @paginationData =  Gov::Vha::Isaac::Rest::Api::Data::Pagination.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @paginationData = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @paginationData.push Gov::Vha::Isaac::Rest::Api::Data::Pagination.from_json(_item)
                 else
                   @paginationData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @paginationData = _oa
            end
          end
        if !_o['results'].nil?
          _oa = _o['results']
            if(_oa.is_a? Hash)
              @results = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @results =  Gov::Vha::Isaac::Rest::Api1::Data::Search::RestSearchResult.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @results = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @results.push Gov::Vha::Isaac::Rest::Api1::Data::Search::RestSearchResult.from_json(_item)
                 else
                   @results.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @results = _oa
            end
          end
    end

    # constructs a RestSearchResultPage from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

  # (no documentation provided)
  class RestIdentifiedObject 

    # The globally unique, fixed, stable set of identifiers for the object.  Typically populated, but may be null in edge cases - such as
    # a sequence stored in a dynamic sememe column - one has to refer to the dynamic sememe definition to determine if the sequence represents
    # a concept or a sememe - which is expensive, so it isn&#39;t pre-populated here - which will leave the UUIDs and nid blank.
    attr_accessor :uuids
    # The local-database-only internal nid identifier for this object.  Typically populated, but may be null in edge cases - such as
    # a UUID stored in a dynamic sememe column which doesn&#39;t represent a known object.
    attr_accessor :nid
    # The local-database-only internal sequence identifier for this object.  Typically populated, but may be null in edge cases - such as
    # a UUID stored in a dynamic sememe column which doesn&#39;t represent a known object.
    attr_accessor :sequence
    # A textual description of this identified object.  This field is NOT always populated, and should not be relied on.
    # 
    # It currently always returns null in a production mode - it is only calculated when the service is in debug mode.
    # 
    # It is primarily a debugging aid for developers when looking at returned object in a browser.  When concepts are returned, this will return an
    # arbitrary description for the concept (sometimes - not always.)
    # 
    # When sememes are returned, this is currently not populated at all.
    attr_accessor :description
    # The type of this object - concept, sememe, or unknown.
    attr_accessor :type

    # the json hash for this RestIdentifiedObject
    def to_jaxb_json_hash
      _h = {}
      if !uuids.nil?
        _ha = Array.new
        uuids.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['uuids'] = _ha
      end
      _h['nid'] = nid.to_jaxb_json_hash unless nid.nil?
      _h['sequence'] = sequence.to_jaxb_json_hash unless sequence.nil?
      _h['description'] = description.to_jaxb_json_hash unless description.nil?
      _h['type'] = type.to_jaxb_json_hash unless type.nil?
      return _h
    end

    # the json (string form) for this RestIdentifiedObject
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestIdentifiedObject with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['uuids'].nil?
          _oa = _o['uuids']
            if(_oa.is_a? Hash)
              @uuids = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @uuids =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @uuids = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @uuids.push String.from_json(_item)
                 else
                   @uuids.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @uuids = _oa
            end
          end
        if !_o['nid'].nil?
          _oa = _o['nid']
            if(_oa.is_a? Hash)
              @nid = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @nid =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @nid = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @nid.push Fixnum.from_json(_item)
                 else
                   @nid.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @nid = _oa
            end
          end
        if !_o['sequence'].nil?
          _oa = _o['sequence']
            if(_oa.is_a? Hash)
              @sequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @sequence =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @sequence = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @sequence.push Fixnum.from_json(_item)
                 else
                   @sequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @sequence = _oa
            end
          end
        if !_o['description'].nil?
          _oa = _o['description']
            if(_oa.is_a? Hash)
              @description = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @description =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @description = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @description.push String.from_json(_item)
                 else
                   @description.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @description = _oa
            end
          end
        if !_o['type'].nil?
          _oa = _o['type']
            if(_oa.is_a? Hash)
              @type = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @type =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @type = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @type.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_item)
                 else
                   @type.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @type = _oa
            end
          end
    end

    # constructs a RestIdentifiedObject from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestSememeDescriptionUpdate 

    # The concept identifier (uuid, nid or sequence) of the concept that represents the case significance flag on the description .
    # This should be description case sensitive, description not case sensitive or description initial character sensitive
    attr_accessor :caseSignificanceConcept
    # The optional concept identifier (uuid, nid or sequence) of the concept that represents the language of the description (note, this is NOT
    # the dialect).  If not specified, defaults to ENGLISH
    attr_accessor :languageConcept
    # The text of the description
    attr_accessor :text
    # The concept identifier (uuid, nid or sequence) of the concept that represents the type of the description.
    # This should be FSN, Synonym, or Definition.
    attr_accessor :descriptionTypeConcept
    # An optional concept identifier (nid, sequence or UUID) of a concept that represents an extended type of the description.
    # This may be a concept like Abbreviation or Vista Name.  On Create, if this is left blank, it is simply not added.
    # On Update, if this is not provided, and it was previously specified, then the previous extended type will be inactivated.
    # On Update, to maintain this value, you must submit back the value that it is currently set to.
    attr_accessor :extendedDescriptionTypeConcept
    # True to indicate the mapping set should be set as active, false for inactive.
    # This field is optional, if not provided, it will be assumed to be active.
    attr_accessor :active

    # the json hash for this RestSememeDescriptionUpdate
    def to_jaxb_json_hash
      _h = {}
      _h['caseSignificanceConcept'] = caseSignificanceConcept.to_jaxb_json_hash unless caseSignificanceConcept.nil?
      _h['languageConcept'] = languageConcept.to_jaxb_json_hash unless languageConcept.nil?
      _h['text'] = text.to_jaxb_json_hash unless text.nil?
      _h['descriptionTypeConcept'] = descriptionTypeConcept.to_jaxb_json_hash unless descriptionTypeConcept.nil?
      _h['extendedDescriptionTypeConcept'] = extendedDescriptionTypeConcept.to_jaxb_json_hash unless extendedDescriptionTypeConcept.nil?
      _h['active'] = active.to_jaxb_json_hash unless active.nil?
      return _h
    end

    # the json (string form) for this RestSememeDescriptionUpdate
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestSememeDescriptionUpdate with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['caseSignificanceConcept'].nil?
          _oa = _o['caseSignificanceConcept']
            if(_oa.is_a? Hash)
              @caseSignificanceConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @caseSignificanceConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @caseSignificanceConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @caseSignificanceConcept.push String.from_json(_item)
                 else
                   @caseSignificanceConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @caseSignificanceConcept = _oa
            end
          end
        if !_o['languageConcept'].nil?
          _oa = _o['languageConcept']
            if(_oa.is_a? Hash)
              @languageConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @languageConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @languageConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @languageConcept.push String.from_json(_item)
                 else
                   @languageConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @languageConcept = _oa
            end
          end
        if !_o['text'].nil?
          _oa = _o['text']
            if(_oa.is_a? Hash)
              @text = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @text =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @text = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @text.push String.from_json(_item)
                 else
                   @text.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @text = _oa
            end
          end
        if !_o['descriptionTypeConcept'].nil?
          _oa = _o['descriptionTypeConcept']
            if(_oa.is_a? Hash)
              @descriptionTypeConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @descriptionTypeConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @descriptionTypeConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @descriptionTypeConcept.push String.from_json(_item)
                 else
                   @descriptionTypeConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @descriptionTypeConcept = _oa
            end
          end
        if !_o['extendedDescriptionTypeConcept'].nil?
          _oa = _o['extendedDescriptionTypeConcept']
            if(_oa.is_a? Hash)
              @extendedDescriptionTypeConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @extendedDescriptionTypeConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @extendedDescriptionTypeConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @extendedDescriptionTypeConcept.push String.from_json(_item)
                 else
                   @extendedDescriptionTypeConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @extendedDescriptionTypeConcept = _oa
            end
          end
        if !_o['active'].nil?
          _oa = _o['active']
            if(_oa.is_a? Hash)
              @active = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @active =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @active = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @active.push Boolean.from_json(_item)
                 else
                   @active.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @active = _oa
            end
          end
    end

    # constructs a RestSememeDescriptionUpdate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestDynamicSememeDefinition 

    # The concept sequence of the concept that is used as an assemblage.  The rest of the descriptive details of the
    # sememe assemblage (returned in this object) are read from this concept.
    attr_accessor :assemblageConceptId
    # The &quot;best&quot; description for the concept identified by the assemblageConceptId.  This is selected based on the attributes within the session for
    # stamp and language coordinates - or - if none present - the server default.
    attr_accessor :assemblageConceptDescription
    # the user-friendly description of the overall purpose of this sememe
    attr_accessor :sememeUsageDescription
    # the column information that describes the data that may be returned as part of a sememe instance.
    attr_accessor :columnInfo
    # Return the RestObjectChronologyType of the restriction on referenced components for this sememe (if any - may return null)
    # 
    # If there is a restriction, the nid set for the referenced component in an instance of this sememe must be of the type listed here.
    # 
    # See rest/1/enumeration/restObjectChronologyType for a list of potential object types returned.
    attr_accessor :referencedComponentTypeRestriction
    # Return the RestSememeType of the sub restriction on referenced components for this DynamicSememe (if any - may return null)
    # 
    # If there is a restriction, the nid set for the referenced component in an instance of this sememe must be of the type listed here.
    # 
    # This is only applicable when #referencedComponentTypeRestriction returns RestObjectChronologyType#SEMEME
    # 
    # See rest/1/enumeration/restSememeType for a list of potential object types returned.
    attr_accessor :referencedComponentTypeSubRestriction

    # the json hash for this RestDynamicSememeDefinition
    def to_jaxb_json_hash
      _h = {}
      _h['assemblageConceptId'] = assemblageConceptId.to_jaxb_json_hash unless assemblageConceptId.nil?
      _h['assemblageConceptDescription'] = assemblageConceptDescription.to_jaxb_json_hash unless assemblageConceptDescription.nil?
      _h['sememeUsageDescription'] = sememeUsageDescription.to_jaxb_json_hash unless sememeUsageDescription.nil?
      if !columnInfo.nil?
        _ha = Array.new
        columnInfo.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['columnInfo'] = _ha
      end
      _h['referencedComponentTypeRestriction'] = referencedComponentTypeRestriction.to_jaxb_json_hash unless referencedComponentTypeRestriction.nil?
      _h['referencedComponentTypeSubRestriction'] = referencedComponentTypeSubRestriction.to_jaxb_json_hash unless referencedComponentTypeSubRestriction.nil?
      return _h
    end

    # the json (string form) for this RestDynamicSememeDefinition
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestDynamicSememeDefinition with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['assemblageConceptId'].nil?
          _oa = _o['assemblageConceptId']
            if(_oa.is_a? Hash)
              @assemblageConceptId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @assemblageConceptId =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @assemblageConceptId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @assemblageConceptId.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @assemblageConceptId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @assemblageConceptId = _oa
            end
          end
        if !_o['assemblageConceptDescription'].nil?
          _oa = _o['assemblageConceptDescription']
            if(_oa.is_a? Hash)
              @assemblageConceptDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @assemblageConceptDescription =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @assemblageConceptDescription = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @assemblageConceptDescription.push String.from_json(_item)
                 else
                   @assemblageConceptDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @assemblageConceptDescription = _oa
            end
          end
        if !_o['sememeUsageDescription'].nil?
          _oa = _o['sememeUsageDescription']
            if(_oa.is_a? Hash)
              @sememeUsageDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @sememeUsageDescription =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @sememeUsageDescription = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @sememeUsageDescription.push String.from_json(_item)
                 else
                   @sememeUsageDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @sememeUsageDescription = _oa
            end
          end
        if !_o['columnInfo'].nil?
          _oa = _o['columnInfo']
            if(_oa.is_a? Hash)
              @columnInfo = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnInfo =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfo.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnInfo = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnInfo.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfo.from_json(_item)
                 else
                   @columnInfo.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnInfo = _oa
            end
          end
        if !_o['referencedComponentTypeRestriction'].nil?
          _oa = _o['referencedComponentTypeRestriction']
            if(_oa.is_a? Hash)
              @referencedComponentTypeRestriction = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @referencedComponentTypeRestriction =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @referencedComponentTypeRestriction = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @referencedComponentTypeRestriction.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_item)
                 else
                   @referencedComponentTypeRestriction.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @referencedComponentTypeRestriction = _oa
            end
          end
        if !_o['referencedComponentTypeSubRestriction'].nil?
          _oa = _o['referencedComponentTypeSubRestriction']
            if(_oa.is_a? Hash)
              @referencedComponentTypeSubRestriction = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @referencedComponentTypeSubRestriction =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSememeType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @referencedComponentTypeSubRestriction = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @referencedComponentTypeSubRestriction.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSememeType.from_json(_item)
                 else
                   @referencedComponentTypeSubRestriction.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @referencedComponentTypeSubRestriction = _oa
            end
          end
    end

    # constructs a RestDynamicSememeDefinition from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Concept

  # (no documentation provided)
  class RestConceptUpdateData 

    # True to indicate the concept should be set as active, false for inactive.
    # This field is optional, if not provided, it will be assumed to be active.
    attr_accessor :active

    # the json hash for this RestConceptUpdateData
    def to_jaxb_json_hash
      _h = {}
      _h['active'] = active.to_jaxb_json_hash unless active.nil?
      return _h
    end

    # the json (string form) for this RestConceptUpdateData
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestConceptUpdateData with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['active'].nil?
          _oa = _o['active']
            if(_oa.is_a? Hash)
              @active = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @active =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @active = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @active.push Boolean.from_json(_item)
                 else
                   @active.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @active = _oa
            end
          end
    end

    # constructs a RestConceptUpdateData from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

  # (no documentation provided)
  class RestSystemInfo 

    # The full version number of this API.  Note, this is an array, because in the future
    # the API may simultaneously support versions such as [1.3, 2.0] for reverse compatibility.
    # 
    # The agreement with Komet is that we do &quot;Major.Minor.Revision&quot;
    # The Major version only changes in concert with the rest API paths changing from /1/ to /2/ for example.
    # The Minor version is changed whenever we change a previously existing API or data structure - such that it
    # may break existing code in KOMET.  Note, you can add new APIs / properties to existing data structures without
    # breaking KOMET.
    # The Revision is changed whenever we make a change that modifies the API, but only in a way that won&#39;t impact
    # existing KOMET functionality - such as adding a new API, adding a new data structure, adding a field to an existing
    # data structure.
    attr_accessor :supportedAPIVersions
    # REST API Implementation Version - aka the version number of the software running here.
    attr_accessor :apiImplementationVersion
    # The version number of the database being used by this instance.
    attr_accessor :isaacDbDependency
    # The globally unique UUID assigned to the database (and changesets) that this instance of isaac-rest is running
    # on top of
    attr_accessor :isaacDbId
    # The globally unique UUID assigned to the deployment of isaac-rest.  This is assigned by PRISME at the time that PRISME
    # is deployed (and will only be available if PRISME deployed the service).  This is read from prisme.properties: war_uuid
    attr_accessor :warId
    # Source Code Management URL that contains the source code for the software running here.
    attr_accessor :scmUrl
    # The version of ISAAC that the rest service is running on top of.
    attr_accessor :isaacVersion
    # Software Licenses
    attr_accessor :appLicenses
    # Database Licenses
    attr_accessor :dbLicenses
    # The source content that was built into the underlying database.
    attr_accessor :dbDependencies

    # the json hash for this RestSystemInfo
    def to_jaxb_json_hash
      _h = {}
      if !supportedAPIVersions.nil?
        _ha = Array.new
        supportedAPIVersions.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['supportedAPIVersions'] = _ha
      end
      _h['apiImplementationVersion'] = apiImplementationVersion.to_jaxb_json_hash unless apiImplementationVersion.nil?
      _h['isaacDbDependency'] = isaacDbDependency.to_jaxb_json_hash unless isaacDbDependency.nil?
      _h['isaacDbId'] = isaacDbId.to_jaxb_json_hash unless isaacDbId.nil?
      _h['warId'] = warId.to_jaxb_json_hash unless warId.nil?
      _h['scmUrl'] = scmUrl.to_jaxb_json_hash unless scmUrl.nil?
      _h['isaacVersion'] = isaacVersion.to_jaxb_json_hash unless isaacVersion.nil?
      if !appLicenses.nil?
        _ha = Array.new
        appLicenses.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['appLicenses'] = _ha
      end
      if !dbLicenses.nil?
        _ha = Array.new
        dbLicenses.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['dbLicenses'] = _ha
      end
      if !dbDependencies.nil?
        _ha = Array.new
        dbDependencies.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['dbDependencies'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestSystemInfo
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestSystemInfo with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['supportedAPIVersions'].nil?
          _oa = _o['supportedAPIVersions']
            if(_oa.is_a? Hash)
              @supportedAPIVersions = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @supportedAPIVersions =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @supportedAPIVersions = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @supportedAPIVersions.push String.from_json(_item)
                 else
                   @supportedAPIVersions.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @supportedAPIVersions = _oa
            end
          end
        if !_o['apiImplementationVersion'].nil?
          _oa = _o['apiImplementationVersion']
            if(_oa.is_a? Hash)
              @apiImplementationVersion = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @apiImplementationVersion =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @apiImplementationVersion = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @apiImplementationVersion.push String.from_json(_item)
                 else
                   @apiImplementationVersion.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @apiImplementationVersion = _oa
            end
          end
        if !_o['isaacDbDependency'].nil?
          _oa = _o['isaacDbDependency']
            if(_oa.is_a? Hash)
              @isaacDbDependency = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @isaacDbDependency =  Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestDependencyInfo.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @isaacDbDependency = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @isaacDbDependency.push Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestDependencyInfo.from_json(_item)
                 else
                   @isaacDbDependency.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @isaacDbDependency = _oa
            end
          end
        if !_o['isaacDbId'].nil?
          _oa = _o['isaacDbId']
            if(_oa.is_a? Hash)
              @isaacDbId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @isaacDbId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @isaacDbId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @isaacDbId.push String.from_json(_item)
                 else
                   @isaacDbId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @isaacDbId = _oa
            end
          end
        if !_o['warId'].nil?
          _oa = _o['warId']
            if(_oa.is_a? Hash)
              @warId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @warId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @warId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @warId.push String.from_json(_item)
                 else
                   @warId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @warId = _oa
            end
          end
        if !_o['scmUrl'].nil?
          _oa = _o['scmUrl']
            if(_oa.is_a? Hash)
              @scmUrl = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @scmUrl =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @scmUrl = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @scmUrl.push String.from_json(_item)
                 else
                   @scmUrl.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @scmUrl = _oa
            end
          end
        if !_o['isaacVersion'].nil?
          _oa = _o['isaacVersion']
            if(_oa.is_a? Hash)
              @isaacVersion = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @isaacVersion =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @isaacVersion = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @isaacVersion.push String.from_json(_item)
                 else
                   @isaacVersion.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @isaacVersion = _oa
            end
          end
        if !_o['appLicenses'].nil?
          _oa = _o['appLicenses']
            if(_oa.is_a? Hash)
              @appLicenses = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @appLicenses =  Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestLicenseInfo.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @appLicenses = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @appLicenses.push Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestLicenseInfo.from_json(_item)
                 else
                   @appLicenses.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @appLicenses = _oa
            end
          end
        if !_o['dbLicenses'].nil?
          _oa = _o['dbLicenses']
            if(_oa.is_a? Hash)
              @dbLicenses = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @dbLicenses =  Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestLicenseInfo.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @dbLicenses = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @dbLicenses.push Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestLicenseInfo.from_json(_item)
                 else
                   @dbLicenses.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @dbLicenses = _oa
            end
          end
        if !_o['dbDependencies'].nil?
          _oa = _o['dbDependencies']
            if(_oa.is_a? Hash)
              @dbDependencies = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @dbDependencies =  Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestDependencyInfo.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @dbDependencies = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @dbDependencies.push Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestDependencyInfo.from_json(_item)
                 else
                   @dbDependencies.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @dbDependencies = _oa
            end
          end
    end

    # constructs a RestSystemInfo from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingItemVersionPage 

    # Link to retrieve current page
    attr_accessor :paginationData
    # The contained results
    attr_accessor :results

    # the json hash for this RestMappingItemVersionPage
    def to_jaxb_json_hash
      _h = {}
      _h['paginationData'] = paginationData.to_jaxb_json_hash unless paginationData.nil?
      if !results.nil?
        _ha = Array.new
        results.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['results'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestMappingItemVersionPage
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestMappingItemVersionPage with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['paginationData'].nil?
          _oa = _o['paginationData']
            if(_oa.is_a? Hash)
              @paginationData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @paginationData =  Gov::Vha::Isaac::Rest::Api::Data::Pagination.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @paginationData = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @paginationData.push Gov::Vha::Isaac::Rest::Api::Data::Pagination.from_json(_item)
                 else
                   @paginationData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @paginationData = _oa
            end
          end
        if !_o['results'].nil?
          _oa = _o['results']
            if(_oa.is_a? Hash)
              @results = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @results =  Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingItemVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @results = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @results.push Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingItemVersion.from_json(_item)
                 else
                   @results.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @results = _oa
            end
          end
    end

    # constructs a RestMappingItemVersionPage from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Concept

  # (no documentation provided)
  class RestConceptCreateData 

    # The concept identifiers (UUID, nid or sequence) of the parent concepts of this concept. At least one is required.
    attr_accessor :parentConceptIds
    # The required Fully Specified Name description of this concept.
    attr_accessor :fsn
    # If set to true, and if the provided parentConceptIds all represent concepts that have a common semantic tag, then a semantic tag will be appended to
    # the FSN which matches the semantic tag of the parent concept(s).  Additionally, a preferred term description will be created with the exact value provided
    # by the FSN.  If the parent concepts have multiple semantic tags, an error will be thrown.
    # If not set, or set to false, then:
    # - if the fsn value contains a semantic tag: the FSN will be created exactly as specified, and a preferred term will be created by stripping the semantic tag
    # from the provided value.
    # - if the fsn value does not contain a semantic tag: FSN description will be created and it will carry the exact value of the FSN.  No preferred term will be created
    attr_accessor :calculateSemanticTag
    # The optional language concept (uuid, nid or sequence) associated with the required descriptions.  Will be set to
    # ENGLISH if not specified
    attr_accessor :descriptionLanguageConceptId
    # The optional concept identifiers (uuid, nid or sequence) of the preferred dialects associated with the required description.
    # A default of US ENGLISH will be assigned if not set.
    attr_accessor :descriptionPreferredInDialectAssemblagesConceptIds
    # An optional concept identifier (nid, sequence or UUID) of a concept that represents an extended type of the description.
    # This will be applied to the preferred description created on the concept if #calculateSemanticTag is true.  Will be applied to
    # the FSN description created on the concept if  #calculateSemanticTag is false or absent.
    # This may be a concept like Abbreviation or Vista Name
    attr_accessor :extendedDescriptionTypeConcept
    # True to indicate the concept should be set as active, false for inactive.
    # This field is optional, if not provided, it will be assumed to be active.
    attr_accessor :active

    # the json hash for this RestConceptCreateData
    def to_jaxb_json_hash
      _h = {}
      if !parentConceptIds.nil?
        _ha = Array.new
        parentConceptIds.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['parentConceptIds'] = _ha
      end
      _h['fsn'] = fsn.to_jaxb_json_hash unless fsn.nil?
      _h['calculateSemanticTag'] = calculateSemanticTag.to_jaxb_json_hash unless calculateSemanticTag.nil?
      _h['descriptionLanguageConceptId'] = descriptionLanguageConceptId.to_jaxb_json_hash unless descriptionLanguageConceptId.nil?
      if !descriptionPreferredInDialectAssemblagesConceptIds.nil?
        _ha = Array.new
        descriptionPreferredInDialectAssemblagesConceptIds.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['descriptionPreferredInDialectAssemblagesConceptIds'] = _ha
      end
      _h['extendedDescriptionTypeConcept'] = extendedDescriptionTypeConcept.to_jaxb_json_hash unless extendedDescriptionTypeConcept.nil?
      _h['active'] = active.to_jaxb_json_hash unless active.nil?
      return _h
    end

    # the json (string form) for this RestConceptCreateData
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestConceptCreateData with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['parentConceptIds'].nil?
          _oa = _o['parentConceptIds']
            if(_oa.is_a? Hash)
              @parentConceptIds = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @parentConceptIds =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @parentConceptIds = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @parentConceptIds.push String.from_json(_item)
                 else
                   @parentConceptIds.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @parentConceptIds = _oa
            end
          end
        if !_o['fsn'].nil?
          _oa = _o['fsn']
            if(_oa.is_a? Hash)
              @fsn = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @fsn =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @fsn = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @fsn.push String.from_json(_item)
                 else
                   @fsn.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @fsn = _oa
            end
          end
        if !_o['calculateSemanticTag'].nil?
          _oa = _o['calculateSemanticTag']
            if(_oa.is_a? Hash)
              @calculateSemanticTag = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @calculateSemanticTag =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @calculateSemanticTag = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @calculateSemanticTag.push Boolean.from_json(_item)
                 else
                   @calculateSemanticTag.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @calculateSemanticTag = _oa
            end
          end
        if !_o['descriptionLanguageConceptId'].nil?
          _oa = _o['descriptionLanguageConceptId']
            if(_oa.is_a? Hash)
              @descriptionLanguageConceptId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @descriptionLanguageConceptId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @descriptionLanguageConceptId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @descriptionLanguageConceptId.push String.from_json(_item)
                 else
                   @descriptionLanguageConceptId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @descriptionLanguageConceptId = _oa
            end
          end
        if !_o['descriptionPreferredInDialectAssemblagesConceptIds'].nil?
          _oa = _o['descriptionPreferredInDialectAssemblagesConceptIds']
            if(_oa.is_a? Hash)
              @descriptionPreferredInDialectAssemblagesConceptIds = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @descriptionPreferredInDialectAssemblagesConceptIds =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @descriptionPreferredInDialectAssemblagesConceptIds = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @descriptionPreferredInDialectAssemblagesConceptIds.push String.from_json(_item)
                 else
                   @descriptionPreferredInDialectAssemblagesConceptIds.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @descriptionPreferredInDialectAssemblagesConceptIds = _oa
            end
          end
        if !_o['extendedDescriptionTypeConcept'].nil?
          _oa = _o['extendedDescriptionTypeConcept']
            if(_oa.is_a? Hash)
              @extendedDescriptionTypeConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @extendedDescriptionTypeConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @extendedDescriptionTypeConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @extendedDescriptionTypeConcept.push String.from_json(_item)
                 else
                   @extendedDescriptionTypeConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @extendedDescriptionTypeConcept = _oa
            end
          end
        if !_o['active'].nil?
          _oa = _o['active']
            if(_oa.is_a? Hash)
              @active = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @active =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @active = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @active.push Boolean.from_json(_item)
                 else
                   @active.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @active = _oa
            end
          end
    end

    # constructs a RestConceptCreateData from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

  # (no documentation provided)
  class RestUserInfo 

    # The identifiers of the concept which is a placeholder for a user in the system.
    attr_accessor :userId
    # The unique name of the user, used as the FSN on the concept that represents the user.
    # This value was created from the information passed in via the SSO authentication.
    attr_accessor :uniqueName
    # The user-preferred name of the current user.  This may be identical to the unique name, or it may have been customized by the user.
    attr_accessor :preferredName

    # the json hash for this RestUserInfo
    def to_jaxb_json_hash
      _h = {}
      _h['userId'] = userId.to_jaxb_json_hash unless userId.nil?
      _h['uniqueName'] = uniqueName.to_jaxb_json_hash unless uniqueName.nil?
      _h['preferredName'] = preferredName.to_jaxb_json_hash unless preferredName.nil?
      return _h
    end

    # the json (string form) for this RestUserInfo
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestUserInfo with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['userId'].nil?
          _oa = _o['userId']
            if(_oa.is_a? Hash)
              @userId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @userId =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @userId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @userId.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @userId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @userId = _oa
            end
          end
        if !_o['uniqueName'].nil?
          _oa = _o['uniqueName']
            if(_oa.is_a? Hash)
              @uniqueName = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @uniqueName =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @uniqueName = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @uniqueName.push String.from_json(_item)
                 else
                   @uniqueName.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @uniqueName = _oa
            end
          end
        if !_o['preferredName'].nil?
          _oa = _o['preferredName']
            if(_oa.is_a? Hash)
              @preferredName = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @preferredName =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @preferredName = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @preferredName.push String.from_json(_item)
                 else
                   @preferredName.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @preferredName = _oa
            end
          end
    end

    # constructs a RestUserInfo from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Workflow

  # (no documentation provided)
  class RestWorkflowComponentSummary 

    # The value
    attr_accessor :summary

    # the json hash for this RestWorkflowComponentSummary
    def to_jaxb_json_hash
      _h = {}
      _h['summary'] = summary.to_jaxb_json_hash unless summary.nil?
      return _h
    end

    # the json (string form) for this RestWorkflowComponentSummary
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestWorkflowComponentSummary with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['summary'].nil?
          _oa = _o['summary']
            if(_oa.is_a? Hash)
              @summary = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @summary =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @summary = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @summary.push String.from_json(_item)
                 else
                   @summary.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @summary = _oa
            end
          end
    end

    # constructs a RestWorkflowComponentSummary from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class Enumeration 

    # The enum name of this enumeration type
    attr_accessor :enumName
    # The user-friendly name of this enumeration type - if available.  May be null
    attr_accessor :friendlyName
    # The identifier of this enumeration.  This would be passed back to a call that requested an enum type.
    attr_accessor :enumId

    # the json hash for this Enumeration
    def to_jaxb_json_hash
      _h = {}
      _h['enumName'] = enumName.to_jaxb_json_hash unless enumName.nil?
      _h['friendlyName'] = friendlyName.to_jaxb_json_hash unless friendlyName.nil?
      _h['enumId'] = enumId.to_jaxb_json_hash unless enumId.nil?
      return _h
    end

    # the json (string form) for this Enumeration
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this Enumeration with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['enumName'].nil?
          _oa = _o['enumName']
            if(_oa.is_a? Hash)
              @enumName = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @enumName =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @enumName = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @enumName.push String.from_json(_item)
                 else
                   @enumName.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @enumName = _oa
            end
          end
        if !_o['friendlyName'].nil?
          _oa = _o['friendlyName']
            if(_oa.is_a? Hash)
              @friendlyName = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @friendlyName =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @friendlyName = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @friendlyName.push String.from_json(_item)
                 else
                   @friendlyName.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @friendlyName = _oa
            end
          end
        if !_o['enumId'].nil?
          _oa = _o['enumId']
            if(_oa.is_a? Hash)
              @enumId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @enumId =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @enumId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @enumId.push Fixnum.from_json(_item)
                 else
                   @enumId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @enumId = _oa
            end
          end
    end

    # constructs a Enumeration from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestDynamicSememeColumnInfoCreate 

    # The concept identifier (uuid, nid or sequence) of the concept that represents the column within the dynamic sememe.
    attr_accessor :columnLabelConcept
    # The data type of the value to be stored in this column.
    # 
    # The value passed here can be the value provided by RestDynamicSememeDataType#name or RestDynamicSememeDataType#enumId.
    # To retrieve the valid RestDynamicSememeDataType types, call 1/system/enumeration/restDynamicSememeDataType/
    # 
    # The typical values for this parameter would be &quot;STRING&quot; or &quot;LONG&quot;
    attr_accessor :columnDataType
    # The default value to use for this column when creating a new sememe (if no user value is specified).
    # This field is optional and may be null.
    attr_accessor :columnDefaultData
    # Does the user have to provide a value for this column in order to create an instance of this sememe.
    attr_accessor :columnRequired
    # The validators types that are attached to this sememe (if any).  Interval, &lt;, etc.
    # 
    # The value passed here can be the value provided by RestDynamicSememeValidatorType#name or RestDynamicSememeValidatorType#enumId.
    # To retrieve the valid RestDynamicSememeValidatorType types, call 1/system/enumeration/restDynamicSememeValidatorType/
    attr_accessor :columnValidatorTypes
    # The data required to execute the validator type specified in columnValidatorTypes.  The format and type of this field
    # will depend on the columnValidatorTypes field.  The positions within this array will match with the columnValidatorTypes
    # array.  This optional field should only be populated if the columnValidatorTypes is populated.
    attr_accessor :columnValidatorData

    # the json hash for this RestDynamicSememeColumnInfoCreate
    def to_jaxb_json_hash
      _h = {}
      _h['columnLabelConcept'] = columnLabelConcept.to_jaxb_json_hash unless columnLabelConcept.nil?
      _h['columnDataType'] = columnDataType.to_jaxb_json_hash unless columnDataType.nil?
      _h['columnDefaultData'] = columnDefaultData.to_jaxb_json_hash unless columnDefaultData.nil?
      _h['columnRequired'] = columnRequired.to_jaxb_json_hash unless columnRequired.nil?
      if !columnValidatorTypes.nil?
        _ha = Array.new
        columnValidatorTypes.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['columnValidatorTypes'] = _ha
      end
      if !columnValidatorData.nil?
        _ha = Array.new
        columnValidatorData.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['columnValidatorData'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestDynamicSememeColumnInfoCreate
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestDynamicSememeColumnInfoCreate with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['columnLabelConcept'].nil?
          _oa = _o['columnLabelConcept']
            if(_oa.is_a? Hash)
              @columnLabelConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnLabelConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnLabelConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnLabelConcept.push String.from_json(_item)
                 else
                   @columnLabelConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnLabelConcept = _oa
            end
          end
        if !_o['columnDataType'].nil?
          _oa = _o['columnDataType']
            if(_oa.is_a? Hash)
              @columnDataType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnDataType =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnDataType = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnDataType.push String.from_json(_item)
                 else
                   @columnDataType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnDataType = _oa
            end
          end
        if !_o['columnDefaultData'].nil?
          _oa = _o['columnDefaultData']
            if(_oa.is_a? Hash)
              @columnDefaultData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnDefaultData =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnDefaultData = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnDefaultData.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                 else
                   @columnDefaultData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnDefaultData = _oa
            end
          end
        if !_o['columnRequired'].nil?
          _oa = _o['columnRequired']
            if(_oa.is_a? Hash)
              @columnRequired = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnRequired =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnRequired = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnRequired.push Boolean.from_json(_item)
                 else
                   @columnRequired.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnRequired = _oa
            end
          end
        if !_o['columnValidatorTypes'].nil?
          _oa = _o['columnValidatorTypes']
            if(_oa.is_a? Hash)
              @columnValidatorTypes = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnValidatorTypes =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnValidatorTypes = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnValidatorTypes.push String.from_json(_item)
                 else
                   @columnValidatorTypes.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnValidatorTypes = _oa
            end
          end
        if !_o['columnValidatorData'].nil?
          _oa = _o['columnValidatorData']
            if(_oa.is_a? Hash)
              @columnValidatorData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnValidatorData =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnValidatorData = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnValidatorData.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                 else
                   @columnValidatorData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnValidatorData = _oa
            end
          end
    end

    # constructs a RestDynamicSememeColumnInfoCreate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Coordinate

  # (no documentation provided)
  class RestCoordinates 

    # taxonomyCoordinate
    attr_accessor :taxonomyCoordinate
    # stampCoordinate
    attr_accessor :stampCoordinate
    # languageCoordinate
    attr_accessor :languageCoordinate
    # logicCoordinate
    attr_accessor :logicCoordinate

    # the json hash for this RestCoordinates
    def to_jaxb_json_hash
      _h = {}
      _h['taxonomyCoordinate'] = taxonomyCoordinate.to_jaxb_json_hash unless taxonomyCoordinate.nil?
      _h['stampCoordinate'] = stampCoordinate.to_jaxb_json_hash unless stampCoordinate.nil?
      _h['languageCoordinate'] = languageCoordinate.to_jaxb_json_hash unless languageCoordinate.nil?
      _h['logicCoordinate'] = logicCoordinate.to_jaxb_json_hash unless logicCoordinate.nil?
      return _h
    end

    # the json (string form) for this RestCoordinates
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestCoordinates with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['taxonomyCoordinate'].nil?
          _oa = _o['taxonomyCoordinate']
            if(_oa.is_a? Hash)
              @taxonomyCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @taxonomyCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestTaxonomyCoordinate.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @taxonomyCoordinate = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @taxonomyCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestTaxonomyCoordinate.from_json(_item)
                 else
                   @taxonomyCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @taxonomyCoordinate = _oa
            end
          end
        if !_o['stampCoordinate'].nil?
          _oa = _o['stampCoordinate']
            if(_oa.is_a? Hash)
              @stampCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @stampCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestStampCoordinate.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @stampCoordinate = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @stampCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestStampCoordinate.from_json(_item)
                 else
                   @stampCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @stampCoordinate = _oa
            end
          end
        if !_o['languageCoordinate'].nil?
          _oa = _o['languageCoordinate']
            if(_oa.is_a? Hash)
              @languageCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @languageCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLanguageCoordinate.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @languageCoordinate = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @languageCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLanguageCoordinate.from_json(_item)
                 else
                   @languageCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @languageCoordinate = _oa
            end
          end
        if !_o['logicCoordinate'].nil?
          _oa = _o['logicCoordinate']
            if(_oa.is_a? Hash)
              @logicCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @logicCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLogicCoordinate.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @logicCoordinate = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @logicCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLogicCoordinate.from_json(_item)
                 else
                   @logicCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @logicCoordinate = _oa
            end
          end
    end

    # constructs a RestCoordinates from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Workflow

  # (no documentation provided)
  class RestWorkflowAvailableAction 

    # The identifier
    attr_accessor :id
    # The definition id
    attr_accessor :definitionId
    # The initial state
    attr_accessor :initialState
    # The action
    attr_accessor :action
    # The outcome state
    attr_accessor :outcomeState
    # The role
    attr_accessor :role

    # the json hash for this RestWorkflowAvailableAction
    def to_jaxb_json_hash
      _h = {}
      _h['id'] = id.to_jaxb_json_hash unless id.nil?
      _h['definitionId'] = definitionId.to_jaxb_json_hash unless definitionId.nil?
      _h['initialState'] = initialState.to_jaxb_json_hash unless initialState.nil?
      _h['action'] = action.to_jaxb_json_hash unless action.nil?
      _h['outcomeState'] = outcomeState.to_jaxb_json_hash unless outcomeState.nil?
      _h['role'] = role.to_jaxb_json_hash unless role.nil?
      return _h
    end

    # the json (string form) for this RestWorkflowAvailableAction
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestWorkflowAvailableAction with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['id'].nil?
          _oa = _o['id']
            if(_oa.is_a? Hash)
              @id = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @id =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @id = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @id.push String.from_json(_item)
                 else
                   @id.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @id = _oa
            end
          end
        if !_o['definitionId'].nil?
          _oa = _o['definitionId']
            if(_oa.is_a? Hash)
              @definitionId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @definitionId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @definitionId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @definitionId.push String.from_json(_item)
                 else
                   @definitionId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @definitionId = _oa
            end
          end
        if !_o['initialState'].nil?
          _oa = _o['initialState']
            if(_oa.is_a? Hash)
              @initialState = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @initialState =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @initialState = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @initialState.push String.from_json(_item)
                 else
                   @initialState.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @initialState = _oa
            end
          end
        if !_o['action'].nil?
          _oa = _o['action']
            if(_oa.is_a? Hash)
              @action = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @action =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @action = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @action.push String.from_json(_item)
                 else
                   @action.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @action = _oa
            end
          end
        if !_o['outcomeState'].nil?
          _oa = _o['outcomeState']
            if(_oa.is_a? Hash)
              @outcomeState = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @outcomeState =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @outcomeState = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @outcomeState.push String.from_json(_item)
                 else
                   @outcomeState.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @outcomeState = _oa
            end
          end
        if !_o['role'].nil?
          _oa = _o['role']
            if(_oa.is_a? Hash)
              @role = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @role =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestUserRoleType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @role = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @role.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestUserRoleType.from_json(_item)
                 else
                   @role.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @role = _oa
            end
          end
    end

    # constructs a RestWorkflowAvailableAction from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingItemVersionBase 

    # The (optional) extended fields which carry additional information about this map item.  For details on these fields, read
    # the info returned as part of the RestMappingSetVersion#mapItemFieldsDefinition field
    attr_accessor :mapItemExtendedFields

    # the json hash for this RestMappingItemVersionBase
    def to_jaxb_json_hash
      _h = {}
      if !mapItemExtendedFields.nil?
        _ha = Array.new
        mapItemExtendedFields.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['mapItemExtendedFields'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestMappingItemVersionBase
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestMappingItemVersionBase with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['mapItemExtendedFields'].nil?
          _oa = _o['mapItemExtendedFields']
            if(_oa.is_a? Hash)
              @mapItemExtendedFields = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @mapItemExtendedFields =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @mapItemExtendedFields = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @mapItemExtendedFields.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                 else
                   @mapItemExtendedFields.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @mapItemExtendedFields = _oa
            end
          end
    end

    # constructs a RestMappingItemVersionBase from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestSememeChronology 

    # The data that was not expanded as part of this call (but can be)
    attr_accessor :expandables
    # The concept sequence identifier of the concept that represents the type of this sememe
    attr_accessor :assemblage
    # The identifier of the object that is referenced by this sememe instance.  This could represent a concept or a sememe.
    attr_accessor :referencedComponent
    # If the referencedComponentNid represents a concept, then this carries the &quot;best&quot; description for that concept.  This is selected based on the
    # attributes within the session for  stamp and language coordinates - or - if none present - the server default.  This is not populated if the
    # referencedComponentNid is a sememe type.
    # Only populated when the expand parameter &#39;referencedDetails&#39; is passed.
    attr_accessor :referencedComponentNidDescription
    # The permanent identifiers attached to this sememe instance
    attr_accessor :identifiers
    # The list of sememe versions.  Depending on the expand parameter, may be empty, the latest only, or all versions.
    attr_accessor :versions

    # the json hash for this RestSememeChronology
    def to_jaxb_json_hash
      _h = {}
      _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
      _h['assemblage'] = assemblage.to_jaxb_json_hash unless assemblage.nil?
      _h['referencedComponent'] = referencedComponent.to_jaxb_json_hash unless referencedComponent.nil?
      _h['referencedComponentNidDescription'] = referencedComponentNidDescription.to_jaxb_json_hash unless referencedComponentNidDescription.nil?
      _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
      if !versions.nil?
        _ha = Array.new
        versions.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['versions'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestSememeChronology
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestSememeChronology with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['expandables'].nil?
          _oa = _o['expandables']
            if(_oa.is_a? Hash)
              @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @expandables = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                 else
                   @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @expandables = _oa
            end
          end
        if !_o['assemblage'].nil?
          _oa = _o['assemblage']
            if(_oa.is_a? Hash)
              @assemblage = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @assemblage =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @assemblage = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @assemblage.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @assemblage.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @assemblage = _oa
            end
          end
        if !_o['referencedComponent'].nil?
          _oa = _o['referencedComponent']
            if(_oa.is_a? Hash)
              @referencedComponent = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @referencedComponent =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @referencedComponent = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @referencedComponent.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @referencedComponent.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @referencedComponent = _oa
            end
          end
        if !_o['referencedComponentNidDescription'].nil?
          _oa = _o['referencedComponentNidDescription']
            if(_oa.is_a? Hash)
              @referencedComponentNidDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @referencedComponentNidDescription =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @referencedComponentNidDescription = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @referencedComponentNidDescription.push String.from_json(_item)
                 else
                   @referencedComponentNidDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @referencedComponentNidDescription = _oa
            end
          end
        if !_o['identifiers'].nil?
          _oa = _o['identifiers']
            if(_oa.is_a? Hash)
              @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @identifiers = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @identifiers = _oa
            end
          end
        if !_o['versions'].nil?
          _oa = _o['versions']
            if(_oa.is_a? Hash)
              @versions = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @versions =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @versions = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @versions.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion.from_json(_item)
                 else
                   @versions.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @versions = _oa
            end
          end
    end

    # constructs a RestSememeChronology from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingSetDisplayFieldCreate 

    # ID that identifies this display field.  Depending on the value of fieldComponenetType, this may be one of three distinct types:
    # 
    # 1) when fieldComponentType below is set to ITEM_EXTENDED, this should be the integer column number that represents the columnPosition
    # of the extended field (extensionValue.columnNumber)
    # 2)  when fieldComponentType below is set to a value such as SOURCE or TARGET - This required value must be an ID pulled from
    # 1/mapping/fields[.id], which will be a UUID
    attr_accessor :id
    # This should be a enumName or enumId from the available values at /1/mapping/fieldComponentTypes - however in the case where the id is set to an id
    # from 1/mapping/fields, the value can more easily be populated from 1/mapping/fields[.componentType]
    # 
    # Example values of for this field are SOURCE, ITEM_EXTENDED
    attr_accessor :fieldComponentType

    # the json hash for this RestMappingSetDisplayFieldCreate
    def to_jaxb_json_hash
      _h = {}
      _h['id'] = id.to_jaxb_json_hash unless id.nil?
      _h['fieldComponentType'] = fieldComponentType.to_jaxb_json_hash unless fieldComponentType.nil?
      return _h
    end

    # the json (string form) for this RestMappingSetDisplayFieldCreate
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestMappingSetDisplayFieldCreate with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['id'].nil?
          _oa = _o['id']
            if(_oa.is_a? Hash)
              @id = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @id =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @id = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @id.push String.from_json(_item)
                 else
                   @id.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @id = _oa
            end
          end
        if !_o['fieldComponentType'].nil?
          _oa = _o['fieldComponentType']
            if(_oa.is_a? Hash)
              @fieldComponentType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @fieldComponentType =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @fieldComponentType = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @fieldComponentType.push String.from_json(_item)
                 else
                   @fieldComponentType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @fieldComponentType = _oa
            end
          end
    end

    # constructs a RestMappingSetDisplayFieldCreate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Logic

  # (no documentation provided)
  class RestLogicNode 

    # The RestNodeSemanticType type of this node corresponding to the NodeSemantic enum
    attr_accessor :nodeSemantic
    # The UUID of the logic node itself (not of any referenced or associated component or concept)
    attr_accessor :nodeUuid
    # The list of child RestLogicNode instances contained within this RestLogicNode.
    # A RestTypedConnctorNode may have exactly one child node
    # A literal node may not have any child nodes at all
    # Others may have one or more child nodes
    attr_accessor :children

    # the json hash for this RestLogicNode
    def to_jaxb_json_hash
      _h = {}
      _h['nodeSemantic'] = nodeSemantic.to_jaxb_json_hash unless nodeSemantic.nil?
      _h['nodeUuid'] = nodeUuid.to_jaxb_json_hash unless nodeUuid.nil?
      if !children.nil?
        _ha = Array.new
        children.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['children'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestLogicNode
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestLogicNode with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['nodeSemantic'].nil?
          _oa = _o['nodeSemantic']
            if(_oa.is_a? Hash)
              @nodeSemantic = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @nodeSemantic =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestNodeSemanticType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @nodeSemantic = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @nodeSemantic.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestNodeSemanticType.from_json(_item)
                 else
                   @nodeSemantic.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @nodeSemantic = _oa
            end
          end
        if !_o['nodeUuid'].nil?
          _oa = _o['nodeUuid']
            if(_oa.is_a? Hash)
              @nodeUuid = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @nodeUuid =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @nodeUuid = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @nodeUuid.push String.from_json(_item)
                 else
                   @nodeUuid.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @nodeUuid = _oa
            end
          end
        if !_o['children'].nil?
          _oa = _o['children']
            if(_oa.is_a? Hash)
              @children = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @children =  Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @children = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @children.push Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode.from_json(_item)
                 else
                   @children.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @children = _oa
            end
          end
    end

    # constructs a RestLogicNode from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestSememeVersion 

    # The data that was not expanded as part of this call (but can be)
    attr_accessor :expandables
    # The sememe chronology for this concept.  Depending on the expand parameter, may be empty.
    attr_accessor :sememeChronology
    # The StampedVersion details for this version of this sememe.
    attr_accessor :sememeVersion
    # The nested sememes attached to this sememe.  Not populated by default, include expand=nested to expand these.
    attr_accessor :nestedSememes

    # the json hash for this RestSememeVersion
    def to_jaxb_json_hash
      _h = {}
      _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
      _h['sememeChronology'] = sememeChronology.to_jaxb_json_hash unless sememeChronology.nil?
      _h['sememeVersion'] = sememeVersion.to_jaxb_json_hash unless sememeVersion.nil?
      if !nestedSememes.nil?
        _ha = Array.new
        nestedSememes.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['nestedSememes'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestSememeVersion
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestSememeVersion with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['expandables'].nil?
          _oa = _o['expandables']
            if(_oa.is_a? Hash)
              @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @expandables = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                 else
                   @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @expandables = _oa
            end
          end
        if !_o['sememeChronology'].nil?
          _oa = _o['sememeChronology']
            if(_oa.is_a? Hash)
              @sememeChronology = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @sememeChronology =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeChronology.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @sememeChronology = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @sememeChronology.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeChronology.from_json(_item)
                 else
                   @sememeChronology.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @sememeChronology = _oa
            end
          end
        if !_o['sememeVersion'].nil?
          _oa = _o['sememeVersion']
            if(_oa.is_a? Hash)
              @sememeVersion = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @sememeVersion =  Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @sememeVersion = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @sememeVersion.push Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_item)
                 else
                   @sememeVersion.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @sememeVersion = _oa
            end
          end
        if !_o['nestedSememes'].nil?
          _oa = _o['nestedSememes']
            if(_oa.is_a? Hash)
              @nestedSememes = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @nestedSememes =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @nestedSememes = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @nestedSememes.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeVersion.from_json(_item)
                 else
                   @nestedSememes.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @nestedSememes = _oa
            end
          end
    end

    # constructs a RestSememeVersion from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api

module Exceptions

  # (no documentation provided)
  class RestExceptionResponse 

    # (no documentation provided)
    attr_accessor :status
    # (no documentation provided)
    attr_accessor :relevantQueryParameterValue
    # (no documentation provided)
    attr_accessor :relevantQueryParameterName
    # (no documentation provided)
    attr_accessor :conciseMessage
    # (no documentation provided)
    attr_accessor :verboseMessage

    # the json hash for this RestExceptionResponse
    def to_jaxb_json_hash
      _h = {}
      _h['status'] = status.to_jaxb_json_hash unless status.nil?
      _h['relevantQueryParameterValue'] = relevantQueryParameterValue.to_jaxb_json_hash unless relevantQueryParameterValue.nil?
      _h['relevantQueryParameterName'] = relevantQueryParameterName.to_jaxb_json_hash unless relevantQueryParameterName.nil?
      _h['conciseMessage'] = conciseMessage.to_jaxb_json_hash unless conciseMessage.nil?
      _h['verboseMessage'] = verboseMessage.to_jaxb_json_hash unless verboseMessage.nil?
      return _h
    end

    # the json (string form) for this RestExceptionResponse
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestExceptionResponse with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['status'].nil?
          _oa = _o['status']
            if(_oa.is_a? Hash)
              @status = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @status =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @status = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @status.push String.from_json(_item)
                 else
                   @status.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @status = _oa
            end
          end
        if !_o['relevantQueryParameterValue'].nil?
          _oa = _o['relevantQueryParameterValue']
            if(_oa.is_a? Hash)
              @relevantQueryParameterValue = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @relevantQueryParameterValue =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @relevantQueryParameterValue = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @relevantQueryParameterValue.push String.from_json(_item)
                 else
                   @relevantQueryParameterValue.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @relevantQueryParameterValue = _oa
            end
          end
        if !_o['relevantQueryParameterName'].nil?
          _oa = _o['relevantQueryParameterName']
            if(_oa.is_a? Hash)
              @relevantQueryParameterName = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @relevantQueryParameterName =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @relevantQueryParameterName = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @relevantQueryParameterName.push String.from_json(_item)
                 else
                   @relevantQueryParameterName.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @relevantQueryParameterName = _oa
            end
          end
        if !_o['conciseMessage'].nil?
          _oa = _o['conciseMessage']
            if(_oa.is_a? Hash)
              @conciseMessage = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @conciseMessage =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @conciseMessage = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @conciseMessage.push String.from_json(_item)
                 else
                   @conciseMessage.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @conciseMessage = _oa
            end
          end
        if !_o['verboseMessage'].nil?
          _oa = _o['verboseMessage']
            if(_oa.is_a? Hash)
              @verboseMessage = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @verboseMessage =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @verboseMessage = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @verboseMessage.push String.from_json(_item)
                 else
                   @verboseMessage.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @verboseMessage = _oa
            end
          end
    end

    # constructs a RestExceptionResponse from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

  # (no documentation provided)
  class RestEditToken 

    # Serialized coordinates token
    attr_accessor :token

    # the json hash for this RestEditToken
    def to_jaxb_json_hash
      _h = {}
      _h['token'] = token.to_jaxb_json_hash unless token.nil?
      return _h
    end

    # the json (string form) for this RestEditToken
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestEditToken with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['token'].nil?
          _oa = _o['token']
            if(_oa.is_a? Hash)
              @token = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @token =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @token = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @token.push String.from_json(_item)
                 else
                   @token.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @token = _oa
            end
          end
    end

    # constructs a RestEditToken from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api

module Data

  # (no documentation provided)
  class Expandable 

    # The name of the item that is expandable (pass this to have this value expanded directly by the call that produced this)
    attr_accessor :name
    # The url to call to get the expanded item separately
    attr_accessor :url

    # the json hash for this Expandable
    def to_jaxb_json_hash
      _h = {}
      _h['name'] = name.to_jaxb_json_hash unless name.nil?
      _h['url'] = url.to_jaxb_json_hash unless url.nil?
      return _h
    end

    # the json (string form) for this Expandable
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this Expandable with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['name'].nil?
          _oa = _o['name']
            if(_oa.is_a? Hash)
              @name = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @name =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @name = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @name.push String.from_json(_item)
                 else
                   @name.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @name = _oa
            end
          end
        if !_o['url'].nil?
          _oa = _o['url']
            if(_oa.is_a? Hash)
              @url = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @url =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @url = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @url.push String.from_json(_item)
                 else
                   @url.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @url = _oa
            end
          end
    end

    # constructs a Expandable from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

  # (no documentation provided)
  class RestId 

    # The id value
    attr_accessor :value
    # The id type
    attr_accessor :idType

    # the json hash for this RestId
    def to_jaxb_json_hash
      _h = {}
      _h['value'] = value.to_jaxb_json_hash unless value.nil?
      _h['idType'] = idType.to_jaxb_json_hash unless idType.nil?
      return _h
    end

    # the json (string form) for this RestId
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestId with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['value'].nil?
          _oa = _o['value']
            if(_oa.is_a? Hash)
              @value = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @value =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @value = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @value.push String.from_json(_item)
                 else
                   @value.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @value = _oa
            end
          end
        if !_o['idType'].nil?
          _oa = _o['idType']
            if(_oa.is_a? Hash)
              @idType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @idType =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSupportedIdType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @idType = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @idType.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSupportedIdType.from_json(_item)
                 else
                   @idType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @idType = _oa
            end
          end
    end

    # constructs a RestId from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Coordinate

  # (no documentation provided)
  class RestStampCoordinate 

    # Long epoch time component of the RestStampCoordinate.
    # Corresponds to the time component of the StampPosition component of the OCHRE StampCoordinate.
    # A value of 9223372036854775807 (Long.MAX_TIME) indicates that the StampCoordinate specifies LATEST
    attr_accessor :time
    # Sequence number of the path concept.
    # Corresponds to the path component of the StampPosition component of the OCHRE StampCoordinate
    attr_accessor :path
    # RestStampPrecedenceType Enumeration specifying precedence. Values are either PATH or TIME.
    attr_accessor :precedence
    # Set of module concept identifiers.
    attr_accessor :modules
    # Set of RestStateType Enumeration values determining allowed RestStateType values.
    # Values include INACTIVE, ACTIVE, PRIMORDIAL and CANCELLED.
    attr_accessor :allowedStates

    # the json hash for this RestStampCoordinate
    def to_jaxb_json_hash
      _h = {}
      _h['time'] = time.to_jaxb_json_hash unless time.nil?
      _h['path'] = path.to_jaxb_json_hash unless path.nil?
      _h['precedence'] = precedence.to_jaxb_json_hash unless precedence.nil?
      if !modules.nil?
        _ha = Array.new
        modules.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['modules'] = _ha
      end
      if !allowedStates.nil?
        _ha = Array.new
        allowedStates.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['allowedStates'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestStampCoordinate
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestStampCoordinate with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['time'].nil?
          _oa = _o['time']
            if(_oa.is_a? Hash)
              @time = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @time =  Bignum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @time = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @time.push Bignum.from_json(_item)
                 else
                   @time.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @time = _oa
            end
          end
        if !_o['path'].nil?
          _oa = _o['path']
            if(_oa.is_a? Hash)
              @path = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @path =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @path = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @path.push Fixnum.from_json(_item)
                 else
                   @path.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @path = _oa
            end
          end
        if !_o['precedence'].nil?
          _oa = _o['precedence']
            if(_oa.is_a? Hash)
              @precedence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @precedence =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStampPrecedenceType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @precedence = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @precedence.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStampPrecedenceType.from_json(_item)
                 else
                   @precedence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @precedence = _oa
            end
          end
        if !_o['modules'].nil?
          _oa = _o['modules']
            if(_oa.is_a? Hash)
              @modules = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @modules =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @modules = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @modules.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @modules.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @modules = _oa
            end
          end
        if !_o['allowedStates'].nil?
          _oa = _o['allowedStates']
            if(_oa.is_a? Hash)
              @allowedStates = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @allowedStates =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStateType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @allowedStates = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @allowedStates.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStateType.from_json(_item)
                 else
                   @allowedStates.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @allowedStates = _oa
            end
          end
    end

    # constructs a RestStampCoordinate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingSetDisplayFieldBase 

    # The unique ID that identifies this display field.  Depending on the value of componenetType, this may be one of three distinct types:
    # 
    # 1) when componentType below is set to ITEM_EXTENDED, this should be the integer column number that represents the columnPosition
    # of the extended field (extensionValue.columnNumber)
    # 2)  when fieldComponentType below is set to a value such as SOURCE or TARGET - This required value must be an ID pulled from
    # 1/mapping/fields[.id]. - and will be returned as a UUID.
    # the ID returned should be utilized to link the column position of this display field in the RestMappingSetVersion.displayFields list
    # with the ID found in RestMappingItemComputedDisplayField, when placing items on screen.
    attr_accessor :id
    # An optional value that describes the type of this display field - which will come from the available values at /1/mapping/fieldComponentTypes
    # 
    # Example values of for this field are SOURCE, ITEM_EXTENDED, etc
    # 
    # This is only populated in the context of a mapset that already has a field order assigned.  When this class is returned in a way that it only
    # expresses the possible display fields, this will be null.
    attr_accessor :componentType

    # the json hash for this RestMappingSetDisplayFieldBase
    def to_jaxb_json_hash
      _h = {}
      _h['id'] = id.to_jaxb_json_hash unless id.nil?
      _h['componentType'] = componentType.to_jaxb_json_hash unless componentType.nil?
      return _h
    end

    # the json (string form) for this RestMappingSetDisplayFieldBase
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestMappingSetDisplayFieldBase with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['id'].nil?
          _oa = _o['id']
            if(_oa.is_a? Hash)
              @id = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @id =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @id = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @id.push String.from_json(_item)
                 else
                   @id.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @id = _oa
            end
          end
        if !_o['componentType'].nil?
          _oa = _o['componentType']
            if(_oa.is_a? Hash)
              @componentType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @componentType =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestMapSetItemComponentType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @componentType = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @componentType.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestMapSetItemComponentType.from_json(_item)
                 else
                   @componentType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @componentType = _oa
            end
          end
    end

    # constructs a RestMappingSetDisplayFieldBase from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestDynamicSememeData 

    # The 0 indexed column number for this data.  Will not be populated for nested RestDynamicSememeData objects where the &#39;data&#39; field
    # is of type RestDynamicSememeArray.  This field MUST be provided during during a sememe create or update, and it takes priority over
    # the ordering of fields in an array of columns.  Also may be irrelevant in cases where setting DefaultData, or ValidatorData.
    attr_accessor :columnNumber
    # The data for a column within a RestDynamicSememeVersion instance.  The data type of this field depends on the type of class that extends
    # this abstract class.  The mapping of types is: &lt;ClassType&gt; - &lt;Java Data Type&gt;
    # 
    # - RestDynamicSememeBoolean - boolean
    # - RestDynamicSememeByteArray - byte[]
    # - RestDynamicSememeDouble - double
    # - RestDynamicSememeFloat - float
    # - RestDynamicSememeInteger - int
    # - RestDynamicSememeLong - long
    # - RestDynamicSememeString - string
    # - RestDynamicSememeNid - int
    # - RestDynamicSememeSequence - int
    # - RestDynamicSememeUUID - UUID
    # - RestDynamicSememeArray - An array of one of the above types
    # 
    # The data type as returned via the REST interface will be typed however the JSON or XML serializer handles the java types.
    # 
    # When using this class in a create or update call, a special annotation must be included to create the proper type of RestDynamicSememeData
    # because RestDynamicSememeData is an abstract type.
    # 
    # For the server to deserialize the type properly, a field must be included of the form &quot;@class&quot;: &quot;gov.vha.isaac.rest.api1.data.sememe.dataTypes.CLASSTYPE&quot;
    # 
    # where CLASSTYPE is one of:
    # - RestDynamicSememeBoolean
    # - RestDynamicSememeByteArray
    # - RestDynamicSememeDouble
    # - RestDynamicSememeFloat
    # - RestDynamicSememeInteger,
    # - RestDynamicSememeLong,
    # - RestDynamicSememeString,
    # - RestDynamicSememeNid
    # - RestDynamicSememeSequence
    # - RestDynamicSememeUUID
    # - RestDynamicSememeArray
    # 
    # Example JSON that provides two columns of differing types:
    # 
    # ...
    # &quot;restDynamicSememeDataArrayField&quot;: [{
    # &quot;@class&quot;: &quot;gov.vha.isaac.rest.api1.data.sememe.dataTypes.RestDynamicSememeString&quot;,
    # &quot;data&quot;: &quot;test&quot;
    # }, {
    # &quot;@class&quot;: &quot;gov.vha.isaac.rest.api1.data.sememe.dataTypes.RestDynamicSememeLong&quot;,
    # &quot;data&quot;: 5
    # }]
    # }
    attr_accessor :data

    # the json hash for this RestDynamicSememeData
    def to_jaxb_json_hash
      _h = {}
      _h['columnNumber'] = columnNumber.to_jaxb_json_hash unless columnNumber.nil?
      _h['data'] = data.to_jaxb_json_hash unless data.nil?
      return _h
    end

    # the json (string form) for this RestDynamicSememeData
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestDynamicSememeData with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['columnNumber'].nil?
          _oa = _o['columnNumber']
            if(_oa.is_a? Hash)
              @columnNumber = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @columnNumber =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @columnNumber = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @columnNumber.push Fixnum.from_json(_item)
                 else
                   @columnNumber.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @columnNumber = _oa
            end
          end
        if !_o['data'].nil?
          _oa = _o['data']
            if(_oa.is_a? Hash)
              @data = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @data =  Object.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @data = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @data.push Object.from_json(_item)
                 else
                   @data.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @data = _oa
            end
          end
    end

    # constructs a RestDynamicSememeData from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestSememeVersionPage 

    # Link to retrieve current page
    attr_accessor :paginationData
    # The contained results
    attr_accessor :results

    # the json hash for this RestSememeVersionPage
    def to_jaxb_json_hash
      _h = {}
      _h['paginationData'] = paginationData.to_jaxb_json_hash unless paginationData.nil?
      if !results.nil?
        _ha = Array.new
        results.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['results'] = _ha
      end
      return _h
    end

    # the json (string form) for this RestSememeVersionPage
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestSememeVersionPage with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['paginationData'].nil?
          _oa = _o['paginationData']
            if(_oa.is_a? Hash)
              @paginationData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @paginationData =  Gov::Vha::Isaac::Rest::Api::Data::Pagination.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @paginationData = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @paginationData.push Gov::Vha::Isaac::Rest::Api::Data::Pagination.from_json(_item)
                 else
                   @paginationData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @paginationData = _oa
            end
          end
        if !_o['results'].nil?
          _oa = _o['results']
            if(_oa.is_a? Hash)
              @results = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @results =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @results = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @results.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion.from_json(_item)
                 else
                   @results.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @results = _oa
            end
          end
    end

    # constructs a RestSememeVersionPage from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api

module Data

  # (no documentation provided)
  class Pagination 

    # Link to retrieve previous result set page - not provided if no previous page exists.
    attr_accessor :previousUrl
    # Link to retrieve next result set page
    attr_accessor :nextUrl
    # The page (of maximum size pageSize) number from beginning of dataset starting at 1
    attr_accessor :pageNum
    # Estimated size of set of all matching values of which the current page is a subset. Value is negative if and only if unknown. May be affected by filtering.
    attr_accessor :approximateTotal
    # True if the approximateTotal value is an exact count of results, false if the value is an estimate.
    attr_accessor :totalIsExact

    # the json hash for this Pagination
    def to_jaxb_json_hash
      _h = {}
      _h['previousUrl'] = previousUrl.to_jaxb_json_hash unless previousUrl.nil?
      _h['nextUrl'] = nextUrl.to_jaxb_json_hash unless nextUrl.nil?
      _h['pageNum'] = pageNum.to_jaxb_json_hash unless pageNum.nil?
      _h['approximateTotal'] = approximateTotal.to_jaxb_json_hash unless approximateTotal.nil?
      _h['totalIsExact'] = totalIsExact.to_jaxb_json_hash unless totalIsExact.nil?
      return _h
    end

    # the json (string form) for this Pagination
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this Pagination with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['previousUrl'].nil?
          _oa = _o['previousUrl']
            if(_oa.is_a? Hash)
              @previousUrl = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @previousUrl =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @previousUrl = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @previousUrl.push String.from_json(_item)
                 else
                   @previousUrl.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @previousUrl = _oa
            end
          end
        if !_o['nextUrl'].nil?
          _oa = _o['nextUrl']
            if(_oa.is_a? Hash)
              @nextUrl = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @nextUrl =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @nextUrl = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @nextUrl.push String.from_json(_item)
                 else
                   @nextUrl.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @nextUrl = _oa
            end
          end
        if !_o['pageNum'].nil?
          _oa = _o['pageNum']
            if(_oa.is_a? Hash)
              @pageNum = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @pageNum =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @pageNum = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @pageNum.push Fixnum.from_json(_item)
                 else
                   @pageNum.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @pageNum = _oa
            end
          end
        if !_o['approximateTotal'].nil?
          _oa = _o['approximateTotal']
            if(_oa.is_a? Hash)
              @approximateTotal = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @approximateTotal =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @approximateTotal = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @approximateTotal.push Fixnum.from_json(_item)
                 else
                   @approximateTotal.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @approximateTotal = _oa
            end
          end
        if !_o['totalIsExact'].nil?
          _oa = _o['totalIsExact']
            if(_oa.is_a? Hash)
              @totalIsExact = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @totalIsExact =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @totalIsExact = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @totalIsExact.push Boolean.from_json(_item)
                 else
                   @totalIsExact.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @totalIsExact = _oa
            end
          end
    end

    # constructs a Pagination from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Systeminfo

  # (no documentation provided)
  class RestDependencyInfo 

    # Maven Dependency Group ID
    attr_accessor :groupId
    # Maven Dependency Artifact ID
    attr_accessor :artifactId
    # Maven Dependency Version
    attr_accessor :version
    # Maven Dependency Classifier
    attr_accessor :classifier
    # Maven Dependency Type
    attr_accessor :type

    # the json hash for this RestDependencyInfo
    def to_jaxb_json_hash
      _h = {}
      _h['groupId'] = groupId.to_jaxb_json_hash unless groupId.nil?
      _h['artifactId'] = artifactId.to_jaxb_json_hash unless artifactId.nil?
      _h['version'] = version.to_jaxb_json_hash unless version.nil?
      _h['classifier'] = classifier.to_jaxb_json_hash unless classifier.nil?
      _h['type'] = type.to_jaxb_json_hash unless type.nil?
      return _h
    end

    # the json (string form) for this RestDependencyInfo
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestDependencyInfo with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['groupId'].nil?
          _oa = _o['groupId']
            if(_oa.is_a? Hash)
              @groupId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @groupId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @groupId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @groupId.push String.from_json(_item)
                 else
                   @groupId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @groupId = _oa
            end
          end
        if !_o['artifactId'].nil?
          _oa = _o['artifactId']
            if(_oa.is_a? Hash)
              @artifactId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @artifactId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @artifactId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @artifactId.push String.from_json(_item)
                 else
                   @artifactId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @artifactId = _oa
            end
          end
        if !_o['version'].nil?
          _oa = _o['version']
            if(_oa.is_a? Hash)
              @version = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @version =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @version = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @version.push String.from_json(_item)
                 else
                   @version.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @version = _oa
            end
          end
        if !_o['classifier'].nil?
          _oa = _o['classifier']
            if(_oa.is_a? Hash)
              @classifier = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @classifier =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @classifier = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @classifier.push String.from_json(_item)
                 else
                   @classifier.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @classifier = _oa
            end
          end
        if !_o['type'].nil?
          _oa = _o['type']
            if(_oa.is_a? Hash)
              @type = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @type =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @type = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @type.push String.from_json(_item)
                 else
                   @type.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @type = _oa
            end
          end
    end

    # constructs a RestDependencyInfo from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestDynamicSememeTypeCreate 

    # The primary name of this sememe.
    attr_accessor :name
    # The description of this sememe
    attr_accessor :description
    # The (optional) extended fields that are declared for each sememe instance that is created using this sememe definition.
    attr_accessor :dataColumnsDefinition
    # the optional uuid, nid or sequence of the parent concept for the created sememe definition.  If not provided, this defaults to
    # DynamicSememeConstants#DYNAMIC_SEMEME_ASSEMBLAGES
    attr_accessor :parentConcept
    # optional - may be null - if provided - this restricts the type of object referenced by the nid or  UUID that is set for the referenced component
    # in an instance of this sememe.  If ObjectChronologyType#UNKNOWN_NID is passed, it is ignored, as if it were null.
    # 
    # The value passed here can be the value provided by RestObjectChronologyType#name or RestObjectChronologyType#enumId.
    # To retrieve the valid RestObjectChronologyType types, call 1/system/enumeration/restObjectChronologyType/
    # 
    # The typical values for this parameter would be &quot;CONCEPT&quot; or &quot;SEMEME&quot;
    attr_accessor :referencedComponentRestriction
    # optional - may be null - subtype restriction which is applicable when #referencedComponentRestriction is set to SEMEME.
    # 
    # The value passed here can be the value provided by RestSememeType#name or RestSememeType#enumId.
    # To retrieve the valid RestSememeType types, call 1/system/enumeration/restSememeType/
    # 
    # The typical values for this parameter would be &quot;LONG&quot; or &quot;STRING&quot; or &quot;DYNAMIC&quot;
    attr_accessor :referencedComponentSubRestriction

    # the json hash for this RestDynamicSememeTypeCreate
    def to_jaxb_json_hash
      _h = {}
      _h['name'] = name.to_jaxb_json_hash unless name.nil?
      _h['description'] = description.to_jaxb_json_hash unless description.nil?
      if !dataColumnsDefinition.nil?
        _ha = Array.new
        dataColumnsDefinition.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['dataColumnsDefinition'] = _ha
      end
      _h['parentConcept'] = parentConcept.to_jaxb_json_hash unless parentConcept.nil?
      _h['referencedComponentRestriction'] = referencedComponentRestriction.to_jaxb_json_hash unless referencedComponentRestriction.nil?
      _h['referencedComponentSubRestriction'] = referencedComponentSubRestriction.to_jaxb_json_hash unless referencedComponentSubRestriction.nil?
      return _h
    end

    # the json (string form) for this RestDynamicSememeTypeCreate
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this RestDynamicSememeTypeCreate with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['name'].nil?
          _oa = _o['name']
            if(_oa.is_a? Hash)
              @name = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @name =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @name = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @name.push String.from_json(_item)
                 else
                   @name.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @name = _oa
            end
          end
        if !_o['description'].nil?
          _oa = _o['description']
            if(_oa.is_a? Hash)
              @description = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @description =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @description = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @description.push String.from_json(_item)
                 else
                   @description.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @description = _oa
            end
          end
        if !_o['dataColumnsDefinition'].nil?
          _oa = _o['dataColumnsDefinition']
            if(_oa.is_a? Hash)
              @dataColumnsDefinition = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @dataColumnsDefinition =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfoCreate.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @dataColumnsDefinition = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @dataColumnsDefinition.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfoCreate.from_json(_item)
                 else
                   @dataColumnsDefinition.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @dataColumnsDefinition = _oa
            end
          end
        if !_o['parentConcept'].nil?
          _oa = _o['parentConcept']
            if(_oa.is_a? Hash)
              @parentConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @parentConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @parentConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @parentConcept.push String.from_json(_item)
                 else
                   @parentConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @parentConcept = _oa
            end
          end
        if !_o['referencedComponentRestriction'].nil?
          _oa = _o['referencedComponentRestriction']
            if(_oa.is_a? Hash)
              @referencedComponentRestriction = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @referencedComponentRestriction =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @referencedComponentRestriction = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @referencedComponentRestriction.push String.from_json(_item)
                 else
                   @referencedComponentRestriction.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @referencedComponentRestriction = _oa
            end
          end
        if !_o['referencedComponentSubRestriction'].nil?
          _oa = _o['referencedComponentSubRestriction']
            if(_oa.is_a? Hash)
              @referencedComponentSubRestriction = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @referencedComponentSubRestriction =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @referencedComponentSubRestriction = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @referencedComponentSubRestriction.push String.from_json(_item)
                 else
                   @referencedComponentSubRestriction.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @referencedComponentSubRestriction = _oa
            end
          end
    end

    # constructs a RestDynamicSememeTypeCreate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

module DataTypes

  # (no documentation provided)
  class RestDynamicSememeArray < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData 


    # the json hash for this RestDynamicSememeArray
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestDynamicSememeArray with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestDynamicSememeArray from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Logic

  # (no documentation provided)
  class RestConceptNode < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode 

    # The int sequence of the concept referred to by this REST logic graph node
    attr_accessor :concept
    # Optionally-expandable RestConceptVersion corresponding to RestConceptNode concept
    attr_accessor :conceptVersion
    # A boolean indicating whether the concept referred to by this RestConceptVersion is defined rather than primitive
    attr_accessor :isConceptDefined
    # The String text description of the concept referred to by this REST logic graph node. It is included as a convenience, as it may be retrieved based on the concept sequence.
    attr_accessor :conceptDescription

    # the json hash for this RestConceptNode
    def to_jaxb_json_hash
      _h = super
      _h['concept'] = concept.to_jaxb_json_hash unless concept.nil?
      _h['conceptVersion'] = conceptVersion.to_jaxb_json_hash unless conceptVersion.nil?
      _h['isConceptDefined'] = isConceptDefined.to_jaxb_json_hash unless isConceptDefined.nil?
      _h['conceptDescription'] = conceptDescription.to_jaxb_json_hash unless conceptDescription.nil?
      return _h
    end

    #initializes this RestConceptNode with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['concept'].nil?
          _oa = _o['concept']
            if(_oa.is_a? Hash)
              @concept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @concept =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @concept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @concept.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @concept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @concept = _oa
            end
          end
        if !_o['conceptVersion'].nil?
          _oa = _o['conceptVersion']
            if(_oa.is_a? Hash)
              @conceptVersion = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @conceptVersion =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @conceptVersion = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @conceptVersion.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_item)
                 else
                   @conceptVersion.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @conceptVersion = _oa
            end
          end
        if !_o['isConceptDefined'].nil?
          _oa = _o['isConceptDefined']
            if(_oa.is_a? Hash)
              @isConceptDefined = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @isConceptDefined =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @isConceptDefined = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @isConceptDefined.push Boolean.from_json(_item)
                 else
                   @isConceptDefined.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @isConceptDefined = _oa
            end
          end
        if !_o['conceptDescription'].nil?
          _oa = _o['conceptDescription']
            if(_oa.is_a? Hash)
              @conceptDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @conceptDescription =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @conceptDescription = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @conceptDescription.push String.from_json(_item)
                 else
                   @conceptDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @conceptDescription = _oa
            end
          end
    end

    # constructs a RestConceptNode from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Comment

  # (no documentation provided)
  class RestCommentVersionCreate < Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersionBase 

    # The identifier of the component that is being commented on.  Could be a concept or a sememe - as such this accepts UUIDs and Nids (but does not accept sequence
    # identifiers)
    attr_accessor :commentedItem

    # the json hash for this RestCommentVersionCreate
    def to_jaxb_json_hash
      _h = super
      _h['commentedItem'] = commentedItem.to_jaxb_json_hash unless commentedItem.nil?
      return _h
    end

    #initializes this RestCommentVersionCreate with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['commentedItem'].nil?
          _oa = _o['commentedItem']
            if(_oa.is_a? Hash)
              @commentedItem = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @commentedItem =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @commentedItem = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @commentedItem.push String.from_json(_item)
                 else
                   @commentedItem.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @commentedItem = _oa
            end
          end
    end

    # constructs a RestCommentVersionCreate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestNodeSemanticType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestNodeSemanticType
    def to_jaxb_json_hash
      _h = super
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestNodeSemanticType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestNodeSemanticType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestNodeSemanticType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestNodeSemanticType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Logic

  # (no documentation provided)
  class RestLiteralNodeBoolean < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode 

    # RestLiteralNodeBoolean contains a literal boolean value, literalValue
    attr_accessor :literalValue

    # the json hash for this RestLiteralNodeBoolean
    def to_jaxb_json_hash
      _h = super
      _h['literalValue'] = literalValue.to_jaxb_json_hash unless literalValue.nil?
      return _h
    end

    #initializes this RestLiteralNodeBoolean with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['literalValue'].nil?
          _oa = _o['literalValue']
            if(_oa.is_a? Hash)
              @literalValue = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @literalValue =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @literalValue = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @literalValue.push Boolean.from_json(_item)
                 else
                   @literalValue.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @literalValue = _oa
            end
          end
    end

    # constructs a RestLiteralNodeBoolean from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Logic

  # (no documentation provided)
  class RestLiteralNodeInteger < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode 

    # RestLiteralNodeInteger contains a literal int value, literalValue
    attr_accessor :literalValue

    # the json hash for this RestLiteralNodeInteger
    def to_jaxb_json_hash
      _h = super
      _h['literalValue'] = literalValue.to_jaxb_json_hash unless literalValue.nil?
      return _h
    end

    #initializes this RestLiteralNodeInteger with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['literalValue'].nil?
          _oa = _o['literalValue']
            if(_oa.is_a? Hash)
              @literalValue = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @literalValue =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @literalValue = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @literalValue.push Fixnum.from_json(_item)
                 else
                   @literalValue.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @literalValue = _oa
            end
          end
    end

    # constructs a RestLiteralNodeInteger from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestSememeType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestSememeType
    def to_jaxb_json_hash
      _h = super
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestSememeType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSememeType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSememeType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestSememeType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Comment

  # (no documentation provided)
  class RestCommentVersion < Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersionBase 

    # The identifier data for the comment itself
    attr_accessor :identifiers
    # The identifier data of the item the comment is placed on
    attr_accessor :commentedItem
    # The StampedVersion details for this comment
    attr_accessor :commentStamp

    # the json hash for this RestCommentVersion
    def to_jaxb_json_hash
      _h = super
      _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
      _h['commentedItem'] = commentedItem.to_jaxb_json_hash unless commentedItem.nil?
      _h['commentStamp'] = commentStamp.to_jaxb_json_hash unless commentStamp.nil?
      return _h
    end

    #initializes this RestCommentVersion with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['identifiers'].nil?
          _oa = _o['identifiers']
            if(_oa.is_a? Hash)
              @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @identifiers = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @identifiers = _oa
            end
          end
        if !_o['commentedItem'].nil?
          _oa = _o['commentedItem']
            if(_oa.is_a? Hash)
              @commentedItem = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @commentedItem =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @commentedItem = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @commentedItem.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @commentedItem.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @commentedItem = _oa
            end
          end
        if !_o['commentStamp'].nil?
          _oa = _o['commentStamp']
            if(_oa.is_a? Hash)
              @commentStamp = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @commentStamp =  Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @commentStamp = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @commentStamp.push Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_item)
                 else
                   @commentStamp.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @commentStamp = _oa
            end
          end
    end

    # constructs a RestCommentVersion from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

module DataTypes

  # (no documentation provided)
  class RestDynamicSememeLong < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData 


    # the json hash for this RestDynamicSememeLong
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestDynamicSememeLong with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestDynamicSememeLong from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestStampPrecedenceType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestStampPrecedenceType
    def to_jaxb_json_hash
      _h = super
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestStampPrecedenceType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStampPrecedenceType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStampPrecedenceType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestStampPrecedenceType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

module DataTypes

  # (no documentation provided)
  class RestDynamicSememeByteArray < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData 


    # the json hash for this RestDynamicSememeByteArray
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestDynamicSememeByteArray with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestDynamicSememeByteArray from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestDynamicSememeIdentifiedData < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData 

    # When the data type of the sememe is nid, sequence, or UUID, this usually represents a concept or a sememe in the system.  This field carries
    # all of the information about that object, when it is a concept or sememe in the system.  For example, if the data type is nid, the &#39;data&#39; field will
    # be an int that contains the nid.  This filed will contain the (same) nid, but also the sequence, and the data type (concept or sememe).
    # 
    # In some cases, where the data type is a UUID - the UUID may not represent a concept or sememe, in which case, the dataIdentified will carry the UUID,
    # and the data type unknown (but sequence and nid would be blank).
    attr_accessor :dataIdentified
    # If the dataObjectType represents is a concept, then this carries the &quot;best&quot; description for that concept.  This is selected based on the
    # attributes within the session for  stamp and language coordinates - or - if none present - the server default.  This is not populated if the
    # dataObjectType is not a concept type.
    # Only populated when the expand parameter &#39;referencedDetails&#39; is passed.
    attr_accessor :conceptDescription

    # the json hash for this RestDynamicSememeIdentifiedData
    def to_jaxb_json_hash
      _h = super
      _h['dataIdentified'] = dataIdentified.to_jaxb_json_hash unless dataIdentified.nil?
      _h['conceptDescription'] = conceptDescription.to_jaxb_json_hash unless conceptDescription.nil?
      return _h
    end

    #initializes this RestDynamicSememeIdentifiedData with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['dataIdentified'].nil?
          _oa = _o['dataIdentified']
            if(_oa.is_a? Hash)
              @dataIdentified = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @dataIdentified =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @dataIdentified = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @dataIdentified.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @dataIdentified.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @dataIdentified = _oa
            end
          end
        if !_o['conceptDescription'].nil?
          _oa = _o['conceptDescription']
            if(_oa.is_a? Hash)
              @conceptDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @conceptDescription =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @conceptDescription = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @conceptDescription.push String.from_json(_item)
                 else
                   @conceptDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @conceptDescription = _oa
            end
          end
    end

    # constructs a RestDynamicSememeIdentifiedData from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestTaxonomyType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestTaxonomyType
    def to_jaxb_json_hash
      _h = super
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestTaxonomyType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestTaxonomyType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestTaxonomyType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestTaxonomyType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

module DataTypes

  # (no documentation provided)
  class RestDynamicSememeString < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData 


    # the json hash for this RestDynamicSememeString
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestDynamicSememeString with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestDynamicSememeString from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingSetExtensionValue < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValueBase 

    # The selected description of the extensionNameConcept that describes the purpose of this extended field on a map set definition.
    # This is provided as a convenience on read.
    attr_accessor :extensionNameConceptDescription
    # The identifiers of the concept that describes the purpose of this extended field on a map set definition.  The descriptions from this concept
    # will be used as the label of the extension.
    attr_accessor :extensionNameConceptIdentifiers

    # the json hash for this RestMappingSetExtensionValue
    def to_jaxb_json_hash
      _h = super
      _h['extensionNameConceptDescription'] = extensionNameConceptDescription.to_jaxb_json_hash unless extensionNameConceptDescription.nil?
      _h['extensionNameConceptIdentifiers'] = extensionNameConceptIdentifiers.to_jaxb_json_hash unless extensionNameConceptIdentifiers.nil?
      return _h
    end

    #initializes this RestMappingSetExtensionValue with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['extensionNameConceptDescription'].nil?
          _oa = _o['extensionNameConceptDescription']
            if(_oa.is_a? Hash)
              @extensionNameConceptDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @extensionNameConceptDescription =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @extensionNameConceptDescription = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @extensionNameConceptDescription.push String.from_json(_item)
                 else
                   @extensionNameConceptDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @extensionNameConceptDescription = _oa
            end
          end
        if !_o['extensionNameConceptIdentifiers'].nil?
          _oa = _o['extensionNameConceptIdentifiers']
            if(_oa.is_a? Hash)
              @extensionNameConceptIdentifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @extensionNameConceptIdentifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @extensionNameConceptIdentifiers = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @extensionNameConceptIdentifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @extensionNameConceptIdentifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @extensionNameConceptIdentifiers = _oa
            end
          end
    end

    # constructs a RestMappingSetExtensionValue from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Logic

  # (no documentation provided)
  class RestTypedConnectorNode < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode 

    # RestTypedConnectorNode contains an int connectorTypeConceptSequence identifying a connector type concept
    attr_accessor :connectorTypeConcept
    # Optionally-populated connectorTypeConceptVersion
    attr_accessor :connectorTypeConceptVersion
    # RestTypedConnectorNode contains a String connectorTypeConceptDescription describing a connector type concept
    attr_accessor :connectorTypeConceptDescription

    # the json hash for this RestTypedConnectorNode
    def to_jaxb_json_hash
      _h = super
      _h['connectorTypeConcept'] = connectorTypeConcept.to_jaxb_json_hash unless connectorTypeConcept.nil?
      _h['connectorTypeConceptVersion'] = connectorTypeConceptVersion.to_jaxb_json_hash unless connectorTypeConceptVersion.nil?
      _h['connectorTypeConceptDescription'] = connectorTypeConceptDescription.to_jaxb_json_hash unless connectorTypeConceptDescription.nil?
      return _h
    end

    #initializes this RestTypedConnectorNode with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['connectorTypeConcept'].nil?
          _oa = _o['connectorTypeConcept']
            if(_oa.is_a? Hash)
              @connectorTypeConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @connectorTypeConcept =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @connectorTypeConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @connectorTypeConcept.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @connectorTypeConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @connectorTypeConcept = _oa
            end
          end
        if !_o['connectorTypeConceptVersion'].nil?
          _oa = _o['connectorTypeConceptVersion']
            if(_oa.is_a? Hash)
              @connectorTypeConceptVersion = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @connectorTypeConceptVersion =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @connectorTypeConceptVersion = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @connectorTypeConceptVersion.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_item)
                 else
                   @connectorTypeConceptVersion.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @connectorTypeConceptVersion = _oa
            end
          end
        if !_o['connectorTypeConceptDescription'].nil?
          _oa = _o['connectorTypeConceptDescription']
            if(_oa.is_a? Hash)
              @connectorTypeConceptDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @connectorTypeConceptDescription =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @connectorTypeConceptDescription = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @connectorTypeConceptDescription.push String.from_json(_item)
                 else
                   @connectorTypeConceptDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @connectorTypeConceptDescription = _oa
            end
          end
    end

    # constructs a RestTypedConnectorNode from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingSetVersionBaseUpdate < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetVersionBase 

    # The (optional) extended fields which carry additional information about this map set definition.
    attr_accessor :mapSetExtendedFields
    # The (optional) ordered list of fields to be displayed for the mapping set.
    # The passed map set display fields will replace, not update, any existing set.
    # If no fields are passed, then any existing display fields on the map set concept will be removed.
    attr_accessor :displayFields

    # the json hash for this RestMappingSetVersionBaseUpdate
    def to_jaxb_json_hash
      _h = super
      if !mapSetExtendedFields.nil?
        _ha = Array.new
        mapSetExtendedFields.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['mapSetExtendedFields'] = _ha
      end
      if !displayFields.nil?
        _ha = Array.new
        displayFields.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['displayFields'] = _ha
      end
      return _h
    end

    #initializes this RestMappingSetVersionBaseUpdate with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['mapSetExtendedFields'].nil?
          _oa = _o['mapSetExtendedFields']
            if(_oa.is_a? Hash)
              @mapSetExtendedFields = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @mapSetExtendedFields =  Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValueUpdate.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @mapSetExtendedFields = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @mapSetExtendedFields.push Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValueUpdate.from_json(_item)
                 else
                   @mapSetExtendedFields.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @mapSetExtendedFields = _oa
            end
          end
        if !_o['displayFields'].nil?
          _oa = _o['displayFields']
            if(_oa.is_a? Hash)
              @displayFields = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @displayFields =  Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetDisplayFieldCreate.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @displayFields = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @displayFields.push Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetDisplayFieldCreate.from_json(_item)
                 else
                   @displayFields.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @displayFields = _oa
            end
          end
    end

    # constructs a RestMappingSetVersionBaseUpdate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingSetDisplayField < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetDisplayFieldBase 

    # when componentType is set to a value such as SOURCE or TARGET (basically, any type other than ITEM_EXTENDED) the id is set to a UUID
    # that represents a sememe to compute the value from or the UUID constant for the description option, then this field will be populated with the
    # concept represented by the UUID value of the id field.
    # 
    # In any other case, this will not be populated.
    attr_accessor :fieldNameConceptIdentifiers
    # Description of this field
    # If the field id is the ID of an assemblage concept (of a sememe type - where the desired behavior is to return the sememe string value)
    # then it will be the description of that sememe assemblage concept.  A typical value here would be &quot;VUID, though it will be prefixed with source,
    # target, or another prefix, as makes sense in the context.
    attr_accessor :description

    # the json hash for this RestMappingSetDisplayField
    def to_jaxb_json_hash
      _h = super
      _h['fieldNameConceptIdentifiers'] = fieldNameConceptIdentifiers.to_jaxb_json_hash unless fieldNameConceptIdentifiers.nil?
      _h['description'] = description.to_jaxb_json_hash unless description.nil?
      return _h
    end

    #initializes this RestMappingSetDisplayField with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['fieldNameConceptIdentifiers'].nil?
          _oa = _o['fieldNameConceptIdentifiers']
            if(_oa.is_a? Hash)
              @fieldNameConceptIdentifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @fieldNameConceptIdentifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @fieldNameConceptIdentifiers = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @fieldNameConceptIdentifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @fieldNameConceptIdentifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @fieldNameConceptIdentifiers = _oa
            end
          end
        if !_o['description'].nil?
          _oa = _o['description']
            if(_oa.is_a? Hash)
              @description = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @description =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @description = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @description.push String.from_json(_item)
                 else
                   @description.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @description = _oa
            end
          end
    end

    # constructs a RestMappingSetDisplayField from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestObjectChronologyType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestObjectChronologyType
    def to_jaxb_json_hash
      _h = super
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestObjectChronologyType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestObjectChronologyType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Javax

module Ws

module Rs

module Core

  # (no documentation provided)
  class Family

    # 
    INFORMATIONAL = "INFORMATIONAL"

    # 
    SUCCESSFUL = "SUCCESSFUL"

    # 
    REDIRECTION = "REDIRECTION"

    # 
    CLIENT_ERROR = "CLIENT_ERROR"

    # 
    SERVER_ERROR = "SERVER_ERROR"

    # 
    OTHER = "OTHER"
  end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingSetExtensionValueUpdate < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValueBase 

    # The concept (uuid, nid or sequence) that describes the purpose of this extended field on a map set definition.  The descriptions from this concept
    # will be used as the label of the extension.
    attr_accessor :extensionNameConcept

    # the json hash for this RestMappingSetExtensionValueUpdate
    def to_jaxb_json_hash
      _h = super
      _h['extensionNameConcept'] = extensionNameConcept.to_jaxb_json_hash unless extensionNameConcept.nil?
      return _h
    end

    #initializes this RestMappingSetExtensionValueUpdate with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['extensionNameConcept'].nil?
          _oa = _o['extensionNameConcept']
            if(_oa.is_a? Hash)
              @extensionNameConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @extensionNameConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @extensionNameConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @extensionNameConcept.push String.from_json(_item)
                 else
                   @extensionNameConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @extensionNameConcept = _oa
            end
          end
    end

    # constructs a RestMappingSetExtensionValueUpdate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Association

  # (no documentation provided)
  class RestAssociationItemVersionCreate < Gov::Vha::Isaac::Rest::Api1::Data::Association::RestAssociationItemVersionUpdate 

    # The concept uuid, nid or sequence of the association type
    attr_accessor :associationType
    # The nid or UUID of the source item in the association.  Typically this is a concept, but it may also be a sememe.
    # Sequences are not allowed here.
    attr_accessor :sourceId

    # the json hash for this RestAssociationItemVersionCreate
    def to_jaxb_json_hash
      _h = super
      _h['associationType'] = associationType.to_jaxb_json_hash unless associationType.nil?
      _h['sourceId'] = sourceId.to_jaxb_json_hash unless sourceId.nil?
      return _h
    end

    #initializes this RestAssociationItemVersionCreate with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['associationType'].nil?
          _oa = _o['associationType']
            if(_oa.is_a? Hash)
              @associationType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @associationType =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @associationType = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @associationType.push String.from_json(_item)
                 else
                   @associationType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @associationType = _oa
            end
          end
        if !_o['sourceId'].nil?
          _oa = _o['sourceId']
            if(_oa.is_a? Hash)
              @sourceId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @sourceId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @sourceId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @sourceId.push String.from_json(_item)
                 else
                   @sourceId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @sourceId = _oa
            end
          end
    end

    # constructs a RestAssociationItemVersionCreate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

module DataTypes

  # (no documentation provided)
  class RestDynamicSememeDouble < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData 


    # the json hash for this RestDynamicSememeDouble
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestDynamicSememeDouble with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestDynamicSememeDouble from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

module DataTypes

  # (no documentation provided)
  class RestDynamicSememeInteger < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData 


    # the json hash for this RestDynamicSememeInteger
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestDynamicSememeInteger with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestDynamicSememeInteger from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingItemComputedDisplayField < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetDisplayFieldBase 

    # In cases where this field represents a text description value for a calculated item such as source, target, or equivalence type,
    # this will contain the value to display.   This field should always be populated.  This entire object will only be returned
    # for computed fields that have a value.
    attr_accessor :value

    # the json hash for this RestMappingItemComputedDisplayField
    def to_jaxb_json_hash
      _h = super
      _h['value'] = value.to_jaxb_json_hash unless value.nil?
      return _h
    end

    #initializes this RestMappingItemComputedDisplayField with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['value'].nil?
          _oa = _o['value']
            if(_oa.is_a? Hash)
              @value = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @value =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @value = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @value.push String.from_json(_item)
                 else
                   @value.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @value = _oa
            end
          end
    end

    # constructs a RestMappingItemComputedDisplayField from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestSememeDescriptionVersion < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion 

    # The concept sequence of the concept that represents the case significance flag on the description .
    # This should be description case sensitive, description not case sensitive or description initial character sensitive
    attr_accessor :caseSignificanceConcept
    # The concept sequence of the concept that represents the language of the description (note, this is NOT
    # the dialect)
    attr_accessor :languageConcept
    # The text of the description
    attr_accessor :text
    # The concept sequence of the concept that represents the type of the description.
    # This should be FSN, Synonym, or Definition.
    attr_accessor :descriptionTypeConcept
    # The optional concept sequence of the concept that represents the extended type of the description.
    # This should be a MetaData.DYNAMIC_SEMEME_EXTENDED_DESCRIPTION_TYPE.
    attr_accessor :descriptionExtendedTypeConcept
    # The dialects attached to this sememe.  Not populated by default, include expand=nestedSememes to expand this.
    attr_accessor :dialects

    # the json hash for this RestSememeDescriptionVersion
    def to_jaxb_json_hash
      _h = super
      _h['caseSignificanceConcept'] = caseSignificanceConcept.to_jaxb_json_hash unless caseSignificanceConcept.nil?
      _h['languageConcept'] = languageConcept.to_jaxb_json_hash unless languageConcept.nil?
      _h['text'] = text.to_jaxb_json_hash unless text.nil?
      _h['descriptionTypeConcept'] = descriptionTypeConcept.to_jaxb_json_hash unless descriptionTypeConcept.nil?
      _h['descriptionExtendedTypeConcept'] = descriptionExtendedTypeConcept.to_jaxb_json_hash unless descriptionExtendedTypeConcept.nil?
      if !dialects.nil?
        _ha = Array.new
        dialects.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['dialects'] = _ha
      end
      return _h
    end

    #initializes this RestSememeDescriptionVersion with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['caseSignificanceConcept'].nil?
          _oa = _o['caseSignificanceConcept']
            if(_oa.is_a? Hash)
              @caseSignificanceConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @caseSignificanceConcept =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @caseSignificanceConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @caseSignificanceConcept.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @caseSignificanceConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @caseSignificanceConcept = _oa
            end
          end
        if !_o['languageConcept'].nil?
          _oa = _o['languageConcept']
            if(_oa.is_a? Hash)
              @languageConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @languageConcept =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @languageConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @languageConcept.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @languageConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @languageConcept = _oa
            end
          end
        if !_o['text'].nil?
          _oa = _o['text']
            if(_oa.is_a? Hash)
              @text = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @text =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @text = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @text.push String.from_json(_item)
                 else
                   @text.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @text = _oa
            end
          end
        if !_o['descriptionTypeConcept'].nil?
          _oa = _o['descriptionTypeConcept']
            if(_oa.is_a? Hash)
              @descriptionTypeConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @descriptionTypeConcept =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @descriptionTypeConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @descriptionTypeConcept.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @descriptionTypeConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @descriptionTypeConcept = _oa
            end
          end
        if !_o['descriptionExtendedTypeConcept'].nil?
          _oa = _o['descriptionExtendedTypeConcept']
            if(_oa.is_a? Hash)
              @descriptionExtendedTypeConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @descriptionExtendedTypeConcept =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @descriptionExtendedTypeConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @descriptionExtendedTypeConcept.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @descriptionExtendedTypeConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @descriptionExtendedTypeConcept = _oa
            end
          end
        if !_o['dialects'].nil?
          _oa = _o['dialects']
            if(_oa.is_a? Hash)
              @dialects = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @dialects =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @dialects = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @dialects.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeVersion.from_json(_item)
                 else
                   @dialects.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @dialects = _oa
            end
          end
    end

    # constructs a RestSememeDescriptionVersion from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestStateType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestStateType
    def to_jaxb_json_hash
      _h = super
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestStateType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStateType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStateType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestStateType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestWorkflowProcessStatusType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # Displayable text
    attr_accessor :text
    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestWorkflowProcessStatusType
    def to_jaxb_json_hash
      _h = super
      _h['text'] = text.to_jaxb_json_hash unless text.nil?
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestWorkflowProcessStatusType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['text'].nil?
          _oa = _o['text']
            if(_oa.is_a? Hash)
              @text = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @text =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @text = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @text.push String.from_json(_item)
                 else
                   @text.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @text = _oa
            end
          end
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestWorkflowProcessStatusType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestWorkflowProcessStatusType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestWorkflowProcessStatusType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestSupportedIdType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestSupportedIdType
    def to_jaxb_json_hash
      _h = super
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestSupportedIdType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSupportedIdType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSupportedIdType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestSupportedIdType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestMapSetItemComponentType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestMapSetItemComponentType
    def to_jaxb_json_hash
      _h = super
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestMapSetItemComponentType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestMapSetItemComponentType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestMapSetItemComponentType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestMapSetItemComponentType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingSetVersionBaseCreate < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetVersionBase 

    # The (optional) extended fields which carry additional information about this map set definition.
    attr_accessor :mapSetExtendedFields
    # The (optional) extended fields that are declared for each map item instance that is created using this map set definition.
    attr_accessor :mapItemExtendedFieldsDefinition
    # Specifies display fields that should populate each item and respective order
    attr_accessor :displayFields

    # the json hash for this RestMappingSetVersionBaseCreate
    def to_jaxb_json_hash
      _h = super
      if !mapSetExtendedFields.nil?
        _ha = Array.new
        mapSetExtendedFields.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['mapSetExtendedFields'] = _ha
      end
      if !mapItemExtendedFieldsDefinition.nil?
        _ha = Array.new
        mapItemExtendedFieldsDefinition.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['mapItemExtendedFieldsDefinition'] = _ha
      end
      if !displayFields.nil?
        _ha = Array.new
        displayFields.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['displayFields'] = _ha
      end
      return _h
    end

    #initializes this RestMappingSetVersionBaseCreate with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['mapSetExtendedFields'].nil?
          _oa = _o['mapSetExtendedFields']
            if(_oa.is_a? Hash)
              @mapSetExtendedFields = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @mapSetExtendedFields =  Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValueCreate.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @mapSetExtendedFields = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @mapSetExtendedFields.push Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValueCreate.from_json(_item)
                 else
                   @mapSetExtendedFields.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @mapSetExtendedFields = _oa
            end
          end
        if !_o['mapItemExtendedFieldsDefinition'].nil?
          _oa = _o['mapItemExtendedFieldsDefinition']
            if(_oa.is_a? Hash)
              @mapItemExtendedFieldsDefinition = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @mapItemExtendedFieldsDefinition =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfoCreate.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @mapItemExtendedFieldsDefinition = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @mapItemExtendedFieldsDefinition.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfoCreate.from_json(_item)
                 else
                   @mapItemExtendedFieldsDefinition.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @mapItemExtendedFieldsDefinition = _oa
            end
          end
        if !_o['displayFields'].nil?
          _oa = _o['displayFields']
            if(_oa.is_a? Hash)
              @displayFields = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @displayFields =  Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetDisplayFieldCreate.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @displayFields = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @displayFields.push Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetDisplayFieldCreate.from_json(_item)
                 else
                   @displayFields.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @displayFields = _oa
            end
          end
    end

    # constructs a RestMappingSetVersionBaseCreate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Javax

module Ws

module Rs

module Core

  # (no documentation provided)
  class Status

    # 
    OK = "OK"

    # 
    CREATED = "CREATED"

    # 
    ACCEPTED = "ACCEPTED"

    # 
    NO_CONTENT = "NO_CONTENT"

    # 
    RESET_CONTENT = "RESET_CONTENT"

    # 
    PARTIAL_CONTENT = "PARTIAL_CONTENT"

    # 
    MOVED_PERMANENTLY = "MOVED_PERMANENTLY"

    # 
    FOUND = "FOUND"

    # 
    SEE_OTHER = "SEE_OTHER"

    # 
    NOT_MODIFIED = "NOT_MODIFIED"

    # 
    USE_PROXY = "USE_PROXY"

    # 
    TEMPORARY_REDIRECT = "TEMPORARY_REDIRECT"

    # 
    BAD_REQUEST = "BAD_REQUEST"

    # 
    UNAUTHORIZED = "UNAUTHORIZED"

    # 
    PAYMENT_REQUIRED = "PAYMENT_REQUIRED"

    # 
    FORBIDDEN = "FORBIDDEN"

    # 
    NOT_FOUND = "NOT_FOUND"

    # 
    METHOD_NOT_ALLOWED = "METHOD_NOT_ALLOWED"

    # 
    NOT_ACCEPTABLE = "NOT_ACCEPTABLE"

    # 
    PROXY_AUTHENTICATION_REQUIRED = "PROXY_AUTHENTICATION_REQUIRED"

    # 
    REQUEST_TIMEOUT = "REQUEST_TIMEOUT"

    # 
    CONFLICT = "CONFLICT"

    # 
    GONE = "GONE"

    # 
    LENGTH_REQUIRED = "LENGTH_REQUIRED"

    # 
    PRECONDITION_FAILED = "PRECONDITION_FAILED"

    # 
    REQUEST_ENTITY_TOO_LARGE = "REQUEST_ENTITY_TOO_LARGE"

    # 
    REQUEST_URI_TOO_LONG = "REQUEST_URI_TOO_LONG"

    # 
    UNSUPPORTED_MEDIA_TYPE = "UNSUPPORTED_MEDIA_TYPE"

    # 
    REQUESTED_RANGE_NOT_SATISFIABLE = "REQUESTED_RANGE_NOT_SATISFIABLE"

    # 
    EXPECTATION_FAILED = "EXPECTATION_FAILED"

    # 
    INTERNAL_SERVER_ERROR = "INTERNAL_SERVER_ERROR"

    # 
    NOT_IMPLEMENTED = "NOT_IMPLEMENTED"

    # 
    BAD_GATEWAY = "BAD_GATEWAY"

    # 
    SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE"

    # 
    GATEWAY_TIMEOUT = "GATEWAY_TIMEOUT"

    # 
    HTTP_VERSION_NOT_SUPPORTED = "HTTP_VERSION_NOT_SUPPORTED"
  end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Workflow

  # (no documentation provided)
  class RestWorkflowProcess < Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowProcessBaseCreate 

    # The workflow process identifier
    attr_accessor :id
    # The creator concept id
    attr_accessor :creatorId
    # The time workflow process created
    attr_accessor :timeCreated
    # The time workflow process launched
    attr_accessor :timeLaunched
    # The time workflow process cancelled or concluded
    attr_accessor :timeCancelledOrConcluded
    # The defining workflow process status
    attr_accessor :processStatus
    # The workflow process owner
    attr_accessor :ownerId
    # Indicate if process is available to the user
    attr_accessor :userAvailability
    # Indicate the state of the process such Ready for Approval,
    # Ready for Review, or Ready for Edit.
    attr_accessor :state

    # the json hash for this RestWorkflowProcess
    def to_jaxb_json_hash
      _h = super
      _h['id'] = id.to_jaxb_json_hash unless id.nil?
      _h['creatorId'] = creatorId.to_jaxb_json_hash unless creatorId.nil?
      _h['timeCreated'] = timeCreated.to_jaxb_json_hash unless timeCreated.nil?
      _h['timeLaunched'] = timeLaunched.to_jaxb_json_hash unless timeLaunched.nil?
      _h['timeCancelledOrConcluded'] = timeCancelledOrConcluded.to_jaxb_json_hash unless timeCancelledOrConcluded.nil?
      _h['processStatus'] = processStatus.to_jaxb_json_hash unless processStatus.nil?
      _h['ownerId'] = ownerId.to_jaxb_json_hash unless ownerId.nil?
      _h['userAvailability'] = userAvailability.to_jaxb_json_hash unless userAvailability.nil?
      _h['state'] = state.to_jaxb_json_hash unless state.nil?
      return _h
    end

    #initializes this RestWorkflowProcess with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['id'].nil?
          _oa = _o['id']
            if(_oa.is_a? Hash)
              @id = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @id =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @id = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @id.push String.from_json(_item)
                 else
                   @id.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @id = _oa
            end
          end
        if !_o['creatorId'].nil?
          _oa = _o['creatorId']
            if(_oa.is_a? Hash)
              @creatorId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @creatorId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @creatorId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @creatorId.push String.from_json(_item)
                 else
                   @creatorId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @creatorId = _oa
            end
          end
        if !_o['timeCreated'].nil?
          _oa = _o['timeCreated']
            if(_oa.is_a? Hash)
              @timeCreated = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @timeCreated =  Bignum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @timeCreated = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @timeCreated.push Bignum.from_json(_item)
                 else
                   @timeCreated.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @timeCreated = _oa
            end
          end
        if !_o['timeLaunched'].nil?
          _oa = _o['timeLaunched']
            if(_oa.is_a? Hash)
              @timeLaunched = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @timeLaunched =  Bignum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @timeLaunched = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @timeLaunched.push Bignum.from_json(_item)
                 else
                   @timeLaunched.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @timeLaunched = _oa
            end
          end
        if !_o['timeCancelledOrConcluded'].nil?
          _oa = _o['timeCancelledOrConcluded']
            if(_oa.is_a? Hash)
              @timeCancelledOrConcluded = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @timeCancelledOrConcluded =  Bignum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @timeCancelledOrConcluded = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @timeCancelledOrConcluded.push Bignum.from_json(_item)
                 else
                   @timeCancelledOrConcluded.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @timeCancelledOrConcluded = _oa
            end
          end
        if !_o['processStatus'].nil?
          _oa = _o['processStatus']
            if(_oa.is_a? Hash)
              @processStatus = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @processStatus =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestWorkflowProcessStatusType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @processStatus = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @processStatus.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestWorkflowProcessStatusType.from_json(_item)
                 else
                   @processStatus.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @processStatus = _oa
            end
          end
        if !_o['ownerId'].nil?
          _oa = _o['ownerId']
            if(_oa.is_a? Hash)
              @ownerId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @ownerId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @ownerId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @ownerId.push String.from_json(_item)
                 else
                   @ownerId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @ownerId = _oa
            end
          end
        if !_o['userAvailability'].nil?
          _oa = _o['userAvailability']
            if(_oa.is_a? Hash)
              @userAvailability = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @userAvailability =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @userAvailability = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @userAvailability.push String.from_json(_item)
                 else
                   @userAvailability.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @userAvailability = _oa
            end
          end
        if !_o['state'].nil?
          _oa = _o['state']
            if(_oa.is_a? Hash)
              @state = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @state =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @state = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @state.push String.from_json(_item)
                 else
                   @state.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @state = _oa
            end
          end
    end

    # constructs a RestWorkflowProcess from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Logic

  # (no documentation provided)
  class RestLiteralNodeFloat < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode 

    # RestLiteralNodeFloat contains a literal float value, literalValue
    attr_accessor :literalValue

    # the json hash for this RestLiteralNodeFloat
    def to_jaxb_json_hash
      _h = super
      _h['literalValue'] = literalValue.to_jaxb_json_hash unless literalValue.nil?
      return _h
    end

    #initializes this RestLiteralNodeFloat with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['literalValue'].nil?
          _oa = _o['literalValue']
            if(_oa.is_a? Hash)
              @literalValue = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @literalValue =  Float.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @literalValue = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @literalValue.push Float.from_json(_item)
                 else
                   @literalValue.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @literalValue = _oa
            end
          end
    end

    # constructs a RestLiteralNodeFloat from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestSememeLogicGraphVersion < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion 

    # The String text of the description of the associated concept
    attr_accessor :referencedConceptDescription
    # A boolean indicating whether the concept referred to by this
    # RestSememeLogicGraphVersion is defined rather than primitive
    attr_accessor :isReferencedConceptDefined
    # The root node of the logical expression tree associated with the concept
    attr_accessor :rootLogicNode

    # the json hash for this RestSememeLogicGraphVersion
    def to_jaxb_json_hash
      _h = super
      _h['referencedConceptDescription'] = referencedConceptDescription.to_jaxb_json_hash unless referencedConceptDescription.nil?
      _h['isReferencedConceptDefined'] = isReferencedConceptDefined.to_jaxb_json_hash unless isReferencedConceptDefined.nil?
      _h['rootLogicNode'] = rootLogicNode.to_jaxb_json_hash unless rootLogicNode.nil?
      return _h
    end

    #initializes this RestSememeLogicGraphVersion with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['referencedConceptDescription'].nil?
          _oa = _o['referencedConceptDescription']
            if(_oa.is_a? Hash)
              @referencedConceptDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @referencedConceptDescription =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @referencedConceptDescription = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @referencedConceptDescription.push String.from_json(_item)
                 else
                   @referencedConceptDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @referencedConceptDescription = _oa
            end
          end
        if !_o['isReferencedConceptDefined'].nil?
          _oa = _o['isReferencedConceptDefined']
            if(_oa.is_a? Hash)
              @isReferencedConceptDefined = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @isReferencedConceptDefined =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @isReferencedConceptDefined = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @isReferencedConceptDefined.push Boolean.from_json(_item)
                 else
                   @isReferencedConceptDefined.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @isReferencedConceptDefined = _oa
            end
          end
        if !_o['rootLogicNode'].nil?
          _oa = _o['rootLogicNode']
            if(_oa.is_a? Hash)
              @rootLogicNode = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @rootLogicNode =  Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @rootLogicNode = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @rootLogicNode.push Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode.from_json(_item)
                 else
                   @rootLogicNode.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @rootLogicNode = _oa
            end
          end
    end

    # constructs a RestSememeLogicGraphVersion from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

module DataTypes

  # (no documentation provided)
  class RestDynamicSememeBoolean < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData 


    # the json hash for this RestDynamicSememeBoolean
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestDynamicSememeBoolean with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestDynamicSememeBoolean from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingItemVersionUpdate < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingItemVersionBase 

    # The (optional) target concept being mapped by this map item.  This field is optional, and may be blank, if no target mapping
    # is available.  Accepts a nid, sequence or UUID.
    attr_accessor :targetConcept
    # An (optional) concept used to qualify this mapping entry.  Accepts a nid, sequence or UUID.
    attr_accessor :qualifierConcept
    # True to indicate the mapping item should be set as active, false for inactive.
    # This field is optional, if not provided, it will be assumed to be active.
    attr_accessor :active

    # the json hash for this RestMappingItemVersionUpdate
    def to_jaxb_json_hash
      _h = super
      _h['targetConcept'] = targetConcept.to_jaxb_json_hash unless targetConcept.nil?
      _h['qualifierConcept'] = qualifierConcept.to_jaxb_json_hash unless qualifierConcept.nil?
      _h['active'] = active.to_jaxb_json_hash unless active.nil?
      return _h
    end

    #initializes this RestMappingItemVersionUpdate with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['targetConcept'].nil?
          _oa = _o['targetConcept']
            if(_oa.is_a? Hash)
              @targetConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @targetConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @targetConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @targetConcept.push String.from_json(_item)
                 else
                   @targetConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @targetConcept = _oa
            end
          end
        if !_o['qualifierConcept'].nil?
          _oa = _o['qualifierConcept']
            if(_oa.is_a? Hash)
              @qualifierConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @qualifierConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @qualifierConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @qualifierConcept.push String.from_json(_item)
                 else
                   @qualifierConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @qualifierConcept = _oa
            end
          end
        if !_o['active'].nil?
          _oa = _o['active']
            if(_oa.is_a? Hash)
              @active = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @active =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @active = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @active.push Boolean.from_json(_item)
                 else
                   @active.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @active = _oa
            end
          end
    end

    # constructs a RestMappingItemVersionUpdate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestDynamicSememeBaseCreate < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeBase 

    # The concept sequence, nid or UUID that identifies the concept that defined the assemblage of this sememe.
    # This is effectively the type of the sememe being created.
    attr_accessor :assemblageConcept
    # The nid or UUID (may NOT be a sequence) of desired referenced component of the sememe instance.
    attr_accessor :referencedComponent

    # the json hash for this RestDynamicSememeBaseCreate
    def to_jaxb_json_hash
      _h = super
      _h['assemblageConcept'] = assemblageConcept.to_jaxb_json_hash unless assemblageConcept.nil?
      _h['referencedComponent'] = referencedComponent.to_jaxb_json_hash unless referencedComponent.nil?
      return _h
    end

    #initializes this RestDynamicSememeBaseCreate with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['assemblageConcept'].nil?
          _oa = _o['assemblageConcept']
            if(_oa.is_a? Hash)
              @assemblageConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @assemblageConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @assemblageConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @assemblageConcept.push String.from_json(_item)
                 else
                   @assemblageConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @assemblageConcept = _oa
            end
          end
        if !_o['referencedComponent'].nil?
          _oa = _o['referencedComponent']
            if(_oa.is_a? Hash)
              @referencedComponent = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @referencedComponent =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @referencedComponent = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @referencedComponent.push String.from_json(_item)
                 else
                   @referencedComponent.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @referencedComponent = _oa
            end
          end
    end

    # constructs a RestDynamicSememeBaseCreate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Logic

  # (no documentation provided)
  class RestUntypedConnectorNode < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode 


    # the json hash for this RestUntypedConnectorNode
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestUntypedConnectorNode with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestUntypedConnectorNode from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestSememeDescriptionCreate < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeDescriptionUpdate 

    # The optional concepts (UUID, nid or sequence) that represent preferred dialects attached to this sememe.  If not specified,
    # no preferred dialect is added.
    attr_accessor :preferredInDialectAssemblagesIds
    # The optional concepts (UUID, nid or sequence) that represent acceptable dialects attached to this sememe.  If not specified,
    # no acceptable dialect is added.
    attr_accessor :acceptableInDialectAssemblagesIds
    # The identifier (UUID or nid) of the component to which this sememe refers.  May NOT be a sequence identifier.
    attr_accessor :referencedComponentId

    # the json hash for this RestSememeDescriptionCreate
    def to_jaxb_json_hash
      _h = super
      if !preferredInDialectAssemblagesIds.nil?
        _ha = Array.new
        preferredInDialectAssemblagesIds.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['preferredInDialectAssemblagesIds'] = _ha
      end
      if !acceptableInDialectAssemblagesIds.nil?
        _ha = Array.new
        acceptableInDialectAssemblagesIds.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['acceptableInDialectAssemblagesIds'] = _ha
      end
      _h['referencedComponentId'] = referencedComponentId.to_jaxb_json_hash unless referencedComponentId.nil?
      return _h
    end

    #initializes this RestSememeDescriptionCreate with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['preferredInDialectAssemblagesIds'].nil?
          _oa = _o['preferredInDialectAssemblagesIds']
            if(_oa.is_a? Hash)
              @preferredInDialectAssemblagesIds = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @preferredInDialectAssemblagesIds =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @preferredInDialectAssemblagesIds = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @preferredInDialectAssemblagesIds.push String.from_json(_item)
                 else
                   @preferredInDialectAssemblagesIds.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @preferredInDialectAssemblagesIds = _oa
            end
          end
        if !_o['acceptableInDialectAssemblagesIds'].nil?
          _oa = _o['acceptableInDialectAssemblagesIds']
            if(_oa.is_a? Hash)
              @acceptableInDialectAssemblagesIds = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @acceptableInDialectAssemblagesIds =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @acceptableInDialectAssemblagesIds = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @acceptableInDialectAssemblagesIds.push String.from_json(_item)
                 else
                   @acceptableInDialectAssemblagesIds.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @acceptableInDialectAssemblagesIds = _oa
            end
          end
        if !_o['referencedComponentId'].nil?
          _oa = _o['referencedComponentId']
            if(_oa.is_a? Hash)
              @referencedComponentId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @referencedComponentId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @referencedComponentId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @referencedComponentId.push String.from_json(_item)
                 else
                   @referencedComponentId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @referencedComponentId = _oa
            end
          end
    end

    # constructs a RestSememeDescriptionCreate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingSetVersionClone < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetVersionBase 

    # The concept id (sequence, NID or UUID) of the target mapping set to clone
    attr_accessor :cloneTargetConcept

    # the json hash for this RestMappingSetVersionClone
    def to_jaxb_json_hash
      _h = super
      _h['cloneTargetConcept'] = cloneTargetConcept.to_jaxb_json_hash unless cloneTargetConcept.nil?
      return _h
    end

    #initializes this RestMappingSetVersionClone with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['cloneTargetConcept'].nil?
          _oa = _o['cloneTargetConcept']
            if(_oa.is_a? Hash)
              @cloneTargetConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @cloneTargetConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @cloneTargetConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @cloneTargetConcept.push String.from_json(_item)
                 else
                   @cloneTargetConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @cloneTargetConcept = _oa
            end
          end
    end

    # constructs a RestMappingSetVersionClone from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Logic

  # (no documentation provided)
  class RestLiteralNodeInstant < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode 

    # RestLiteralNodeInstant contains a literal Instant value, literalValue
    attr_accessor :literalValue

    # the json hash for this RestLiteralNodeInstant
    def to_jaxb_json_hash
      _h = super
      _h['literalValue'] = literalValue.to_jaxb_json_hash unless literalValue.nil?
      return _h
    end

    #initializes this RestLiteralNodeInstant with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['literalValue'].nil?
          _oa = _o['literalValue']
            if(_oa.is_a? Hash)
              @literalValue = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @literalValue =  java.time::Instant.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @literalValue = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @literalValue.push java.time::Instant.from_json(_item)
                 else
                   @literalValue.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @literalValue = _oa
            end
          end
    end

    # constructs a RestLiteralNodeInstant from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Association

  # (no documentation provided)
  class RestAssociationTypeVersion < Gov::Vha::Isaac::Rest::Api1::Data::Association::RestAssociationTypeVersionCreate 

    # The data that was not expanded as part of this call (but can be)
    attr_accessor :expandables
    # The identifiers of the concept that represents the association definition
    attr_accessor :identifiers
    # The StampedVersion details for this association type
    attr_accessor :associationItemStamp
    # The Concept Chronology of the concept represented by associationConceptSequence.  Typically blank, unless requested via the expand parameter
    # &#39;referencedConcept&#39;  If &#39;referencedConcept&#39; is passed, you can also pass &#39;versionsAll&#39; or &#39;versionsLatestOnly&#39;
    attr_accessor :associationConcept

    # the json hash for this RestAssociationTypeVersion
    def to_jaxb_json_hash
      _h = super
      _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
      _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
      _h['associationItemStamp'] = associationItemStamp.to_jaxb_json_hash unless associationItemStamp.nil?
      _h['associationConcept'] = associationConcept.to_jaxb_json_hash unless associationConcept.nil?
      return _h
    end

    #initializes this RestAssociationTypeVersion with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['expandables'].nil?
          _oa = _o['expandables']
            if(_oa.is_a? Hash)
              @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @expandables = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                 else
                   @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @expandables = _oa
            end
          end
        if !_o['identifiers'].nil?
          _oa = _o['identifiers']
            if(_oa.is_a? Hash)
              @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @identifiers = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @identifiers = _oa
            end
          end
        if !_o['associationItemStamp'].nil?
          _oa = _o['associationItemStamp']
            if(_oa.is_a? Hash)
              @associationItemStamp = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @associationItemStamp =  Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @associationItemStamp = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @associationItemStamp.push Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_item)
                 else
                   @associationItemStamp.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @associationItemStamp = _oa
            end
          end
        if !_o['associationConcept'].nil?
          _oa = _o['associationConcept']
            if(_oa.is_a? Hash)
              @associationConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @associationConcept =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @associationConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @associationConcept.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_item)
                 else
                   @associationConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @associationConcept = _oa
            end
          end
    end

    # constructs a RestAssociationTypeVersion from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Concept

  # (no documentation provided)
  class RestTerminologyConcept < Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology 

    # The (optional) longer name of a terminology (if available)
    attr_accessor :definition

    # the json hash for this RestTerminologyConcept
    def to_jaxb_json_hash
      _h = super
      _h['definition'] = definition.to_jaxb_json_hash unless definition.nil?
      return _h
    end

    #initializes this RestTerminologyConcept with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['definition'].nil?
          _oa = _o['definition']
            if(_oa.is_a? Hash)
              @definition = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @definition =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @definition = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @definition.push String.from_json(_item)
                 else
                   @definition.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @definition = _oa
            end
          end
    end

    # constructs a RestTerminologyConcept from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestConcreteDomainOperatorsType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestConcreteDomainOperatorsType
    def to_jaxb_json_hash
      _h = super
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestConcreteDomainOperatorsType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestConcreteDomainOperatorsType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestConcreteDomainOperatorsType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestConcreteDomainOperatorsType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Concept

  # (no documentation provided)
  class RestWriteResponseConceptCreate < Gov::Vha::Isaac::Rest::Api::Data::Wrappers::RestWriteResponse 

    # The identifiers for the created FSN
    attr_accessor :fsnDescriptionSememe
    # The identifiers for the created preferred description (may be null)
    attr_accessor :preferredDescriptionSememe
    # The identifiers for the created extended description type (may be null)
    attr_accessor :extendedDescriptionTypeSememe
    # The identifiers for the created logic graph
    attr_accessor :logicGraph
    # The identifiers for the nested dialects that were created
    attr_accessor :dialectSememes

    # the json hash for this RestWriteResponseConceptCreate
    def to_jaxb_json_hash
      _h = super
      _h['fsnDescriptionSememe'] = fsnDescriptionSememe.to_jaxb_json_hash unless fsnDescriptionSememe.nil?
      _h['preferredDescriptionSememe'] = preferredDescriptionSememe.to_jaxb_json_hash unless preferredDescriptionSememe.nil?
      _h['extendedDescriptionTypeSememe'] = extendedDescriptionTypeSememe.to_jaxb_json_hash unless extendedDescriptionTypeSememe.nil?
      _h['logicGraph'] = logicGraph.to_jaxb_json_hash unless logicGraph.nil?
      if !dialectSememes.nil?
        _ha = Array.new
        dialectSememes.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['dialectSememes'] = _ha
      end
      return _h
    end

    #initializes this RestWriteResponseConceptCreate with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['fsnDescriptionSememe'].nil?
          _oa = _o['fsnDescriptionSememe']
            if(_oa.is_a? Hash)
              @fsnDescriptionSememe = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @fsnDescriptionSememe =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @fsnDescriptionSememe = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @fsnDescriptionSememe.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @fsnDescriptionSememe.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @fsnDescriptionSememe = _oa
            end
          end
        if !_o['preferredDescriptionSememe'].nil?
          _oa = _o['preferredDescriptionSememe']
            if(_oa.is_a? Hash)
              @preferredDescriptionSememe = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @preferredDescriptionSememe =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @preferredDescriptionSememe = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @preferredDescriptionSememe.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @preferredDescriptionSememe.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @preferredDescriptionSememe = _oa
            end
          end
        if !_o['extendedDescriptionTypeSememe'].nil?
          _oa = _o['extendedDescriptionTypeSememe']
            if(_oa.is_a? Hash)
              @extendedDescriptionTypeSememe = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @extendedDescriptionTypeSememe =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @extendedDescriptionTypeSememe = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @extendedDescriptionTypeSememe.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @extendedDescriptionTypeSememe.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @extendedDescriptionTypeSememe = _oa
            end
          end
        if !_o['logicGraph'].nil?
          _oa = _o['logicGraph']
            if(_oa.is_a? Hash)
              @logicGraph = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @logicGraph =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @logicGraph = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @logicGraph.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @logicGraph.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @logicGraph = _oa
            end
          end
        if !_o['dialectSememes'].nil?
          _oa = _o['dialectSememes']
            if(_oa.is_a? Hash)
              @dialectSememes = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @dialectSememes =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @dialectSememes = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @dialectSememes.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @dialectSememes.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @dialectSememes = _oa
            end
          end
    end

    # constructs a RestWriteResponseConceptCreate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingSetVersion < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetVersionBase 

    # The data that was not expanded as part of this call (but can be)
    attr_accessor :expandables
    # The identifier data of the concept that represents this mapping set
    attr_accessor :identifiers
    # The identifiers of the terminologies (concepts that represent terminologies) that this mapset concept is part of.  This is determined by whether or not there is
    # version of this concept present with a module that extends from one of the children of the MetaData#MODULE concepts.
    # 
    # Note that this is calculated WITH taking into account the view coordinate, including the active / inactive state of the concept in any particular terminology.
    # This means that if a concept is present in both Snomed CT and the US Extension modules, but your view coordinate excludes the US Extension, this will not
    # include the US Extension module.
    # 
    # See 1/system/terminologyTypes for more details on the potential terminology concepts that will be returned.
    attr_accessor :terminologyTypes
    # The StampedVersion details for this map set definition
    attr_accessor :mappingSetStamp
    # The (optional) extended fields which carry additional information about this map set definition.
    attr_accessor :mapSetExtendedFields
    # The fields that are declared for each map item instance that is created using this map set definition.
    attr_accessor :mapItemFieldsDefinition
    # Specifies display fields that should populate each item and respective order
    attr_accessor :displayFields
    # The (optionally) populated comments attached to this map set.  This field is only populated when requested via an &#39;expand&#39; parameter.
    attr_accessor :comments

    # the json hash for this RestMappingSetVersion
    def to_jaxb_json_hash
      _h = super
      _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
      _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
      if !terminologyTypes.nil?
        _ha = Array.new
        terminologyTypes.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['terminologyTypes'] = _ha
      end
      _h['mappingSetStamp'] = mappingSetStamp.to_jaxb_json_hash unless mappingSetStamp.nil?
      if !mapSetExtendedFields.nil?
        _ha = Array.new
        mapSetExtendedFields.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['mapSetExtendedFields'] = _ha
      end
      if !mapItemFieldsDefinition.nil?
        _ha = Array.new
        mapItemFieldsDefinition.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['mapItemFieldsDefinition'] = _ha
      end
      if !displayFields.nil?
        _ha = Array.new
        displayFields.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['displayFields'] = _ha
      end
      if !comments.nil?
        _ha = Array.new
        comments.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['comments'] = _ha
      end
      return _h
    end

    #initializes this RestMappingSetVersion with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['expandables'].nil?
          _oa = _o['expandables']
            if(_oa.is_a? Hash)
              @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @expandables = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                 else
                   @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @expandables = _oa
            end
          end
        if !_o['identifiers'].nil?
          _oa = _o['identifiers']
            if(_oa.is_a? Hash)
              @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @identifiers = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @identifiers = _oa
            end
          end
        if !_o['terminologyTypes'].nil?
          _oa = _o['terminologyTypes']
            if(_oa.is_a? Hash)
              @terminologyTypes = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @terminologyTypes =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @terminologyTypes = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @terminologyTypes.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @terminologyTypes.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @terminologyTypes = _oa
            end
          end
        if !_o['mappingSetStamp'].nil?
          _oa = _o['mappingSetStamp']
            if(_oa.is_a? Hash)
              @mappingSetStamp = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @mappingSetStamp =  Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @mappingSetStamp = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @mappingSetStamp.push Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_item)
                 else
                   @mappingSetStamp.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @mappingSetStamp = _oa
            end
          end
        if !_o['mapSetExtendedFields'].nil?
          _oa = _o['mapSetExtendedFields']
            if(_oa.is_a? Hash)
              @mapSetExtendedFields = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @mapSetExtendedFields =  Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValue.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @mapSetExtendedFields = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @mapSetExtendedFields.push Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValue.from_json(_item)
                 else
                   @mapSetExtendedFields.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @mapSetExtendedFields = _oa
            end
          end
        if !_o['mapItemFieldsDefinition'].nil?
          _oa = _o['mapItemFieldsDefinition']
            if(_oa.is_a? Hash)
              @mapItemFieldsDefinition = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @mapItemFieldsDefinition =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfo.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @mapItemFieldsDefinition = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @mapItemFieldsDefinition.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfo.from_json(_item)
                 else
                   @mapItemFieldsDefinition.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @mapItemFieldsDefinition = _oa
            end
          end
        if !_o['displayFields'].nil?
          _oa = _o['displayFields']
            if(_oa.is_a? Hash)
              @displayFields = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @displayFields =  Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetDisplayField.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @displayFields = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @displayFields.push Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetDisplayField.from_json(_item)
                 else
                   @displayFields.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @displayFields = _oa
            end
          end
        if !_o['comments'].nil?
          _oa = _o['comments']
            if(_oa.is_a? Hash)
              @comments = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @comments =  Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @comments = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @comments.push Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersion.from_json(_item)
                 else
                   @comments.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @comments = _oa
            end
          end
    end

    # constructs a RestMappingSetVersion from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

module DataTypes

  # (no documentation provided)
  class RestDynamicSememeFloat < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData 


    # the json hash for this RestDynamicSememeFloat
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestDynamicSememeFloat with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestDynamicSememeFloat from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Logic

  # (no documentation provided)
  class RestLiteralNodeString < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode 

    # RestLiteralNodeString contains a literal String value, literalValue
    attr_accessor :literalValue

    # the json hash for this RestLiteralNodeString
    def to_jaxb_json_hash
      _h = super
      _h['literalValue'] = literalValue.to_jaxb_json_hash unless literalValue.nil?
      return _h
    end

    #initializes this RestLiteralNodeString with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['literalValue'].nil?
          _oa = _o['literalValue']
            if(_oa.is_a? Hash)
              @literalValue = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @literalValue =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @literalValue = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @literalValue.push String.from_json(_item)
                 else
                   @literalValue.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @literalValue = _oa
            end
          end
    end

    # constructs a RestLiteralNodeString from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestExternalizableObjectType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestExternalizableObjectType
    def to_jaxb_json_hash
      _h = super
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestExternalizableObjectType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestExternalizableObjectType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestExternalizableObjectType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestExternalizableObjectType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingItemVersion < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingItemVersionBase 

    # The data that was not expanded as part of this call (but can be)
    attr_accessor :expandables
    # The concept that identifies the map set that this entry belongs to.
    attr_accessor :mapSetConcept
    # The source concept mapped by this map item.
    attr_accessor :sourceConcept
    # The (optional) target concept being mapped by this map item.  This field is optional, and may be blank, if no target mapping
    # is available.
    attr_accessor :targetConcept
    # An (optional) concept used to qualify this mapping entry.
    attr_accessor :qualifierConcept
    # The identifier data for the sememe that represents this mapping item
    attr_accessor :identifiers
    # The StampedVersion details for this mapping entry
    attr_accessor :mappingItemStamp
    # The (optionally) populated comments attached to this map set.  This field is only populated when requested via an &#39;expand&#39; parameter.
    attr_accessor :comments
    # If any computed columns were specified to be included in the definition of this mapset,
    # they are returned here.
    attr_accessor :computedDisplayFields

    # the json hash for this RestMappingItemVersion
    def to_jaxb_json_hash
      _h = super
      _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
      _h['mapSetConcept'] = mapSetConcept.to_jaxb_json_hash unless mapSetConcept.nil?
      _h['sourceConcept'] = sourceConcept.to_jaxb_json_hash unless sourceConcept.nil?
      _h['targetConcept'] = targetConcept.to_jaxb_json_hash unless targetConcept.nil?
      _h['qualifierConcept'] = qualifierConcept.to_jaxb_json_hash unless qualifierConcept.nil?
      _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
      _h['mappingItemStamp'] = mappingItemStamp.to_jaxb_json_hash unless mappingItemStamp.nil?
      if !comments.nil?
        _ha = Array.new
        comments.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['comments'] = _ha
      end
      if !computedDisplayFields.nil?
        _ha = Array.new
        computedDisplayFields.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['computedDisplayFields'] = _ha
      end
      return _h
    end

    #initializes this RestMappingItemVersion with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['expandables'].nil?
          _oa = _o['expandables']
            if(_oa.is_a? Hash)
              @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @expandables = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                 else
                   @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @expandables = _oa
            end
          end
        if !_o['mapSetConcept'].nil?
          _oa = _o['mapSetConcept']
            if(_oa.is_a? Hash)
              @mapSetConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @mapSetConcept =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @mapSetConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @mapSetConcept.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @mapSetConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @mapSetConcept = _oa
            end
          end
        if !_o['sourceConcept'].nil?
          _oa = _o['sourceConcept']
            if(_oa.is_a? Hash)
              @sourceConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @sourceConcept =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @sourceConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @sourceConcept.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @sourceConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @sourceConcept = _oa
            end
          end
        if !_o['targetConcept'].nil?
          _oa = _o['targetConcept']
            if(_oa.is_a? Hash)
              @targetConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @targetConcept =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @targetConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @targetConcept.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @targetConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @targetConcept = _oa
            end
          end
        if !_o['qualifierConcept'].nil?
          _oa = _o['qualifierConcept']
            if(_oa.is_a? Hash)
              @qualifierConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @qualifierConcept =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @qualifierConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @qualifierConcept.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @qualifierConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @qualifierConcept = _oa
            end
          end
        if !_o['identifiers'].nil?
          _oa = _o['identifiers']
            if(_oa.is_a? Hash)
              @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @identifiers = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                 else
                   @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @identifiers = _oa
            end
          end
        if !_o['mappingItemStamp'].nil?
          _oa = _o['mappingItemStamp']
            if(_oa.is_a? Hash)
              @mappingItemStamp = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @mappingItemStamp =  Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @mappingItemStamp = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @mappingItemStamp.push Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_item)
                 else
                   @mappingItemStamp.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @mappingItemStamp = _oa
            end
          end
        if !_o['comments'].nil?
          _oa = _o['comments']
            if(_oa.is_a? Hash)
              @comments = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @comments =  Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersion.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @comments = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @comments.push Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersion.from_json(_item)
                 else
                   @comments.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @comments = _oa
            end
          end
        if !_o['computedDisplayFields'].nil?
          _oa = _o['computedDisplayFields']
            if(_oa.is_a? Hash)
              @computedDisplayFields = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @computedDisplayFields =  Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingItemComputedDisplayField.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @computedDisplayFields = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @computedDisplayFields.push Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingItemComputedDisplayField.from_json(_item)
                 else
                   @computedDisplayFields.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @computedDisplayFields = _oa
            end
          end
    end

    # constructs a RestMappingItemVersion from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

  # (no documentation provided)
  class RestDynamicSememeVersion < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion 

    # The data attached to this sememe instance (if any).  The &#39;sememe/sememeDefinition/{id}&#39;
    # can be read to determine the potential types and descriptions of these columns.
    attr_accessor :dataColumns

    # the json hash for this RestDynamicSememeVersion
    def to_jaxb_json_hash
      _h = super
      if !dataColumns.nil?
        _ha = Array.new
        dataColumns.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['dataColumns'] = _ha
      end
      return _h
    end

    #initializes this RestDynamicSememeVersion with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['dataColumns'].nil?
          _oa = _o['dataColumns']
            if(_oa.is_a? Hash)
              @dataColumns = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @dataColumns =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @dataColumns = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @dataColumns.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                 else
                   @dataColumns.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @dataColumns = _oa
            end
          end
    end

    # constructs a RestDynamicSememeVersion from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestDynamicSememeDataType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # The full value of the &quot;@class&quot; annotation that needs to be passed back in when constructing a RestDynamicSememeData like
    # RestDynamicSememeDouble.
    attr_accessor :classType
    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestDynamicSememeDataType
    def to_jaxb_json_hash
      _h = super
      _h['classType'] = classType.to_jaxb_json_hash unless classType.nil?
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestDynamicSememeDataType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['classType'].nil?
          _oa = _o['classType']
            if(_oa.is_a? Hash)
              @classType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @classType =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @classType = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @classType.push String.from_json(_item)
                 else
                   @classType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @classType = _oa
            end
          end
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeDataType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeDataType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestDynamicSememeDataType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestDynamicSememeValidatorType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestDynamicSememeValidatorType
    def to_jaxb_json_hash
      _h = super
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestDynamicSememeValidatorType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeValidatorType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeValidatorType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestDynamicSememeValidatorType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Enumerations

  # (no documentation provided)
  class RestUserRoleType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration 

    # (no documentation provided)
    attr_accessor :all

    # the json hash for this RestUserRoleType
    def to_jaxb_json_hash
      _h = super
      if !all.nil?
        _ha = Array.new
        all.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['all'] = _ha
      end
      return _h
    end

    #initializes this RestUserRoleType with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['all'].nil?
          _oa = _o['all']
            if(_oa.is_a? Hash)
              @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestUserRoleType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @all = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestUserRoleType.from_json(_item)
                 else
                   @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @all = _oa
            end
          end
    end

    # constructs a RestUserRoleType from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

module DataTypes

  # (no documentation provided)
  class RestDynamicSememeUUID < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeIdentifiedData 


    # the json hash for this RestDynamicSememeUUID
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestDynamicSememeUUID with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestDynamicSememeUUID from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingSetExtensionValueCreate < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValueUpdate 


    # the json hash for this RestMappingSetExtensionValueCreate
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestMappingSetExtensionValueCreate with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestMappingSetExtensionValueCreate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

module DataTypes

  # (no documentation provided)
  class RestDynamicSememeSequence < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeIdentifiedData 


    # the json hash for this RestDynamicSememeSequence
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestDynamicSememeSequence with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestDynamicSememeSequence from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Logic

  # (no documentation provided)
  class RestFeatureNode < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestTypedConnectorNode 

    # RestFeatureNode contains a RestConcreteDomainOperatorsType/ConcreteDomainOperators instance,
    # which is an enumeration specifying a type of comparison
    # 
    # RestFeatureNode must have exactly 1 child node.
    # 
    # Available RestConcreteDomainOperatorsType/ConcreteDomainOperator values include
    # EQUALS,
    # LESS_THAN,
    # LESS_THAN_EQUALS,
    # GREATER_THAN,
    # GREATER_THAN_EQUALS
    attr_accessor :operator

    # the json hash for this RestFeatureNode
    def to_jaxb_json_hash
      _h = super
      _h['operator'] = operator.to_jaxb_json_hash unless operator.nil?
      return _h
    end

    #initializes this RestFeatureNode with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['operator'].nil?
          _oa = _o['operator']
            if(_oa.is_a? Hash)
              @operator = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @operator =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestConcreteDomainOperatorsType.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @operator = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @operator.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestConcreteDomainOperatorsType.from_json(_item)
                 else
                   @operator.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @operator = _oa
            end
          end
    end

    # constructs a RestFeatureNode from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Logic

  # (no documentation provided)
  class RestRoleNode < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestTypedConnectorNode 


    # the json hash for this RestRoleNode
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestRoleNode with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestRoleNode from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Sememe

module DataTypes

  # (no documentation provided)
  class RestDynamicSememeNid < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeIdentifiedData 


    # the json hash for this RestDynamicSememeNid
    def to_jaxb_json_hash
      _h = super
      return _h
    end

    #initializes this RestDynamicSememeNid with a json hash
    def init_jaxb_json_hash(_o)
      super _o
    end

    # constructs a RestDynamicSememeNid from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end

end

module Gov

module Vha

module Isaac

module Rest

module Api1

module Data

module Mapping

  # (no documentation provided)
  class RestMappingItemVersionCreate < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingItemVersionUpdate 

    # The concept that identifies the map set that this entry belongs to.  Accepts a nid, sequence or UUID.
    attr_accessor :mapSetConcept
    # The source concept being mapped by this map item.  Accepts a nid, sequence or UUID.
    attr_accessor :sourceConcept

    # the json hash for this RestMappingItemVersionCreate
    def to_jaxb_json_hash
      _h = super
      _h['mapSetConcept'] = mapSetConcept.to_jaxb_json_hash unless mapSetConcept.nil?
      _h['sourceConcept'] = sourceConcept.to_jaxb_json_hash unless sourceConcept.nil?
      return _h
    end

    #initializes this RestMappingItemVersionCreate with a json hash
    def init_jaxb_json_hash(_o)
      super _o
        if !_o['mapSetConcept'].nil?
          _oa = _o['mapSetConcept']
            if(_oa.is_a? Hash)
              @mapSetConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @mapSetConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @mapSetConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @mapSetConcept.push String.from_json(_item)
                 else
                   @mapSetConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @mapSetConcept = _oa
            end
          end
        if !_o['sourceConcept'].nil?
          _oa = _o['sourceConcept']
            if(_oa.is_a? Hash)
              @sourceConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @sourceConcept =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @sourceConcept = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @sourceConcept.push String.from_json(_item)
                 else
                   @sourceConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @sourceConcept = _oa
            end
          end
    end

    # constructs a RestMappingItemVersionCreate from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

end

end
