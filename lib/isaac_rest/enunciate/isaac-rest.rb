#
#
#
# Generated by <a href="http://enunciate.webcohesion.com">Enunciate</a>.
#
require 'json'

# adding necessary json serialization methods to standard classes.
class Object
  def to_jaxb_json_hash
    return self
  end
  def self.from_json o
    return o
  end
end

class String
  def self.from_json o
    return o
  end
end

class Boolean
  def self.from_json o
    return o
  end
end

class Numeric
  def self.from_json o
    return o
  end
end

class Time
  #json time is represented as number of milliseconds since epoch
  def to_jaxb_json_hash
    return (to_i * 1000) + (usec / 1000)
  end
  def self.from_json o
    if o.nil?
      return nil
    else
      return Time.at(o / 1000, (o % 1000) * 1000)
    end
  end
end

class Array
  def to_jaxb_json_hash
    a = Array.new
    each { | _item | a.push _item.to_jaxb_json_hash }
    return a
  end
end

class Hash
  def to_jaxb_json_hash
    h = Hash.new
    each { | _key, _value | h[_key.to_jaxb_json_hash] = _value.to_jaxb_json_hash }
    return h
  end
end

module EnunciateHelpers
  LAMB_CLASS_AWARE = ->(_item) do
    java_clazz = _item['@class']
    clazz_array_parts = java_clazz.split('.')
    short_clazz = clazz_array_parts.pop
    clazz_package = clazz_array_parts.map do |e| e[0] = e.first.capitalize; e end.join("::")
    clazz = clazz_package + "::" + short_clazz
    Object.const_get(clazz).send(:from_json, _item)
  end
end


module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Workflow

              # (no documentation provided)
              class RestWorkflowComponentNidToStampsMapEntry

                # The key
                attr_accessor :key
                # The value
                attr_accessor :value

                # the json hash for this RestWorkflowComponentNidToStampsMapEntry
                def to_jaxb_json_hash
                  _h = {}
                  _h['key'] = key.to_jaxb_json_hash unless key.nil?
                  if !value.nil?
                    _ha = Array.new
                    value.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['value'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestWorkflowComponentNidToStampsMapEntry
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestWorkflowComponentNidToStampsMapEntry with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['key'].nil?
                    _oa = _o['key']
                    if(_oa.is_a? Hash)
                      @key = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @key =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @key = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @key.push Fixnum.from_json(_item)
                        else
                          @key.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @key = _oa
                    end
                  end
                  if !_o['value'].nil?
                    _oa = _o['value']
                    if(_oa.is_a? Hash)
                      @value = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @value =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @value = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @value.push Fixnum.from_json(_item)
                        else
                          @value.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @value = _oa
                    end
                  end
                end

                # constructs a RestWorkflowComponentNidToStampsMapEntry from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Comment

              # (no documentation provided)
              class RestCommentVersionBase

                # The comment
                attr_accessor :comment
                # An (optional) comment context to store with the comment.  Typically used for key words, etc.
                attr_accessor :commentContext

                # the json hash for this RestCommentVersionBase
                def to_jaxb_json_hash
                  _h = {}
                  _h['comment'] = comment.to_jaxb_json_hash unless comment.nil?
                  _h['commentContext'] = commentContext.to_jaxb_json_hash unless commentContext.nil?
                  return _h
                end

                # the json (string form) for this RestCommentVersionBase
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestCommentVersionBase with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['comment'].nil?
                    _oa = _o['comment']
                    if(_oa.is_a? Hash)
                      @comment = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @comment =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @comment = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @comment.push String.from_json(_item)
                        else
                          @comment.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @comment = _oa
                    end
                  end
                  if !_o['commentContext'].nil?
                    _oa = _o['commentContext']
                    if(_oa.is_a? Hash)
                      @commentContext = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @commentContext =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @commentContext = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @commentContext.push String.from_json(_item)
                        else
                          @commentContext.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @commentContext = _oa
                    end
                  end
                end

                # constructs a RestCommentVersionBase from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Workflow

              # (no documentation provided)
              class RestWorkflowProcessHistoriesMap

                # The contained results
                attr_accessor :entries

                # the json hash for this RestWorkflowProcessHistoriesMap
                def to_jaxb_json_hash
                  _h = {}
                  if !entries.nil?
                    _ha = Array.new
                    entries.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['entries'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestWorkflowProcessHistoriesMap
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestWorkflowProcessHistoriesMap with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['entries'].nil?
                    _oa = _o['entries']
                    if(_oa.is_a? Hash)
                      @entries = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @entries =  Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowProcessHistoriesMapEntry.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @entries = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @entries.push Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowProcessHistoriesMapEntry.from_json(_item)
                        else
                          @entries.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @entries = _oa
                    end
                  end
                end

                # constructs a RestWorkflowProcessHistoriesMap from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Concept

              # (no documentation provided)
              class RestConceptVersion

                # The data that was not expanded as part of this call (but can be)
                attr_accessor :expandables
                # The concept chronology for this concept.  Depending on the expand parameter, may be empty.
                attr_accessor :conChronology
                # The StampedVersion details for this version of this concept.
                attr_accessor :conVersion
                # A boolean indicating whether the concept is fully-defined or primitive.  true for fully-defined, false for primitive
                # This value is not populated / returned if the concept does not contain a logic graph from which to derive the information.
                attr_accessor :isConceptDefined
                # The parent concepts(s) of the concept at this point in time (&#39;is a&#39; relationships).  Depending on the expand parameter, this may not be returned.
                attr_accessor :parents
                # The child concepts(s) of the concept at this point in time (&#39;is a&#39; relationships).  Depending on the expand parameter, this may not be returned.
                attr_accessor :children
                # The number of child concept(s) of the concept at this point in time (&#39;is a&#39; relationships).  Depending on the expand parameter, this may not be returned.
                # This will not be returned if the children field is populated.
                attr_accessor :childCount
                # The number of parent concept(s) of the concept at this point in time (&#39;is a&#39; relationships).  Depending on the expand parameter, this may not be returned.
                # This will not be returned if the parents field is populated.
                attr_accessor :parentCount
                # The concept sequences of the sememe assemblage concepts that this concept is a member of (there exists a sememe instance where the referencedComponent
                # is this concept, and the assemblage is the value returned).  Note that this field is typically not populated - and when it is populated, it is only
                # in response to a request via the Taxonomy or Concept APIs, when the parameter &#39;sememeMembership=true&#39; is passed.
                # See more details on TaxonomyAPIs#getConceptVersionTaxonomy(String, String, int, String, int, String, String, String)
                attr_accessor :sememeMembership

                # the json hash for this RestConceptVersion
                def to_jaxb_json_hash
                  _h = {}
                  _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
                  _h['conChronology'] = conChronology.to_jaxb_json_hash unless conChronology.nil?
                  _h['conVersion'] = conVersion.to_jaxb_json_hash unless conVersion.nil?
                  _h['isConceptDefined'] = isConceptDefined.to_jaxb_json_hash unless isConceptDefined.nil?
                  if !parents.nil?
                    _ha = Array.new
                    parents.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['parents'] = _ha
                  end
                  if !children.nil?
                    _ha = Array.new
                    children.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['children'] = _ha
                  end
                  _h['childCount'] = childCount.to_jaxb_json_hash unless childCount.nil?
                  _h['parentCount'] = parentCount.to_jaxb_json_hash unless parentCount.nil?
                  if !sememeMembership.nil?
                    _ha = Array.new
                    sememeMembership.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['sememeMembership'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestConceptVersion
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestConceptVersion with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['expandables'].nil?
                    _oa = _o['expandables']
                    if(_oa.is_a? Hash)
                      @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @expandables = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                        else
                          @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @expandables = _oa
                    end
                  end
                  if !_o['conChronology'].nil?
                    _oa = _o['conChronology']
                    if(_oa.is_a? Hash)
                      @conChronology = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @conChronology =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @conChronology = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @conChronology.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_item)
                        else
                          @conChronology.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @conChronology = _oa
                    end
                  end
                  if !_o['conVersion'].nil?
                    _oa = _o['conVersion']
                    if(_oa.is_a? Hash)
                      @conVersion = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @conVersion =  Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @conVersion = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @conVersion.push Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_item)
                        else
                          @conVersion.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @conVersion = _oa
                    end
                  end
                  if !_o['isConceptDefined'].nil?
                    _oa = _o['isConceptDefined']
                    if(_oa.is_a? Hash)
                      @isConceptDefined = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @isConceptDefined =  Boolean.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @isConceptDefined = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @isConceptDefined.push Boolean.from_json(_item)
                        else
                          @isConceptDefined.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @isConceptDefined = _oa
                    end
                  end
                  if !_o['parents'].nil?
                    _oa = _o['parents']
                    if(_oa.is_a? Hash)
                      @parents = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @parents =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @parents = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @parents.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_item)
                        else
                          @parents.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @parents = _oa
                    end
                  end
                  if !_o['children'].nil?
                    _oa = _o['children']
                    if(_oa.is_a? Hash)
                      @children = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @children =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @children = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @children.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_item)
                        else
                          @children.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @children = _oa
                    end
                  end
                  if !_o['childCount'].nil?
                    _oa = _o['childCount']
                    if(_oa.is_a? Hash)
                      @childCount = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @childCount =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @childCount = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @childCount.push Fixnum.from_json(_item)
                        else
                          @childCount.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @childCount = _oa
                    end
                  end
                  if !_o['parentCount'].nil?
                    _oa = _o['parentCount']
                    if(_oa.is_a? Hash)
                      @parentCount = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @parentCount =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @parentCount = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @parentCount.push Fixnum.from_json(_item)
                        else
                          @parentCount.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @parentCount = _oa
                    end
                  end
                  if !_o['sememeMembership'].nil?
                    _oa = _o['sememeMembership']
                    if(_oa.is_a? Hash)
                      @sememeMembership = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @sememeMembership =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @sememeMembership = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @sememeMembership.push Fixnum.from_json(_item)
                        else
                          @sememeMembership.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @sememeMembership = _oa
                    end
                  end
                end

                # constructs a RestConceptVersion from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Workflow

              # (no documentation provided)
              class RestWorkflowProcessBaseCreate

                # The workflow definition id
                attr_accessor :definitionId
                # The creator.
                attr_accessor :creatorNid
                # The process name
                attr_accessor :name
                # The process description
                attr_accessor :description

                # the json hash for this RestWorkflowProcessBaseCreate
                def to_jaxb_json_hash
                  _h = {}
                  _h['definitionId'] = definitionId.to_jaxb_json_hash unless definitionId.nil?
                  _h['creatorNid'] = creatorNid.to_jaxb_json_hash unless creatorNid.nil?
                  _h['name'] = name.to_jaxb_json_hash unless name.nil?
                  _h['description'] = description.to_jaxb_json_hash unless description.nil?
                  return _h
                end

                # the json (string form) for this RestWorkflowProcessBaseCreate
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestWorkflowProcessBaseCreate with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['definitionId'].nil?
                    _oa = _o['definitionId']
                    if(_oa.is_a? Hash)
                      @definitionId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @definitionId =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @definitionId = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @definitionId.push String.from_json(_item)
                        else
                          @definitionId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @definitionId = _oa
                    end
                  end
                  if !_o['creatorNid'].nil?
                    _oa = _o['creatorNid']
                    if(_oa.is_a? Hash)
                      @creatorNid = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @creatorNid =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @creatorNid = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @creatorNid.push Fixnum.from_json(_item)
                        else
                          @creatorNid.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @creatorNid = _oa
                    end
                  end
                  if !_o['name'].nil?
                    _oa = _o['name']
                    if(_oa.is_a? Hash)
                      @name = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @name =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @name = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @name.push String.from_json(_item)
                        else
                          @name.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @name = _oa
                    end
                  end
                  if !_o['description'].nil?
                    _oa = _o['description']
                    if(_oa.is_a? Hash)
                      @description = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @description =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @description = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @description.push String.from_json(_item)
                        else
                          @description.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @description = _oa
                    end
                  end
                end

                # constructs a RestWorkflowProcessBaseCreate from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Workflow

              # (no documentation provided)
              class RestWorkflowProcessAdvancementData

                # The process id of the process to advance
                attr_accessor :processId
                # The user performing the advancement
                attr_accessor :userId
                # The advancement action requested
                attr_accessor :actionRequested
                # The comment associated with the advancement
                attr_accessor :comment

                # the json hash for this RestWorkflowProcessAdvancementData
                def to_jaxb_json_hash
                  _h = {}
                  _h['processId'] = processId.to_jaxb_json_hash unless processId.nil?
                  _h['userId'] = userId.to_jaxb_json_hash unless userId.nil?
                  _h['actionRequested'] = actionRequested.to_jaxb_json_hash unless actionRequested.nil?
                  _h['comment'] = comment.to_jaxb_json_hash unless comment.nil?
                  return _h
                end

                # the json (string form) for this RestWorkflowProcessAdvancementData
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestWorkflowProcessAdvancementData with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['processId'].nil?
                    _oa = _o['processId']
                    if(_oa.is_a? Hash)
                      @processId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @processId =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @processId = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @processId.push String.from_json(_item)
                        else
                          @processId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @processId = _oa
                    end
                  end
                  if !_o['userId'].nil?
                    _oa = _o['userId']
                    if(_oa.is_a? Hash)
                      @userId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @userId =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @userId = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @userId.push Fixnum.from_json(_item)
                        else
                          @userId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @userId = _oa
                    end
                  end
                  if !_o['actionRequested'].nil?
                    _oa = _o['actionRequested']
                    if(_oa.is_a? Hash)
                      @actionRequested = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @actionRequested =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @actionRequested = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @actionRequested.push String.from_json(_item)
                        else
                          @actionRequested.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @actionRequested = _oa
                    end
                  end
                  if !_o['comment'].nil?
                    _oa = _o['comment']
                    if(_oa.is_a? Hash)
                      @comment = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @comment =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @comment = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @comment.push String.from_json(_item)
                        else
                          @comment.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @comment = _oa
                    end
                  end
                end

                # constructs a RestWorkflowProcessAdvancementData from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Concept

              # (no documentation provided)
              class RestConceptChronology

                # The concept sequence identifier of this concept
                attr_accessor :conceptSequence
                # The &quot;best&quot; description for this concept.  This is selected based on the attributes within the session for
                # stamp and language coordinates - or - if none present - the server default.
                attr_accessor :description
                # The data that was not expanded as part of this call (but can be)
                attr_accessor :expandables
                # The identifier data for the object
                attr_accessor :identifiers
                # The list of concept versions.  Depending on the expand parameter, may be empty, the latest only, or all versions.
                attr_accessor :versions

                # the json hash for this RestConceptChronology
                def to_jaxb_json_hash
                  _h = {}
                  _h['conceptSequence'] = conceptSequence.to_jaxb_json_hash unless conceptSequence.nil?
                  _h['description'] = description.to_jaxb_json_hash unless description.nil?
                  _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
                  _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
                  if !versions.nil?
                    _ha = Array.new
                    versions.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['versions'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestConceptChronology
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestConceptChronology with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['conceptSequence'].nil?
                    _oa = _o['conceptSequence']
                    if(_oa.is_a? Hash)
                      @conceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @conceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @conceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @conceptSequence.push Fixnum.from_json(_item)
                        else
                          @conceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @conceptSequence = _oa
                    end
                  end
                  if !_o['description'].nil?
                    _oa = _o['description']
                    if(_oa.is_a? Hash)
                      @description = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @description =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @description = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @description.push String.from_json(_item)
                        else
                          @description.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @description = _oa
                    end
                  end
                  if !_o['expandables'].nil?
                    _oa = _o['expandables']
                    if(_oa.is_a? Hash)
                      @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @expandables = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                        else
                          @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @expandables = _oa
                    end
                  end
                  if !_o['identifiers'].nil?
                    _oa = _o['identifiers']
                    if(_oa.is_a? Hash)
                      @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @identifiers = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                        else
                          @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @identifiers = _oa
                    end
                  end
                  if !_o['versions'].nil?
                    _oa = _o['versions']
                    if(_oa.is_a? Hash)
                      @versions = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @versions =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @versions = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @versions.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_item)
                        else
                          @versions.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @versions = _oa
                    end
                  end
                end

                # constructs a RestConceptChronology from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Search

              # (no documentation provided)
              class RestSearchResult

                # The internal identifier of the sememe that matched the query
                attr_accessor :matchNid
                # The text of the description that matched the query (may be blank, if the description is not available/active on the path used to populate this)
                attr_accessor :matchText
                # The Lucene Score for this result.  This value is only useful for ranking search results relative to other search results within the SAME QUERY
                # execution.  It may not be used to rank one query against another.
                attr_accessor :score
                # Returns true if the sememe that matched the query is active (with the specified of default stamp,
                # false if inactive.
                attr_accessor :active
                # The data that was not expanded as part of this call (but can be)
                attr_accessor :expandables
                # The (optionally) populated identifiers (UUIDs) of the sememe that matched the query.  Must pass expand=&#39;uuid&#39; to have
                # this populated.
                attr_accessor :identifiers
                # The (optionally) populated concept that is referenced (indirectly) by the sememe that matched the query.  This is calculated by
                # looking up the sememe of the matchNid, and then getting the referenced component of that sememe.  If the referenced component
                # is a concept, that is the concept that is returned.  If the referenced component is a sememe, then the process is repeated (following
                # the referenced component reference of the sememe) - continuing until a concept is found.  If an (unusual) case occurs where the
                # sememe chain doesn&#39;t lead to a concept, this will not be populated.  This is populated by passing the expand parameter &#39;referencedConcept&#39;.
                # If this is passed, you may also (optionally) pass the parameters &#39;versionsLatestOnly&#39; or &#39;versionsAll&#39;
                attr_accessor :referencedConcept

                # the json hash for this RestSearchResult
                def to_jaxb_json_hash
                  _h = {}
                  _h['matchNid'] = matchNid.to_jaxb_json_hash unless matchNid.nil?
                  _h['matchText'] = matchText.to_jaxb_json_hash unless matchText.nil?
                  _h['score'] = score.to_jaxb_json_hash unless score.nil?
                  _h['active'] = active.to_jaxb_json_hash unless active.nil?
                  _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
                  _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
                  _h['referencedConcept'] = referencedConcept.to_jaxb_json_hash unless referencedConcept.nil?
                  return _h
                end

                # the json (string form) for this RestSearchResult
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestSearchResult with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['matchNid'].nil?
                    _oa = _o['matchNid']
                    if(_oa.is_a? Hash)
                      @matchNid = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @matchNid =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @matchNid = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @matchNid.push Fixnum.from_json(_item)
                        else
                          @matchNid.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @matchNid = _oa
                    end
                  end
                  if !_o['matchText'].nil?
                    _oa = _o['matchText']
                    if(_oa.is_a? Hash)
                      @matchText = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @matchText =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @matchText = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @matchText.push String.from_json(_item)
                        else
                          @matchText.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @matchText = _oa
                    end
                  end
                  if !_o['score'].nil?
                    _oa = _o['score']
                    if(_oa.is_a? Hash)
                      @score = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @score =  Float.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @score = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @score.push Float.from_json(_item)
                        else
                          @score.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @score = _oa
                    end
                  end
                  if !_o['active'].nil?
                    _oa = _o['active']
                    if(_oa.is_a? Hash)
                      @active = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @active =  Boolean.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @active = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @active.push Boolean.from_json(_item)
                        else
                          @active.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @active = _oa
                    end
                  end
                  if !_o['expandables'].nil?
                    _oa = _o['expandables']
                    if(_oa.is_a? Hash)
                      @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @expandables = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                        else
                          @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @expandables = _oa
                    end
                  end
                  if !_o['identifiers'].nil?
                    _oa = _o['identifiers']
                    if(_oa.is_a? Hash)
                      @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @identifiers = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                        else
                          @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @identifiers = _oa
                    end
                  end
                  if !_o['referencedConcept'].nil?
                    _oa = _o['referencedConcept']
                    if(_oa.is_a? Hash)
                      @referencedConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @referencedConcept =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @referencedConcept = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @referencedConcept.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_item)
                        else
                          @referencedConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @referencedConcept = _oa
                    end
                  end
                end

                # constructs a RestSearchResult from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Coordinate

              # (no documentation provided)
              class RestLogicCoordinate

                # Sequence number of the STATED assemblage.
                attr_accessor :statedAssemblage
                # Sequence number of the INFERRED assemblage.
                attr_accessor :inferredAssemblage
                # Sequence number of the description profile assemblage.
                attr_accessor :descriptionLogicProfile
                # Sequence number of the classifier assemblage.
                attr_accessor :classifier

                # the json hash for this RestLogicCoordinate
                def to_jaxb_json_hash
                  _h = {}
                  _h['statedAssemblage'] = statedAssemblage.to_jaxb_json_hash unless statedAssemblage.nil?
                  _h['inferredAssemblage'] = inferredAssemblage.to_jaxb_json_hash unless inferredAssemblage.nil?
                  _h['descriptionLogicProfile'] = descriptionLogicProfile.to_jaxb_json_hash unless descriptionLogicProfile.nil?
                  _h['classifier'] = classifier.to_jaxb_json_hash unless classifier.nil?
                  return _h
                end

                # the json (string form) for this RestLogicCoordinate
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestLogicCoordinate with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['statedAssemblage'].nil?
                    _oa = _o['statedAssemblage']
                    if(_oa.is_a? Hash)
                      @statedAssemblage = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @statedAssemblage =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @statedAssemblage = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @statedAssemblage.push Fixnum.from_json(_item)
                        else
                          @statedAssemblage.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @statedAssemblage = _oa
                    end
                  end
                  if !_o['inferredAssemblage'].nil?
                    _oa = _o['inferredAssemblage']
                    if(_oa.is_a? Hash)
                      @inferredAssemblage = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @inferredAssemblage =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @inferredAssemblage = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @inferredAssemblage.push Fixnum.from_json(_item)
                        else
                          @inferredAssemblage.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @inferredAssemblage = _oa
                    end
                  end
                  if !_o['descriptionLogicProfile'].nil?
                    _oa = _o['descriptionLogicProfile']
                    if(_oa.is_a? Hash)
                      @descriptionLogicProfile = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @descriptionLogicProfile =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @descriptionLogicProfile = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @descriptionLogicProfile.push Fixnum.from_json(_item)
                        else
                          @descriptionLogicProfile.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @descriptionLogicProfile = _oa
                    end
                  end
                  if !_o['classifier'].nil?
                    _oa = _o['classifier']
                    if(_oa.is_a? Hash)
                      @classifier = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @classifier =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @classifier = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @classifier.push Fixnum.from_json(_item)
                        else
                          @classifier.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @classifier = _oa
                    end
                  end
                end

                # constructs a RestLogicCoordinate from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Coordinate

              # (no documentation provided)
              class RestTaxonomyCoordinate

                # Boolean indicating whether or not RestTaxonomyCoordinate is of STATED PremiseType.
                # If TRUE then RestTaxonomyCoordinate is of PremiseType STATED.
                # If FALSE then RestTaxonomyCoordinate is of PremiseType INFERRED.
                attr_accessor :stated
                # RestStampCoordinate component of RestTaxonomyCoordinate
                attr_accessor :stampCoordinate
                # RestLanguageCoordinate component of RestTaxonomyCoordinate
                attr_accessor :languageCoordinate
                # RestLogicCoordinate component of RestTaxonomyCoordinate
                attr_accessor :logicCoordinate

                # the json hash for this RestTaxonomyCoordinate
                def to_jaxb_json_hash
                  _h = {}
                  _h['stated'] = stated.to_jaxb_json_hash unless stated.nil?
                  _h['stampCoordinate'] = stampCoordinate.to_jaxb_json_hash unless stampCoordinate.nil?
                  _h['languageCoordinate'] = languageCoordinate.to_jaxb_json_hash unless languageCoordinate.nil?
                  _h['logicCoordinate'] = logicCoordinate.to_jaxb_json_hash unless logicCoordinate.nil?
                  return _h
                end

                # the json (string form) for this RestTaxonomyCoordinate
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestTaxonomyCoordinate with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['stated'].nil?
                    _oa = _o['stated']
                    if(_oa.is_a? Hash)
                      @stated = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @stated =  Boolean.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @stated = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @stated.push Boolean.from_json(_item)
                        else
                          @stated.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @stated = _oa
                    end
                  end
                  if !_o['stampCoordinate'].nil?
                    _oa = _o['stampCoordinate']
                    if(_oa.is_a? Hash)
                      @stampCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @stampCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestStampCoordinate.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @stampCoordinate = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @stampCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestStampCoordinate.from_json(_item)
                        else
                          @stampCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @stampCoordinate = _oa
                    end
                  end
                  if !_o['languageCoordinate'].nil?
                    _oa = _o['languageCoordinate']
                    if(_oa.is_a? Hash)
                      @languageCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @languageCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLanguageCoordinate.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @languageCoordinate = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @languageCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLanguageCoordinate.from_json(_item)
                        else
                          @languageCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @languageCoordinate = _oa
                    end
                  end
                  if !_o['logicCoordinate'].nil?
                    _oa = _o['logicCoordinate']
                    if(_oa.is_a? Hash)
                      @logicCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @logicCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLogicCoordinate.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @logicCoordinate = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @logicCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLogicCoordinate.from_json(_item)
                        else
                          @logicCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @logicCoordinate = _oa
                    end
                  end
                end

                # constructs a RestTaxonomyCoordinate from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api

          module Data

            module Wrappers

              # (no documentation provided)
              class RestInteger

                # The int value
                attr_accessor :value

                # the json hash for this RestInteger
                def to_jaxb_json_hash
                  _h = {}
                  _h['value'] = value.to_jaxb_json_hash unless value.nil?
                  return _h
                end

                # the json (string form) for this RestInteger
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestInteger with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['value'].nil?
                    _oa = _o['value']
                    if(_oa.is_a? Hash)
                      @value = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @value =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @value = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @value.push Fixnum.from_json(_item)
                        else
                          @value.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @value = _oa
                    end
                  end
                end

                # constructs a RestInteger from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestDynamicSememeDefinition

                # The concept sequence of the concept that is used as an assemblage.  The rest of the descriptive details of the
                # sememe assemblage (returned in this object) are read from this concept.
                attr_accessor :assemblageConceptId
                # the user-friendly description of the overall purpose of this sememe
                attr_accessor :sememeUsageDescription
                # the column information that describes the data that may be returned as part of a sememe instance.
                attr_accessor :columnInfo
                # Return the RestObjectChronologyType of the restriction on referenced components for this sememe (if any - may return null)
                #
                # If there is a restriction, the nid set for the referenced component in an instance of this sememe must be of the type listed here.
                #
                # See rest/1/enumeration/restObjectChronologyType for a list of potential object types returned.
                attr_accessor :referencedComponentTypeRestriction
                # Return the RestSememeType of the sub restriction on referenced components for this DynamicSememe (if any - may return null)
                #
                # If there is a restriction, the nid set for the referenced component in an instance of this sememe must be of the type listed here.
                #
                # This is only applicable when #referencedComponentTypeRestriction returns RestObjectChronologyType#SEMEME
                #
                # See rest/1/enumeration/restSememeType for a list of potential object types returned.
                attr_accessor :referencedComponentTypeSubRestriction

                # the json hash for this RestDynamicSememeDefinition
                def to_jaxb_json_hash
                  _h = {}
                  _h['assemblageConceptId'] = assemblageConceptId.to_jaxb_json_hash unless assemblageConceptId.nil?
                  _h['sememeUsageDescription'] = sememeUsageDescription.to_jaxb_json_hash unless sememeUsageDescription.nil?
                  if !columnInfo.nil?
                    _ha = Array.new
                    columnInfo.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['columnInfo'] = _ha
                  end
                  _h['referencedComponentTypeRestriction'] = referencedComponentTypeRestriction.to_jaxb_json_hash unless referencedComponentTypeRestriction.nil?
                  _h['referencedComponentTypeSubRestriction'] = referencedComponentTypeSubRestriction.to_jaxb_json_hash unless referencedComponentTypeSubRestriction.nil?
                  return _h
                end

                # the json (string form) for this RestDynamicSememeDefinition
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestDynamicSememeDefinition with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['assemblageConceptId'].nil?
                    _oa = _o['assemblageConceptId']
                    if(_oa.is_a? Hash)
                      @assemblageConceptId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @assemblageConceptId =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @assemblageConceptId = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @assemblageConceptId.push Fixnum.from_json(_item)
                        else
                          @assemblageConceptId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @assemblageConceptId = _oa
                    end
                  end
                  if !_o['sememeUsageDescription'].nil?
                    _oa = _o['sememeUsageDescription']
                    if(_oa.is_a? Hash)
                      @sememeUsageDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @sememeUsageDescription =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @sememeUsageDescription = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @sememeUsageDescription.push String.from_json(_item)
                        else
                          @sememeUsageDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @sememeUsageDescription = _oa
                    end
                  end
                  if !_o['columnInfo'].nil?
                    _oa = _o['columnInfo']
                    if(_oa.is_a? Hash)
                      @columnInfo = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnInfo =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfo.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnInfo = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnInfo.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfo.from_json(_item)
                        else
                          @columnInfo.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnInfo = _oa
                    end
                  end
                  if !_o['referencedComponentTypeRestriction'].nil?
                    _oa = _o['referencedComponentTypeRestriction']
                    if(_oa.is_a? Hash)
                      @referencedComponentTypeRestriction = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @referencedComponentTypeRestriction =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @referencedComponentTypeRestriction = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @referencedComponentTypeRestriction.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_item)
                        else
                          @referencedComponentTypeRestriction.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @referencedComponentTypeRestriction = _oa
                    end
                  end
                  if !_o['referencedComponentTypeSubRestriction'].nil?
                    _oa = _o['referencedComponentTypeSubRestriction']
                    if(_oa.is_a? Hash)
                      @referencedComponentTypeSubRestriction = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @referencedComponentTypeSubRestriction =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSememeType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @referencedComponentTypeSubRestriction = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @referencedComponentTypeSubRestriction.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSememeType.from_json(_item)
                        else
                          @referencedComponentTypeSubRestriction.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @referencedComponentTypeSubRestriction = _oa
                    end
                  end
                end

                # constructs a RestDynamicSememeDefinition from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestSememeDescriptionUpdateData

                # The concept sequence of the concept that represents the case significance flag on the description .
                # This should be description case sensitive, description not case sensitive or description initial character sensitive
                attr_accessor :caseSignificanceConceptSequence
                # The concept sequence of the concept that represents the language of the description (note, this is NOT
                # the dialect)
                attr_accessor :languageConceptSequence
                # The text of the description
                attr_accessor :text
                # The concept sequence of the concept that represents the type of the description.
                # This should be FSN, Synonym, or Definition.
                attr_accessor :descriptionTypeConceptSequence
                # The boolean indicating whether specified sememe should be saved as ACTIVE
                attr_accessor :active

                # the json hash for this RestSememeDescriptionUpdateData
                def to_jaxb_json_hash
                  _h = {}
                  _h['caseSignificanceConceptSequence'] = caseSignificanceConceptSequence.to_jaxb_json_hash unless caseSignificanceConceptSequence.nil?
                  _h['languageConceptSequence'] = languageConceptSequence.to_jaxb_json_hash unless languageConceptSequence.nil?
                  _h['text'] = text.to_jaxb_json_hash unless text.nil?
                  _h['descriptionTypeConceptSequence'] = descriptionTypeConceptSequence.to_jaxb_json_hash unless descriptionTypeConceptSequence.nil?
                  _h['active'] = active.to_jaxb_json_hash unless active.nil?
                  return _h
                end

                # the json (string form) for this RestSememeDescriptionUpdateData
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestSememeDescriptionUpdateData with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['caseSignificanceConceptSequence'].nil?
                    _oa = _o['caseSignificanceConceptSequence']
                    if(_oa.is_a? Hash)
                      @caseSignificanceConceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @caseSignificanceConceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @caseSignificanceConceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @caseSignificanceConceptSequence.push Fixnum.from_json(_item)
                        else
                          @caseSignificanceConceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @caseSignificanceConceptSequence = _oa
                    end
                  end
                  if !_o['languageConceptSequence'].nil?
                    _oa = _o['languageConceptSequence']
                    if(_oa.is_a? Hash)
                      @languageConceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @languageConceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @languageConceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @languageConceptSequence.push Fixnum.from_json(_item)
                        else
                          @languageConceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @languageConceptSequence = _oa
                    end
                  end
                  if !_o['text'].nil?
                    _oa = _o['text']
                    if(_oa.is_a? Hash)
                      @text = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @text =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @text = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @text.push String.from_json(_item)
                        else
                          @text.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @text = _oa
                    end
                  end
                  if !_o['descriptionTypeConceptSequence'].nil?
                    _oa = _o['descriptionTypeConceptSequence']
                    if(_oa.is_a? Hash)
                      @descriptionTypeConceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @descriptionTypeConceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @descriptionTypeConceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @descriptionTypeConceptSequence.push Fixnum.from_json(_item)
                        else
                          @descriptionTypeConceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @descriptionTypeConceptSequence = _oa
                    end
                  end
                  if !_o['active'].nil?
                    _oa = _o['active']
                    if(_oa.is_a? Hash)
                      @active = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @active =  Boolean.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @active = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @active.push Boolean.from_json(_item)
                        else
                          @active.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @active = _oa
                    end
                  end
                end

                # constructs a RestSememeDescriptionUpdateData from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            # (no documentation provided)
            class RestCoordinatesToken

              # Serialized coordinates token
              attr_accessor :token

              # the json hash for this RestCoordinatesToken
              def to_jaxb_json_hash
                _h = {}
                _h['token'] = token.to_jaxb_json_hash unless token.nil?
                return _h
              end

              # the json (string form) for this RestCoordinatesToken
              def to_json
                to_jaxb_json_hash.to_json
              end

              #initializes this RestCoordinatesToken with a json hash
              def init_jaxb_json_hash(_o)
                if !_o['token'].nil?
                  _oa = _o['token']
                  if(_oa.is_a? Hash)
                    @token = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @token =  String.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @token = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @token.push String.from_json(_item)
                      else
                        @token.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @token = _oa
                  end
                end
              end

              # constructs a RestCoordinatesToken from a (parsed) JSON hash
              def self.from_json(o)
                if o.nil?
                  return nil
                else
                  inst = new
                  inst.init_jaxb_json_hash o
                  return inst
                end
              end
            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            # (no documentation provided)
            class RestSystemInfo

              # The full version number of this API.  Note, this is an array, because in the future
              # the API may simultaneously support versions such as [1.3, 2.0] for reverse compatibility.
              #
              # The agreement with Komet is that we do &quot;Major.Minor.Revision&quot;
              # The Major version only changes in concert with the rest API paths changing from /1/ to /2/ for example.
              # The Minor version is changed whenever we change a previously existing API or data structure - such that it
              # may break existing code in KOMET.  Note, you can add new APIs / properties to existing data structures without
              # breaking KOMET.
              # The Revision is changed whenever we make a change that modifies the API, but only in a way that won&#39;t impact
              # existing KOMET functionality - such as adding a new API, adding a new data structure, adding a field to an existing
              # data structure.
              attr_accessor :supportedAPIVersions
              # REST API Implementation Version - aka the version number of the software running here.
              attr_accessor :apiImplementationVersion
              # The version number of the database being used by this instance.
              attr_accessor :isaacDbDependency
              # Source Code Management URL that contains the source code for the software running here.
              attr_accessor :scmUrl
              # The version of ISAAC that the rest service is running on top of.
              attr_accessor :isaacVersion
              # Software Licenses
              attr_accessor :appLicenses
              # Database Licenses
              attr_accessor :dbLicenses
              # The source content that was built into the underlying database.
              attr_accessor :dbDependencies

              # the json hash for this RestSystemInfo
              def to_jaxb_json_hash
                _h = {}
                if !supportedAPIVersions.nil?
                  _ha = Array.new
                  supportedAPIVersions.each { | _item | _ha.push _item.to_jaxb_json_hash }
                  _h['supportedAPIVersions'] = _ha
                end
                _h['apiImplementationVersion'] = apiImplementationVersion.to_jaxb_json_hash unless apiImplementationVersion.nil?
                _h['isaacDbDependency'] = isaacDbDependency.to_jaxb_json_hash unless isaacDbDependency.nil?
                _h['scmUrl'] = scmUrl.to_jaxb_json_hash unless scmUrl.nil?
                _h['isaacVersion'] = isaacVersion.to_jaxb_json_hash unless isaacVersion.nil?
                if !appLicenses.nil?
                  _ha = Array.new
                  appLicenses.each { | _item | _ha.push _item.to_jaxb_json_hash }
                  _h['appLicenses'] = _ha
                end
                if !dbLicenses.nil?
                  _ha = Array.new
                  dbLicenses.each { | _item | _ha.push _item.to_jaxb_json_hash }
                  _h['dbLicenses'] = _ha
                end
                if !dbDependencies.nil?
                  _ha = Array.new
                  dbDependencies.each { | _item | _ha.push _item.to_jaxb_json_hash }
                  _h['dbDependencies'] = _ha
                end
                return _h
              end

              # the json (string form) for this RestSystemInfo
              def to_json
                to_jaxb_json_hash.to_json
              end

              #initializes this RestSystemInfo with a json hash
              def init_jaxb_json_hash(_o)
                if !_o['supportedAPIVersions'].nil?
                  _oa = _o['supportedAPIVersions']
                  if(_oa.is_a? Hash)
                    @supportedAPIVersions = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @supportedAPIVersions =  String.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @supportedAPIVersions = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @supportedAPIVersions.push String.from_json(_item)
                      else
                        @supportedAPIVersions.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @supportedAPIVersions = _oa
                  end
                end
                if !_o['apiImplementationVersion'].nil?
                  _oa = _o['apiImplementationVersion']
                  if(_oa.is_a? Hash)
                    @apiImplementationVersion = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @apiImplementationVersion =  String.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @apiImplementationVersion = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @apiImplementationVersion.push String.from_json(_item)
                      else
                        @apiImplementationVersion.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @apiImplementationVersion = _oa
                  end
                end
                if !_o['isaacDbDependency'].nil?
                  _oa = _o['isaacDbDependency']
                  if(_oa.is_a? Hash)
                    @isaacDbDependency = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @isaacDbDependency =  Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestDependencyInfo.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @isaacDbDependency = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @isaacDbDependency.push Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestDependencyInfo.from_json(_item)
                      else
                        @isaacDbDependency.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @isaacDbDependency = _oa
                  end
                end
                if !_o['scmUrl'].nil?
                  _oa = _o['scmUrl']
                  if(_oa.is_a? Hash)
                    @scmUrl = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @scmUrl =  String.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @scmUrl = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @scmUrl.push String.from_json(_item)
                      else
                        @scmUrl.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @scmUrl = _oa
                  end
                end
                if !_o['isaacVersion'].nil?
                  _oa = _o['isaacVersion']
                  if(_oa.is_a? Hash)
                    @isaacVersion = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @isaacVersion =  String.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @isaacVersion = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @isaacVersion.push String.from_json(_item)
                      else
                        @isaacVersion.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @isaacVersion = _oa
                  end
                end
                if !_o['appLicenses'].nil?
                  _oa = _o['appLicenses']
                  if(_oa.is_a? Hash)
                    @appLicenses = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @appLicenses =  Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestLicenseInfo.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @appLicenses = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @appLicenses.push Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestLicenseInfo.from_json(_item)
                      else
                        @appLicenses.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @appLicenses = _oa
                  end
                end
                if !_o['dbLicenses'].nil?
                  _oa = _o['dbLicenses']
                  if(_oa.is_a? Hash)
                    @dbLicenses = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @dbLicenses =  Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestLicenseInfo.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @dbLicenses = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @dbLicenses.push Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestLicenseInfo.from_json(_item)
                      else
                        @dbLicenses.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @dbLicenses = _oa
                  end
                end
                if !_o['dbDependencies'].nil?
                  _oa = _o['dbDependencies']
                  if(_oa.is_a? Hash)
                    @dbDependencies = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @dbDependencies =  Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestDependencyInfo.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @dbDependencies = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @dbDependencies.push Gov::Vha::Isaac::Rest::Api1::Data::Systeminfo::RestDependencyInfo.from_json(_item)
                      else
                        @dbDependencies.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @dbDependencies = _oa
                  end
                end
              end

              # constructs a RestSystemInfo from a (parsed) JSON hash
              def self.from_json(o)
                if o.nil?
                  return nil
                else
                  inst = new
                  inst.init_jaxb_json_hash o
                  return inst
                end
              end
            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Concept

              # (no documentation provided)
              class RestConceptCreateData

                # The sequences of the parent concepts of this concept. At least one is required.
                attr_accessor :parentConceptIds
                # The required Fully Specified Name description of this concept.
                attr_accessor :fsn
                # The required Preferred Term description of this concept.
                attr_accessor :preferredTerm
                # The language concept associated with the required descriptions
                attr_accessor :requiredDescriptionsLanguageConceptId
                # The preferred dialects associated with the required descriptions
                attr_accessor :requiredDescriptionsPreferredInDialectAssemblagesConceptIds
                # The acceptable dialects associated with the required descriptions
                attr_accessor :requiredDescriptionsAcceptableInDialectAssemblagesConceptIds
                # An optional extended description type applying to required descriptions
                attr_accessor :requiredDescriptionsExtendedTypeConceptId

                # the json hash for this RestConceptCreateData
                def to_jaxb_json_hash
                  _h = {}
                  if !parentConceptIds.nil?
                    _ha = Array.new
                    parentConceptIds.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['parentConceptIds'] = _ha
                  end
                  _h['fsn'] = fsn.to_jaxb_json_hash unless fsn.nil?
                  _h['preferredTerm'] = preferredTerm.to_jaxb_json_hash unless preferredTerm.nil?
                  _h['requiredDescriptionsLanguageConceptId'] = requiredDescriptionsLanguageConceptId.to_jaxb_json_hash unless requiredDescriptionsLanguageConceptId.nil?
                  if !requiredDescriptionsPreferredInDialectAssemblagesConceptIds.nil?
                    _ha = Array.new
                    requiredDescriptionsPreferredInDialectAssemblagesConceptIds.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['requiredDescriptionsPreferredInDialectAssemblagesConceptIds'] = _ha
                  end
                  if !requiredDescriptionsAcceptableInDialectAssemblagesConceptIds.nil?
                    _ha = Array.new
                    requiredDescriptionsAcceptableInDialectAssemblagesConceptIds.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['requiredDescriptionsAcceptableInDialectAssemblagesConceptIds'] = _ha
                  end
                  _h['requiredDescriptionsExtendedTypeConceptId'] = requiredDescriptionsExtendedTypeConceptId.to_jaxb_json_hash unless requiredDescriptionsExtendedTypeConceptId.nil?
                  return _h
                end

                # the json (string form) for this RestConceptCreateData
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestConceptCreateData with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['parentConceptIds'].nil?
                    _oa = _o['parentConceptIds']
                    if(_oa.is_a? Hash)
                      @parentConceptIds = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @parentConceptIds =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @parentConceptIds = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @parentConceptIds.push Fixnum.from_json(_item)
                        else
                          @parentConceptIds.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @parentConceptIds = _oa
                    end
                  end
                  if !_o['fsn'].nil?
                    _oa = _o['fsn']
                    if(_oa.is_a? Hash)
                      @fsn = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @fsn =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @fsn = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @fsn.push String.from_json(_item)
                        else
                          @fsn.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @fsn = _oa
                    end
                  end
                  if !_o['preferredTerm'].nil?
                    _oa = _o['preferredTerm']
                    if(_oa.is_a? Hash)
                      @preferredTerm = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @preferredTerm =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @preferredTerm = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @preferredTerm.push String.from_json(_item)
                        else
                          @preferredTerm.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @preferredTerm = _oa
                    end
                  end
                  if !_o['requiredDescriptionsLanguageConceptId'].nil?
                    _oa = _o['requiredDescriptionsLanguageConceptId']
                    if(_oa.is_a? Hash)
                      @requiredDescriptionsLanguageConceptId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @requiredDescriptionsLanguageConceptId =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @requiredDescriptionsLanguageConceptId = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @requiredDescriptionsLanguageConceptId.push Fixnum.from_json(_item)
                        else
                          @requiredDescriptionsLanguageConceptId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @requiredDescriptionsLanguageConceptId = _oa
                    end
                  end
                  if !_o['requiredDescriptionsPreferredInDialectAssemblagesConceptIds'].nil?
                    _oa = _o['requiredDescriptionsPreferredInDialectAssemblagesConceptIds']
                    if(_oa.is_a? Hash)
                      @requiredDescriptionsPreferredInDialectAssemblagesConceptIds = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @requiredDescriptionsPreferredInDialectAssemblagesConceptIds =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @requiredDescriptionsPreferredInDialectAssemblagesConceptIds = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @requiredDescriptionsPreferredInDialectAssemblagesConceptIds.push Fixnum.from_json(_item)
                        else
                          @requiredDescriptionsPreferredInDialectAssemblagesConceptIds.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @requiredDescriptionsPreferredInDialectAssemblagesConceptIds = _oa
                    end
                  end
                  if !_o['requiredDescriptionsAcceptableInDialectAssemblagesConceptIds'].nil?
                    _oa = _o['requiredDescriptionsAcceptableInDialectAssemblagesConceptIds']
                    if(_oa.is_a? Hash)
                      @requiredDescriptionsAcceptableInDialectAssemblagesConceptIds = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @requiredDescriptionsAcceptableInDialectAssemblagesConceptIds =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @requiredDescriptionsAcceptableInDialectAssemblagesConceptIds = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @requiredDescriptionsAcceptableInDialectAssemblagesConceptIds.push Fixnum.from_json(_item)
                        else
                          @requiredDescriptionsAcceptableInDialectAssemblagesConceptIds.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @requiredDescriptionsAcceptableInDialectAssemblagesConceptIds = _oa
                    end
                  end
                  if !_o['requiredDescriptionsExtendedTypeConceptId'].nil?
                    _oa = _o['requiredDescriptionsExtendedTypeConceptId']
                    if(_oa.is_a? Hash)
                      @requiredDescriptionsExtendedTypeConceptId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @requiredDescriptionsExtendedTypeConceptId =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @requiredDescriptionsExtendedTypeConceptId = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @requiredDescriptionsExtendedTypeConceptId.push Fixnum.from_json(_item)
                        else
                          @requiredDescriptionsExtendedTypeConceptId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @requiredDescriptionsExtendedTypeConceptId = _oa
                    end
                  end
                end

                # constructs a RestConceptCreateData from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestSememeChronology

                # The data that was not expanded as part of this call (but can be)
                attr_accessor :expandables
                # The sememe sequence identifier of this sememe instance
                attr_accessor :sememeSequence
                # The concept sequence identifier of the concept that represents the type of this sememe
                attr_accessor :assemblageSequence
                # The NID identifier of the object that is referenced by this sememe instance.  This could represent a concept or a sememe.
                attr_accessor :referencedComponentNid
                # The type of the object that is referenced by the referencedComponentNid value.  This would tell you if the nid represents a concept or a sememe.
                # Only populated when the expand parameter &#39;referencedDetails&#39; is passed.
                attr_accessor :referencedComponentNidObjectType
                # If the referencedComponentNid represents a concept, then this carries the &quot;best&quot; description for that concept.  This is selected based on the
                # attributes within the session for  stamp and language coordinates - or - if none present - the server default.  This is not populated if the
                # referencedComponentNid is a sememe type.
                # Only populated when the expand parameter &#39;referencedDetails&#39; is passed.
                attr_accessor :referencedComponentNidDescription
                # The permanent identifier object(s) attached to this sememe instance
                attr_accessor :identifiers
                # The list of sememe versions.  Depending on the expand parameter, may be empty, the latest only, or all versions.
                attr_accessor :versions

                # the json hash for this RestSememeChronology
                def to_jaxb_json_hash
                  _h = {}
                  _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
                  _h['sememeSequence'] = sememeSequence.to_jaxb_json_hash unless sememeSequence.nil?
                  _h['assemblageSequence'] = assemblageSequence.to_jaxb_json_hash unless assemblageSequence.nil?
                  _h['referencedComponentNid'] = referencedComponentNid.to_jaxb_json_hash unless referencedComponentNid.nil?
                  _h['referencedComponentNidObjectType'] = referencedComponentNidObjectType.to_jaxb_json_hash unless referencedComponentNidObjectType.nil?
                  _h['referencedComponentNidDescription'] = referencedComponentNidDescription.to_jaxb_json_hash unless referencedComponentNidDescription.nil?
                  _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
                  if !versions.nil?
                    _ha = Array.new
                    versions.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['versions'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestSememeChronology
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestSememeChronology with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['expandables'].nil?
                    _oa = _o['expandables']
                    if(_oa.is_a? Hash)
                      @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @expandables = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                        else
                          @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @expandables = _oa
                    end
                  end
                  if !_o['sememeSequence'].nil?
                    _oa = _o['sememeSequence']
                    if(_oa.is_a? Hash)
                      @sememeSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @sememeSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @sememeSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @sememeSequence.push Fixnum.from_json(_item)
                        else
                          @sememeSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @sememeSequence = _oa
                    end
                  end
                  if !_o['assemblageSequence'].nil?
                    _oa = _o['assemblageSequence']
                    if(_oa.is_a? Hash)
                      @assemblageSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @assemblageSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @assemblageSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @assemblageSequence.push Fixnum.from_json(_item)
                        else
                          @assemblageSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @assemblageSequence = _oa
                    end
                  end
                  if !_o['referencedComponentNid'].nil?
                    _oa = _o['referencedComponentNid']
                    if(_oa.is_a? Hash)
                      @referencedComponentNid = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @referencedComponentNid =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @referencedComponentNid = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @referencedComponentNid.push Fixnum.from_json(_item)
                        else
                          @referencedComponentNid.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @referencedComponentNid = _oa
                    end
                  end
                  if !_o['referencedComponentNidObjectType'].nil?
                    _oa = _o['referencedComponentNidObjectType']
                    if(_oa.is_a? Hash)
                      @referencedComponentNidObjectType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @referencedComponentNidObjectType =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @referencedComponentNidObjectType = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @referencedComponentNidObjectType.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_item)
                        else
                          @referencedComponentNidObjectType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @referencedComponentNidObjectType = _oa
                    end
                  end
                  if !_o['referencedComponentNidDescription'].nil?
                    _oa = _o['referencedComponentNidDescription']
                    if(_oa.is_a? Hash)
                      @referencedComponentNidDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @referencedComponentNidDescription =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @referencedComponentNidDescription = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @referencedComponentNidDescription.push String.from_json(_item)
                        else
                          @referencedComponentNidDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @referencedComponentNidDescription = _oa
                    end
                  end
                  if !_o['identifiers'].nil?
                    _oa = _o['identifiers']
                    if(_oa.is_a? Hash)
                      @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @identifiers = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                        else
                          @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @identifiers = _oa
                    end
                  end
                  if !_o['versions'].nil?
                    _oa = _o['versions']
                    if(_oa.is_a? Hash)
                      @versions = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @versions =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @versions = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @versions.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion.from_json(_item)
                        else
                          @versions.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @versions = _oa
                    end
                  end
                end

                # constructs a RestSememeChronology from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class Enumeration

                # The name of this enumeration type
                attr_accessor :name
                # The identifier of this enumeration.  This would be passed back to a call that requested an enum type.
                attr_accessor :enumId

                # the json hash for this Enumeration
                def to_jaxb_json_hash
                  _h = {}
                  _h['name'] = name.to_jaxb_json_hash unless name.nil?
                  _h['enumId'] = enumId.to_jaxb_json_hash unless enumId.nil?
                  return _h
                end

                # the json (string form) for this Enumeration
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this Enumeration with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['name'].nil?
                    _oa = _o['name']
                    if(_oa.is_a? Hash)
                      @name = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @name =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @name = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @name.push String.from_json(_item)
                        else
                          @name.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @name = _oa
                    end
                  end
                  if !_o['enumId'].nil?
                    _oa = _o['enumId']
                    if(_oa.is_a? Hash)
                      @enumId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @enumId =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @enumId = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @enumId.push Fixnum.from_json(_item)
                        else
                          @enumId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @enumId = _oa
                    end
                  end
                end

                # constructs a Enumeration from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestDynamicSememeColumnInfoCreate

                # The concept sequence number of the concept that represents the column within the dynamic sememe.  This returns a sequence,
                # but for creation purposes, can accept a sequence or a nid.
                attr_accessor :columnConceptLabelConcept
                # The type of data that will be found in this column.  String, Integer, etc.  See
                # rest/1/enumeration/restDynamicSememeDataType for a list of all of the possible data types.
                attr_accessor :columnDataType
                # The default value to use for this column when creating a new sememe (if no user value is specified).
                # This field is optional and may be null.
                attr_accessor :columnDefaultData
                # Does the user have to provide a value for this column in order to create an instance of this sememe.
                attr_accessor :columnRequired
                # The validators types that are attached to this sememe (if any).  Interval, &lt;, etc.  See
                # rest/1/enumeration/restDynamicSememeValidatorType for a list of all possible validator types.
                attr_accessor :columnValidatorTypes
                # The data required to execute the validator type specified in columnValidatorTypes.  The format and type of this field
                # will depend on the columnValidatorTypes field.  The positions within this array will match with the columnValidatorTypes
                # array.  This optional field should only be populated if the columnValidatorTypes is populated.
                attr_accessor :columnValidatorData

                # the json hash for this RestDynamicSememeColumnInfoCreate
                def to_jaxb_json_hash
                  _h = {}
                  _h['columnConceptLabelConcept'] = columnConceptLabelConcept.to_jaxb_json_hash unless columnConceptLabelConcept.nil?
                  _h['columnDataType'] = columnDataType.to_jaxb_json_hash unless columnDataType.nil?
                  _h['columnDefaultData'] = columnDefaultData.to_jaxb_json_hash unless columnDefaultData.nil?
                  _h['columnRequired'] = columnRequired.to_jaxb_json_hash unless columnRequired.nil?
                  if !columnValidatorTypes.nil?
                    _ha = Array.new
                    columnValidatorTypes.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['columnValidatorTypes'] = _ha
                  end
                  if !columnValidatorData.nil?
                    _ha = Array.new
                    columnValidatorData.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['columnValidatorData'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestDynamicSememeColumnInfoCreate
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestDynamicSememeColumnInfoCreate with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['columnConceptLabelConcept'].nil?
                    _oa = _o['columnConceptLabelConcept']
                    if(_oa.is_a? Hash)
                      @columnConceptLabelConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnConceptLabelConcept =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnConceptLabelConcept = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnConceptLabelConcept.push Fixnum.from_json(_item)
                        else
                          @columnConceptLabelConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnConceptLabelConcept = _oa
                    end
                  end
                  if !_o['columnDataType'].nil?
                    _oa = _o['columnDataType']
                    if(_oa.is_a? Hash)
                      @columnDataType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnDataType =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeDataType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnDataType = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnDataType.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeDataType.from_json(_item)
                        else
                          @columnDataType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnDataType = _oa
                    end
                  end
                  if !_o['columnDefaultData'].nil?
                    _oa = _o['columnDefaultData']
                    if(_oa.is_a? Hash)
                      @columnDefaultData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnDefaultData =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnDefaultData = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnDefaultData.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                        else
                          @columnDefaultData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnDefaultData = _oa
                    end
                  end
                  if !_o['columnRequired'].nil?
                    _oa = _o['columnRequired']
                    if(_oa.is_a? Hash)
                      @columnRequired = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnRequired =  Boolean.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnRequired = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnRequired.push Boolean.from_json(_item)
                        else
                          @columnRequired.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnRequired = _oa
                    end
                  end
                  if !_o['columnValidatorTypes'].nil?
                    _oa = _o['columnValidatorTypes']
                    if(_oa.is_a? Hash)
                      @columnValidatorTypes = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnValidatorTypes =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeValidatorType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnValidatorTypes = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnValidatorTypes.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeValidatorType.from_json(_item)
                        else
                          @columnValidatorTypes.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnValidatorTypes = _oa
                    end
                  end
                  if !_o['columnValidatorData'].nil?
                    _oa = _o['columnValidatorData']
                    if(_oa.is_a? Hash)
                      @columnValidatorData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnValidatorData =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnValidatorData = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnValidatorData.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                        else
                          @columnValidatorData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnValidatorData = _oa
                    end
                  end
                end

                # constructs a RestDynamicSememeColumnInfoCreate from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Coordinate

              # (no documentation provided)
              class RestCoordinates

                # taxonomyCoordinate
                attr_accessor :taxonomyCoordinate
                # stampCoordinate
                attr_accessor :stampCoordinate
                # languageCoordinate
                attr_accessor :languageCoordinate
                # logicCoordinate
                attr_accessor :logicCoordinate

                # the json hash for this RestCoordinates
                def to_jaxb_json_hash
                  _h = {}
                  _h['taxonomyCoordinate'] = taxonomyCoordinate.to_jaxb_json_hash unless taxonomyCoordinate.nil?
                  _h['stampCoordinate'] = stampCoordinate.to_jaxb_json_hash unless stampCoordinate.nil?
                  _h['languageCoordinate'] = languageCoordinate.to_jaxb_json_hash unless languageCoordinate.nil?
                  _h['logicCoordinate'] = logicCoordinate.to_jaxb_json_hash unless logicCoordinate.nil?
                  return _h
                end

                # the json (string form) for this RestCoordinates
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestCoordinates with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['taxonomyCoordinate'].nil?
                    _oa = _o['taxonomyCoordinate']
                    if(_oa.is_a? Hash)
                      @taxonomyCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @taxonomyCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestTaxonomyCoordinate.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @taxonomyCoordinate = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @taxonomyCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestTaxonomyCoordinate.from_json(_item)
                        else
                          @taxonomyCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @taxonomyCoordinate = _oa
                    end
                  end
                  if !_o['stampCoordinate'].nil?
                    _oa = _o['stampCoordinate']
                    if(_oa.is_a? Hash)
                      @stampCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @stampCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestStampCoordinate.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @stampCoordinate = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @stampCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestStampCoordinate.from_json(_item)
                        else
                          @stampCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @stampCoordinate = _oa
                    end
                  end
                  if !_o['languageCoordinate'].nil?
                    _oa = _o['languageCoordinate']
                    if(_oa.is_a? Hash)
                      @languageCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @languageCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLanguageCoordinate.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @languageCoordinate = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @languageCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLanguageCoordinate.from_json(_item)
                        else
                          @languageCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @languageCoordinate = _oa
                    end
                  end
                  if !_o['logicCoordinate'].nil?
                    _oa = _o['logicCoordinate']
                    if(_oa.is_a? Hash)
                      @logicCoordinate = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @logicCoordinate =  Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLogicCoordinate.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @logicCoordinate = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @logicCoordinate.push Gov::Vha::Isaac::Rest::Api1::Data::Coordinate::RestLogicCoordinate.from_json(_item)
                        else
                          @logicCoordinate.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @logicCoordinate = _oa
                    end
                  end
                end

                # constructs a RestCoordinates from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Workflow

              # (no documentation provided)
              class RestWorkflowAvailableAction

                # The identifier
                attr_accessor :id
                # The definition id
                attr_accessor :definitionId
                # The initial state
                attr_accessor :initialState
                # The action
                attr_accessor :action
                # The outcome state
                attr_accessor :outcomeState
                # The role
                attr_accessor :role

                # the json hash for this RestWorkflowAvailableAction
                def to_jaxb_json_hash
                  _h = {}
                  _h['id'] = id.to_jaxb_json_hash unless id.nil?
                  _h['definitionId'] = definitionId.to_jaxb_json_hash unless definitionId.nil?
                  _h['initialState'] = initialState.to_jaxb_json_hash unless initialState.nil?
                  _h['action'] = action.to_jaxb_json_hash unless action.nil?
                  _h['outcomeState'] = outcomeState.to_jaxb_json_hash unless outcomeState.nil?
                  _h['role'] = role.to_jaxb_json_hash unless role.nil?
                  return _h
                end

                # the json (string form) for this RestWorkflowAvailableAction
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestWorkflowAvailableAction with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['id'].nil?
                    _oa = _o['id']
                    if(_oa.is_a? Hash)
                      @id = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @id =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @id = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @id.push String.from_json(_item)
                        else
                          @id.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @id = _oa
                    end
                  end
                  if !_o['definitionId'].nil?
                    _oa = _o['definitionId']
                    if(_oa.is_a? Hash)
                      @definitionId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @definitionId =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @definitionId = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @definitionId.push String.from_json(_item)
                        else
                          @definitionId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @definitionId = _oa
                    end
                  end
                  if !_o['initialState'].nil?
                    _oa = _o['initialState']
                    if(_oa.is_a? Hash)
                      @initialState = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @initialState =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @initialState = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @initialState.push String.from_json(_item)
                        else
                          @initialState.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @initialState = _oa
                    end
                  end
                  if !_o['action'].nil?
                    _oa = _o['action']
                    if(_oa.is_a? Hash)
                      @action = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @action =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @action = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @action.push String.from_json(_item)
                        else
                          @action.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @action = _oa
                    end
                  end
                  if !_o['outcomeState'].nil?
                    _oa = _o['outcomeState']
                    if(_oa.is_a? Hash)
                      @outcomeState = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @outcomeState =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @outcomeState = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @outcomeState.push String.from_json(_item)
                        else
                          @outcomeState.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @outcomeState = _oa
                    end
                  end
                  if !_o['role'].nil?
                    _oa = _o['role']
                    if(_oa.is_a? Hash)
                      @role = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @role =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @role = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @role.push String.from_json(_item)
                        else
                          @role.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @role = _oa
                    end
                  end
                end

                # constructs a RestWorkflowAvailableAction from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestSememeDescriptionCreateData

                # The concept sequence of the concept that represents the case significance flag on the description .
                # This should be description case sensitive, description not case sensitive or description initial character sensitive
                attr_accessor :caseSignificanceConceptSequence
                # The concept sequence of the concept that represents the language of the description (note, this is NOT
                # the dialect)
                attr_accessor :languageConceptSequence
                # The text of the description
                attr_accessor :text
                # The concept sequence of the concept that represents the type of the description.
                # This should be FSN, Synonym, or Definition.
                attr_accessor :descriptionTypeConceptSequence
                # A concept sequence of an optional concept that represents an extended type of the description.
                # This may be something like Abbreviation or Vista Name
                attr_accessor :extendedDescriptionTypeConceptSequence
                # The preferred dialects attached to this sememe
                attr_accessor :preferredInDialectAssemblagesIds
                # The acceptable dialects attached to this sememe
                attr_accessor :acceptableInDialectAssemblagesIds
                # The nid of the component to which this sememe refers
                attr_accessor :referencedComponentNid

                # the json hash for this RestSememeDescriptionCreateData
                def to_jaxb_json_hash
                  _h = {}
                  _h['caseSignificanceConceptSequence'] = caseSignificanceConceptSequence.to_jaxb_json_hash unless caseSignificanceConceptSequence.nil?
                  _h['languageConceptSequence'] = languageConceptSequence.to_jaxb_json_hash unless languageConceptSequence.nil?
                  _h['text'] = text.to_jaxb_json_hash unless text.nil?
                  _h['descriptionTypeConceptSequence'] = descriptionTypeConceptSequence.to_jaxb_json_hash unless descriptionTypeConceptSequence.nil?
                  _h['extendedDescriptionTypeConceptSequence'] = extendedDescriptionTypeConceptSequence.to_jaxb_json_hash unless extendedDescriptionTypeConceptSequence.nil?
                  if !preferredInDialectAssemblagesIds.nil?
                    _ha = Array.new
                    preferredInDialectAssemblagesIds.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['preferredInDialectAssemblagesIds'] = _ha
                  end
                  if !acceptableInDialectAssemblagesIds.nil?
                    _ha = Array.new
                    acceptableInDialectAssemblagesIds.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['acceptableInDialectAssemblagesIds'] = _ha
                  end
                  _h['referencedComponentNid'] = referencedComponentNid.to_jaxb_json_hash unless referencedComponentNid.nil?
                  return _h
                end

                # the json (string form) for this RestSememeDescriptionCreateData
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestSememeDescriptionCreateData with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['caseSignificanceConceptSequence'].nil?
                    _oa = _o['caseSignificanceConceptSequence']
                    if(_oa.is_a? Hash)
                      @caseSignificanceConceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @caseSignificanceConceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @caseSignificanceConceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @caseSignificanceConceptSequence.push Fixnum.from_json(_item)
                        else
                          @caseSignificanceConceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @caseSignificanceConceptSequence = _oa
                    end
                  end
                  if !_o['languageConceptSequence'].nil?
                    _oa = _o['languageConceptSequence']
                    if(_oa.is_a? Hash)
                      @languageConceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @languageConceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @languageConceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @languageConceptSequence.push Fixnum.from_json(_item)
                        else
                          @languageConceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @languageConceptSequence = _oa
                    end
                  end
                  if !_o['text'].nil?
                    _oa = _o['text']
                    if(_oa.is_a? Hash)
                      @text = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @text =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @text = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @text.push String.from_json(_item)
                        else
                          @text.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @text = _oa
                    end
                  end
                  if !_o['descriptionTypeConceptSequence'].nil?
                    _oa = _o['descriptionTypeConceptSequence']
                    if(_oa.is_a? Hash)
                      @descriptionTypeConceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @descriptionTypeConceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @descriptionTypeConceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @descriptionTypeConceptSequence.push Fixnum.from_json(_item)
                        else
                          @descriptionTypeConceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @descriptionTypeConceptSequence = _oa
                    end
                  end
                  if !_o['extendedDescriptionTypeConceptSequence'].nil?
                    _oa = _o['extendedDescriptionTypeConceptSequence']
                    if(_oa.is_a? Hash)
                      @extendedDescriptionTypeConceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @extendedDescriptionTypeConceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @extendedDescriptionTypeConceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @extendedDescriptionTypeConceptSequence.push Fixnum.from_json(_item)
                        else
                          @extendedDescriptionTypeConceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @extendedDescriptionTypeConceptSequence = _oa
                    end
                  end
                  if !_o['preferredInDialectAssemblagesIds'].nil?
                    _oa = _o['preferredInDialectAssemblagesIds']
                    if(_oa.is_a? Hash)
                      @preferredInDialectAssemblagesIds = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @preferredInDialectAssemblagesIds =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @preferredInDialectAssemblagesIds = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @preferredInDialectAssemblagesIds.push Fixnum.from_json(_item)
                        else
                          @preferredInDialectAssemblagesIds.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @preferredInDialectAssemblagesIds = _oa
                    end
                  end
                  if !_o['acceptableInDialectAssemblagesIds'].nil?
                    _oa = _o['acceptableInDialectAssemblagesIds']
                    if(_oa.is_a? Hash)
                      @acceptableInDialectAssemblagesIds = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @acceptableInDialectAssemblagesIds =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @acceptableInDialectAssemblagesIds = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @acceptableInDialectAssemblagesIds.push Fixnum.from_json(_item)
                        else
                          @acceptableInDialectAssemblagesIds.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @acceptableInDialectAssemblagesIds = _oa
                    end
                  end
                  if !_o['referencedComponentNid'].nil?
                    _oa = _o['referencedComponentNid']
                    if(_oa.is_a? Hash)
                      @referencedComponentNid = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @referencedComponentNid =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @referencedComponentNid = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @referencedComponentNid.push Fixnum.from_json(_item)
                        else
                          @referencedComponentNid.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @referencedComponentNid = _oa
                    end
                  end
                end

                # constructs a RestSememeDescriptionCreateData from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Mapping

              # (no documentation provided)
              class RestMappingItemVersionBase

                # The target concept sequence being mapped by this map item.  This field is optional, and may be blank, if no target mapping
                # is available.
                attr_accessor :targetConcept
                # An (optional) concept sequence used to qualify this mapping entry
                attr_accessor :qualifierConcept
                # The (optional) extended fields which carry additional information about this map item.  For details on these fields, read
                # the assemblage definition of the assemblage concept provided with RestMappingSetVersion#mapItemExtendedFieldsType for
                # the RestMappingSetVersion of #mapSetConcept
                attr_accessor :mapItemExtendedFields

                # the json hash for this RestMappingItemVersionBase
                def to_jaxb_json_hash
                  _h = {}
                  _h['targetConcept'] = targetConcept.to_jaxb_json_hash unless targetConcept.nil?
                  _h['qualifierConcept'] = qualifierConcept.to_jaxb_json_hash unless qualifierConcept.nil?
                  if !mapItemExtendedFields.nil?
                    _ha = Array.new
                    mapItemExtendedFields.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['mapItemExtendedFields'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestMappingItemVersionBase
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestMappingItemVersionBase with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['targetConcept'].nil?
                    _oa = _o['targetConcept']
                    if(_oa.is_a? Hash)
                      @targetConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @targetConcept =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @targetConcept = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @targetConcept.push Fixnum.from_json(_item)
                        else
                          @targetConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @targetConcept = _oa
                    end
                  end
                  if !_o['qualifierConcept'].nil?
                    _oa = _o['qualifierConcept']
                    if(_oa.is_a? Hash)
                      @qualifierConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @qualifierConcept =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @qualifierConcept = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @qualifierConcept.push Fixnum.from_json(_item)
                        else
                          @qualifierConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @qualifierConcept = _oa
                    end
                  end
                  if !_o['mapItemExtendedFields'].nil?
                    _oa = _o['mapItemExtendedFields']
                    if(_oa.is_a? Hash)
                      @mapItemExtendedFields = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @mapItemExtendedFields =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @mapItemExtendedFields = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @mapItemExtendedFields.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                        else
                          @mapItemExtendedFields.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @mapItemExtendedFields = _oa
                    end
                  end
                end

                # constructs a RestMappingItemVersionBase from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Workflow

              # (no documentation provided)
              class RestWorkflowProcessHistory

                # The identifier data
                attr_accessor :id
                # The process id
                attr_accessor :processId
                # The workflow user
                attr_accessor :userId
                # The time advanced
                attr_accessor :timeAdvanced
                # The state
                attr_accessor :initialState
                # The action
                attr_accessor :action
                # The outcome
                attr_accessor :outcomeState
                # The comment
                attr_accessor :comment

                # the json hash for this RestWorkflowProcessHistory
                def to_jaxb_json_hash
                  _h = {}
                  _h['id'] = id.to_jaxb_json_hash unless id.nil?
                  _h['processId'] = processId.to_jaxb_json_hash unless processId.nil?
                  _h['userId'] = userId.to_jaxb_json_hash unless userId.nil?
                  _h['timeAdvanced'] = timeAdvanced.to_jaxb_json_hash unless timeAdvanced.nil?
                  _h['initialState'] = initialState.to_jaxb_json_hash unless initialState.nil?
                  _h['action'] = action.to_jaxb_json_hash unless action.nil?
                  _h['outcomeState'] = outcomeState.to_jaxb_json_hash unless outcomeState.nil?
                  _h['comment'] = comment.to_jaxb_json_hash unless comment.nil?
                  return _h
                end

                # the json (string form) for this RestWorkflowProcessHistory
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestWorkflowProcessHistory with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['id'].nil?
                    _oa = _o['id']
                    if(_oa.is_a? Hash)
                      @id = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @id =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @id = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @id.push String.from_json(_item)
                        else
                          @id.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @id = _oa
                    end
                  end
                  if !_o['processId'].nil?
                    _oa = _o['processId']
                    if(_oa.is_a? Hash)
                      @processId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @processId =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @processId = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @processId.push String.from_json(_item)
                        else
                          @processId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @processId = _oa
                    end
                  end
                  if !_o['userId'].nil?
                    _oa = _o['userId']
                    if(_oa.is_a? Hash)
                      @userId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @userId =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @userId = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @userId.push Fixnum.from_json(_item)
                        else
                          @userId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @userId = _oa
                    end
                  end
                  if !_o['timeAdvanced'].nil?
                    _oa = _o['timeAdvanced']
                    if(_oa.is_a? Hash)
                      @timeAdvanced = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @timeAdvanced =  Bignum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @timeAdvanced = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @timeAdvanced.push Bignum.from_json(_item)
                        else
                          @timeAdvanced.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @timeAdvanced = _oa
                    end
                  end
                  if !_o['initialState'].nil?
                    _oa = _o['initialState']
                    if(_oa.is_a? Hash)
                      @initialState = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @initialState =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @initialState = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @initialState.push String.from_json(_item)
                        else
                          @initialState.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @initialState = _oa
                    end
                  end
                  if !_o['action'].nil?
                    _oa = _o['action']
                    if(_oa.is_a? Hash)
                      @action = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @action =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @action = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @action.push String.from_json(_item)
                        else
                          @action.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @action = _oa
                    end
                  end
                  if !_o['outcomeState'].nil?
                    _oa = _o['outcomeState']
                    if(_oa.is_a? Hash)
                      @outcomeState = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @outcomeState =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @outcomeState = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @outcomeState.push String.from_json(_item)
                        else
                          @outcomeState.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @outcomeState = _oa
                    end
                  end
                  if !_o['comment'].nil?
                    _oa = _o['comment']
                    if(_oa.is_a? Hash)
                      @comment = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @comment =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @comment = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @comment.push String.from_json(_item)
                        else
                          @comment.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @comment = _oa
                    end
                  end
                end

                # constructs a RestWorkflowProcessHistory from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestSememeVersions

                # Link to retrieve current page
                attr_accessor :paginationData
                # The contained results
                attr_accessor :results

                # the json hash for this RestSememeVersions
                def to_jaxb_json_hash
                  _h = {}
                  _h['paginationData'] = paginationData.to_jaxb_json_hash unless paginationData.nil?
                  if !results.nil?
                    _ha = Array.new
                    results.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['results'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestSememeVersions
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestSememeVersions with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['paginationData'].nil?
                    _oa = _o['paginationData']
                    if(_oa.is_a? Hash)
                      @paginationData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @paginationData =  Gov::Vha::Isaac::Rest::Api::Data::Pagination.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @paginationData = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @paginationData.push Gov::Vha::Isaac::Rest::Api::Data::Pagination.from_json(_item)
                        else
                          @paginationData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @paginationData = _oa
                    end
                  end
                  if !_o['results'].nil?
                    _oa = _o['results']
                    if(_oa.is_a? Hash)
                      @results = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @results =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @results = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @results.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion.from_json(_item)
                        else
                          @results.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @results = _oa
                    end
                  end
                end

                # constructs a RestSememeVersions from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestDynamicSememeColumnInfo

                # The concept sequence number of the concept that represents the column within the dynamic sememe.
                attr_accessor :columnConceptSequence
                # The user-friendly name to display for this column.
                attr_accessor :columnName
                # The user friendly description for this column.  Suitable for things like tooltip descriptions.
                attr_accessor :columnDescription
                # The 0 indexed order of this column within the dynamic sememe.
                attr_accessor :columnOrder
                # The type of data that will be found in this column.  String, Integer, etc.  See
                # rest/1/enumeration/restDynamicSememeDataType for a list of all of the possible data types.
                attr_accessor :columnDataType
                # The default value to use for this column when creating a new sememe (if no user value is specified).
                # This field is optional and may be null.
                attr_accessor :columnDefaultData
                # Does the user have to provide a value for this column in order to create an instance of this sememe.
                attr_accessor :columnRequired
                # The validators types that are attached to this sememe (if any).  Interval, &lt;, etc.  See
                # rest/1/enumeration/restDynamicSememeValidatorType for a list of all possible validator types.
                attr_accessor :columnValidatorTypes
                # The data required to execute the validator type specified in columnValidatorTypes.  The format and type of this field
                # will depend on the columnValidatorTypes field.  The positions within this array will match with the columnValidatorTypes
                # array.
                attr_accessor :columnValidatorData

                # the json hash for this RestDynamicSememeColumnInfo
                def to_jaxb_json_hash
                  _h = {}
                  _h['columnConceptSequence'] = columnConceptSequence.to_jaxb_json_hash unless columnConceptSequence.nil?
                  _h['columnName'] = columnName.to_jaxb_json_hash unless columnName.nil?
                  _h['columnDescription'] = columnDescription.to_jaxb_json_hash unless columnDescription.nil?
                  _h['columnOrder'] = columnOrder.to_jaxb_json_hash unless columnOrder.nil?
                  _h['columnDataType'] = columnDataType.to_jaxb_json_hash unless columnDataType.nil?
                  _h['columnDefaultData'] = columnDefaultData.to_jaxb_json_hash unless columnDefaultData.nil?
                  _h['columnRequired'] = columnRequired.to_jaxb_json_hash unless columnRequired.nil?
                  if !columnValidatorTypes.nil?
                    _ha = Array.new
                    columnValidatorTypes.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['columnValidatorTypes'] = _ha
                  end
                  if !columnValidatorData.nil?
                    _ha = Array.new
                    columnValidatorData.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['columnValidatorData'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestDynamicSememeColumnInfo
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestDynamicSememeColumnInfo with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['columnConceptSequence'].nil?
                    _oa = _o['columnConceptSequence']
                    if(_oa.is_a? Hash)
                      @columnConceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnConceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnConceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnConceptSequence.push Fixnum.from_json(_item)
                        else
                          @columnConceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnConceptSequence = _oa
                    end
                  end
                  if !_o['columnName'].nil?
                    _oa = _o['columnName']
                    if(_oa.is_a? Hash)
                      @columnName = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnName =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnName = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnName.push String.from_json(_item)
                        else
                          @columnName.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnName = _oa
                    end
                  end
                  if !_o['columnDescription'].nil?
                    _oa = _o['columnDescription']
                    if(_oa.is_a? Hash)
                      @columnDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnDescription =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnDescription = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnDescription.push String.from_json(_item)
                        else
                          @columnDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnDescription = _oa
                    end
                  end
                  if !_o['columnOrder'].nil?
                    _oa = _o['columnOrder']
                    if(_oa.is_a? Hash)
                      @columnOrder = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnOrder =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnOrder = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnOrder.push Fixnum.from_json(_item)
                        else
                          @columnOrder.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnOrder = _oa
                    end
                  end
                  if !_o['columnDataType'].nil?
                    _oa = _o['columnDataType']
                    if(_oa.is_a? Hash)
                      @columnDataType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnDataType =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeDataType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnDataType = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnDataType.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeDataType.from_json(_item)
                        else
                          @columnDataType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnDataType = _oa
                    end
                  end
                  if !_o['columnDefaultData'].nil?
                    _oa = _o['columnDefaultData']
                    if(_oa.is_a? Hash)
                      @columnDefaultData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnDefaultData =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnDefaultData = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnDefaultData.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                        else
                          @columnDefaultData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnDefaultData = _oa
                    end
                  end
                  if !_o['columnRequired'].nil?
                    _oa = _o['columnRequired']
                    if(_oa.is_a? Hash)
                      @columnRequired = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnRequired =  Boolean.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnRequired = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnRequired.push Boolean.from_json(_item)
                        else
                          @columnRequired.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnRequired = _oa
                    end
                  end
                  if !_o['columnValidatorTypes'].nil?
                    _oa = _o['columnValidatorTypes']
                    if(_oa.is_a? Hash)
                      @columnValidatorTypes = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnValidatorTypes =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeValidatorType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnValidatorTypes = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnValidatorTypes.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeValidatorType.from_json(_item)
                        else
                          @columnValidatorTypes.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnValidatorTypes = _oa
                    end
                  end
                  if !_o['columnValidatorData'].nil?
                    _oa = _o['columnValidatorData']
                    if(_oa.is_a? Hash)
                      @columnValidatorData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnValidatorData =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnValidatorData = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnValidatorData.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                        else
                          @columnValidatorData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnValidatorData = _oa
                    end
                  end
                end

                # constructs a RestDynamicSememeColumnInfo from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api

          module Data

            module Wrappers

              # (no documentation provided)
              class RestBoolean

                # The boolean value
                attr_accessor :value

                # the json hash for this RestBoolean
                def to_jaxb_json_hash
                  _h = {}
                  _h['value'] = value.to_jaxb_json_hash unless value.nil?
                  return _h
                end

                # the json (string form) for this RestBoolean
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestBoolean with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['value'].nil?
                    _oa = _o['value']
                    if(_oa.is_a? Hash)
                      @value = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @value =  Boolean.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @value = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @value.push Boolean.from_json(_item)
                        else
                          @value.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @value = _oa
                    end
                  end
                end

                # constructs a RestBoolean from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Mapping

              # (no documentation provided)
              class RestMappingSetExtensionValueBase

                # The value to store for this mapping set extension.  By the API, this could support any implementing type of RestDynamicSememeData - but
                # in practice, the only currently supported types are:
                # RestDynamicSememeString (for arbitrary values) and RestDynamicSememeNid, RestDynamicSememeUUID for storing a reference
                # to another concept or sememe.  Internally, the  UUID type will be mapped to nid - and a read operation will only return RestDynamicSememeString
                # or RestDynamicSememeNid
                attr_accessor :extensionValue

                # the json hash for this RestMappingSetExtensionValueBase
                def to_jaxb_json_hash
                  _h = {}
                  _h['extensionValue'] = extensionValue.to_jaxb_json_hash unless extensionValue.nil?
                  return _h
                end

                # the json (string form) for this RestMappingSetExtensionValueBase
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestMappingSetExtensionValueBase with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['extensionValue'].nil?
                    _oa = _o['extensionValue']
                    if(_oa.is_a? Hash)
                      @extensionValue = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @extensionValue =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @extensionValue = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @extensionValue.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                        else
                          @extensionValue.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @extensionValue = _oa
                    end
                  end
                end

                # constructs a RestMappingSetExtensionValueBase from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Mapping

              # (no documentation provided)
              class RestMappingSetVersions

                # The list of RestMappingSetVersion objects
                attr_accessor :mappingSetVersions

                # the json hash for this RestMappingSetVersions
                def to_jaxb_json_hash
                  _h = {}
                  if !mappingSetVersions.nil?
                    _ha = Array.new
                    mappingSetVersions.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['mappingSetVersions'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestMappingSetVersions
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestMappingSetVersions with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['mappingSetVersions'].nil?
                    _oa = _o['mappingSetVersions']
                    if(_oa.is_a? Hash)
                      @mappingSetVersions = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @mappingSetVersions =  Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @mappingSetVersions = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @mappingSetVersions.push Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetVersion.from_json(_item)
                        else
                          @mappingSetVersions.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @mappingSetVersions = _oa
                    end
                  end
                end

                # constructs a RestMappingSetVersions from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Mapping

              # (no documentation provided)
              class RestMappingItemVersions

                # The list of RestMappingItemVersion objects
                attr_accessor :mappingItemVersions

                # the json hash for this RestMappingItemVersions
                def to_jaxb_json_hash
                  _h = {}
                  if !mappingItemVersions.nil?
                    _ha = Array.new
                    mappingItemVersions.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['mappingItemVersions'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestMappingItemVersions
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestMappingItemVersions with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['mappingItemVersions'].nil?
                    _oa = _o['mappingItemVersions']
                    if(_oa.is_a? Hash)
                      @mappingItemVersions = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @mappingItemVersions =  Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingItemVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @mappingItemVersions = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @mappingItemVersions.push Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingItemVersion.from_json(_item)
                        else
                          @mappingItemVersions.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @mappingItemVersions = _oa
                    end
                  end
                end

                # constructs a RestMappingItemVersions from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Search

              # (no documentation provided)
              class RestSearchResults

                # Link to retrieve current page
                attr_accessor :paginationData
                # The contained results
                attr_accessor :results

                # the json hash for this RestSearchResults
                def to_jaxb_json_hash
                  _h = {}
                  _h['paginationData'] = paginationData.to_jaxb_json_hash unless paginationData.nil?
                  if !results.nil?
                    _ha = Array.new
                    results.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['results'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestSearchResults
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestSearchResults with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['paginationData'].nil?
                    _oa = _o['paginationData']
                    if(_oa.is_a? Hash)
                      @paginationData = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @paginationData =  Gov::Vha::Isaac::Rest::Api::Data::Pagination.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @paginationData = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @paginationData.push Gov::Vha::Isaac::Rest::Api::Data::Pagination.from_json(_item)
                        else
                          @paginationData.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @paginationData = _oa
                    end
                  end
                  if !_o['results'].nil?
                    _oa = _o['results']
                    if(_oa.is_a? Hash)
                      @results = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @results =  Gov::Vha::Isaac::Rest::Api1::Data::Search::RestSearchResult.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @results = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @results.push Gov::Vha::Isaac::Rest::Api1::Data::Search::RestSearchResult.from_json(_item)
                        else
                          @results.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @results = _oa
                    end
                  end
                end

                # constructs a RestSearchResults from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestLogicNode

                # The RestNodeSemanticType type of this node corresponding to the NodeSemantic enum
                attr_accessor :nodeSemantic
                # The UUID of the logic node itself (not of any referenced or associated component or concept)
                attr_accessor :nodeUuid
                # The list of child RestLogicNode instances contained within this RestLogicNode.
                # A RestTypedConnctorNode may have exactly one child node
                # A literal node may not have any child nodes at all
                # Others may have one or more child nodes
                attr_accessor :children

                # the json hash for this RestLogicNode
                def to_jaxb_json_hash
                  _h = {}
                  _h['nodeSemantic'] = nodeSemantic.to_jaxb_json_hash unless nodeSemantic.nil?
                  _h['nodeUuid'] = nodeUuid.to_jaxb_json_hash unless nodeUuid.nil?
                  if !children.nil?
                    _ha = Array.new
                    children.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['children'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestLogicNode
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestLogicNode with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['nodeSemantic'].nil?
                    _oa = _o['nodeSemantic']
                    if(_oa.is_a? Hash)
                      @nodeSemantic = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @nodeSemantic =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestNodeSemanticType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @nodeSemantic = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @nodeSemantic.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestNodeSemanticType.from_json(_item)
                        else
                          @nodeSemantic.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @nodeSemantic = _oa
                    end
                  end
                  if !_o['nodeUuid'].nil?
                    _oa = _o['nodeUuid']
                    if(_oa.is_a? Hash)
                      @nodeUuid = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @nodeUuid =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @nodeUuid = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @nodeUuid.push String.from_json(_item)
                        else
                          @nodeUuid.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @nodeUuid = _oa
                    end
                  end
                  if !_o['children'].nil?
                    _oa = _o['children']
                    if(_oa.is_a? Hash)
                      @children = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @children =  Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @children = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @children.push Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode.from_json(_item)
                        else
                          @children.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @children = _oa
                    end
                  end
                end

                # constructs a RestLogicNode from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestSememeVersion

                # The data that was not expanded as part of this call (but can be)
                attr_accessor :expandables
                # The sememe chronology for this concept.  Depending on the expand parameter, may be empty.
                attr_accessor :sememeChronology
                # The StampedVersion details for this version of this sememe.
                attr_accessor :sememeVersion
                # The nested sememes attached to this sememe.  Not populated by default, include expand=nested to expand these.
                attr_accessor :nestedSememes

                # the json hash for this RestSememeVersion
                def to_jaxb_json_hash
                  _h = {}
                  _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
                  _h['sememeChronology'] = sememeChronology.to_jaxb_json_hash unless sememeChronology.nil?
                  _h['sememeVersion'] = sememeVersion.to_jaxb_json_hash unless sememeVersion.nil?
                  if !nestedSememes.nil?
                    _ha = Array.new
                    nestedSememes.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['nestedSememes'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestSememeVersion
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestSememeVersion with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['expandables'].nil?
                    _oa = _o['expandables']
                    if(_oa.is_a? Hash)
                      @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @expandables = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                        else
                          @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @expandables = _oa
                    end
                  end
                  if !_o['sememeChronology'].nil?
                    _oa = _o['sememeChronology']
                    if(_oa.is_a? Hash)
                      @sememeChronology = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @sememeChronology =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeChronology.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @sememeChronology = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @sememeChronology.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeChronology.from_json(_item)
                        else
                          @sememeChronology.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @sememeChronology = _oa
                    end
                  end
                  if !_o['sememeVersion'].nil?
                    _oa = _o['sememeVersion']
                    if(_oa.is_a? Hash)
                      @sememeVersion = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @sememeVersion =  Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @sememeVersion = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @sememeVersion.push Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_item)
                        else
                          @sememeVersion.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @sememeVersion = _oa
                    end
                  end
                  if !_o['nestedSememes'].nil?
                    _oa = _o['nestedSememes']
                    if(_oa.is_a? Hash)
                      @nestedSememes = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @nestedSememes =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @nestedSememes = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @nestedSememes.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeVersion.from_json(_item)
                        else
                          @nestedSememes.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @nestedSememes = _oa
                    end
                  end
                end

                # constructs a RestSememeVersion from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Workflow

              # (no documentation provided)
              class RestWorkflowProcessHistoriesMapEntry

                # The key RestWorkflowProcess
                attr_accessor :key
                # The value List&lt;RestWorkflowProcessHistory&gt;
                attr_accessor :value

                # the json hash for this RestWorkflowProcessHistoriesMapEntry
                def to_jaxb_json_hash
                  _h = {}
                  _h['key'] = key.to_jaxb_json_hash unless key.nil?
                  if !value.nil?
                    _ha = Array.new
                    value.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['value'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestWorkflowProcessHistoriesMapEntry
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestWorkflowProcessHistoriesMapEntry with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['key'].nil?
                    _oa = _o['key']
                    if(_oa.is_a? Hash)
                      @key = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @key =  Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowProcess.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @key = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @key.push Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowProcess.from_json(_item)
                        else
                          @key.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @key = _oa
                    end
                  end
                  if !_o['value'].nil?
                    _oa = _o['value']
                    if(_oa.is_a? Hash)
                      @value = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @value =  Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowProcessHistory.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @value = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @value.push Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowProcessHistory.from_json(_item)
                        else
                          @value.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @value = _oa
                    end
                  end
                end

                # constructs a RestWorkflowProcessHistoriesMapEntry from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api

          module Data

            # (no documentation provided)
            class Pagination

              # Link to retrieve previous result set page
              attr_accessor :previousUrl
              # Link to retrieve next result set page
              attr_accessor :nextUrl
              # The page (of maximum size pageSize) number from beginning of dataset starting at 1
              attr_accessor :pageNum
              # Estimated size of set of all matching values of which the current page is a subset. Value is negative if and only if unknown. May be affected by filtering.
              attr_accessor :approximateTotal

              # the json hash for this Pagination
              def to_jaxb_json_hash
                _h = {}
                _h['previousUrl'] = previousUrl.to_jaxb_json_hash unless previousUrl.nil?
                _h['nextUrl'] = nextUrl.to_jaxb_json_hash unless nextUrl.nil?
                _h['pageNum'] = pageNum.to_jaxb_json_hash unless pageNum.nil?
                _h['approximateTotal'] = approximateTotal.to_jaxb_json_hash unless approximateTotal.nil?
                return _h
              end

              # the json (string form) for this Pagination
              def to_json
                to_jaxb_json_hash.to_json
              end

              #initializes this Pagination with a json hash
              def init_jaxb_json_hash(_o)
                if !_o['previousUrl'].nil?
                  _oa = _o['previousUrl']
                  if(_oa.is_a? Hash)
                    @previousUrl = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @previousUrl =  String.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @previousUrl = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @previousUrl.push String.from_json(_item)
                      else
                        @previousUrl.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @previousUrl = _oa
                  end
                end
                if !_o['nextUrl'].nil?
                  _oa = _o['nextUrl']
                  if(_oa.is_a? Hash)
                    @nextUrl = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @nextUrl =  String.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @nextUrl = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @nextUrl.push String.from_json(_item)
                      else
                        @nextUrl.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @nextUrl = _oa
                  end
                end
                if !_o['pageNum'].nil?
                  _oa = _o['pageNum']
                  if(_oa.is_a? Hash)
                    @pageNum = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @pageNum =  Fixnum.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @pageNum = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @pageNum.push Fixnum.from_json(_item)
                      else
                        @pageNum.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @pageNum = _oa
                  end
                end
                if !_o['approximateTotal'].nil?
                  _oa = _o['approximateTotal']
                  if(_oa.is_a? Hash)
                    @approximateTotal = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @approximateTotal =  Fixnum.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @approximateTotal = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @approximateTotal.push Fixnum.from_json(_item)
                      else
                        @approximateTotal.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @approximateTotal = _oa
                  end
                end
              end

              # constructs a Pagination from a (parsed) JSON hash
              def self.from_json(o)
                if o.nil?
                  return nil
                else
                  inst = new
                  inst.init_jaxb_json_hash o
                  return inst
                end
              end
            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api

          module Data

            # (no documentation provided)
            class Expandable

              # The name of the item that is expandable (pass this to have this value expanded directly by the call that produced this)
              attr_accessor :name
              # The url to call to get the expanded item separately
              attr_accessor :url

              # the json hash for this Expandable
              def to_jaxb_json_hash
                _h = {}
                _h['name'] = name.to_jaxb_json_hash unless name.nil?
                _h['url'] = url.to_jaxb_json_hash unless url.nil?
                return _h
              end

              # the json (string form) for this Expandable
              def to_json
                to_jaxb_json_hash.to_json
              end

              #initializes this Expandable with a json hash
              def init_jaxb_json_hash(_o)
                if !_o['name'].nil?
                  _oa = _o['name']
                  if(_oa.is_a? Hash)
                    @name = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @name =  String.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @name = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @name.push String.from_json(_item)
                      else
                        @name.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @name = _oa
                  end
                end
                if !_o['url'].nil?
                  _oa = _o['url']
                  if(_oa.is_a? Hash)
                    @url = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @url =  String.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @url = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @url.push String.from_json(_item)
                      else
                        @url.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @url = _oa
                  end
                end
              end

              # constructs a Expandable from a (parsed) JSON hash
              def self.from_json(o)
                if o.nil?
                  return nil
                else
                  inst = new
                  inst.init_jaxb_json_hash o
                  return inst
                end
              end
            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Coordinate

              # (no documentation provided)
              class RestStampCoordinate

                # Long epoch time component of the RestStampCoordinate.
                # Corresponds to the time component of the StampPosition component of the OCHRE StampCoordinate.
                attr_accessor :time
                # Sequence number of the path concept.
                # Corresponds to the path component of the StampPosition component of the OCHRE StampCoordinate
                attr_accessor :path
                # RestStampPrecedenceType Enumeration specifying precedence. Values are either PATH or TIME.
                attr_accessor :precedence
                # Set of module concept sequence numbers.
                attr_accessor :modules
                # Set of RestStateType Enumeration values determining allowed RestStateType values.
                # Values include INACTIVE, ACTIVE, PRIMORDIAL and CANCELLED.
                attr_accessor :allowedStates

                # the json hash for this RestStampCoordinate
                def to_jaxb_json_hash
                  _h = {}
                  _h['time'] = time.to_jaxb_json_hash unless time.nil?
                  _h['path'] = path.to_jaxb_json_hash unless path.nil?
                  _h['precedence'] = precedence.to_jaxb_json_hash unless precedence.nil?
                  if !modules.nil?
                    _ha = Array.new
                    modules.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['modules'] = _ha
                  end
                  if !allowedStates.nil?
                    _ha = Array.new
                    allowedStates.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['allowedStates'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestStampCoordinate
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestStampCoordinate with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['time'].nil?
                    _oa = _o['time']
                    if(_oa.is_a? Hash)
                      @time = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @time =  Bignum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @time = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @time.push Bignum.from_json(_item)
                        else
                          @time.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @time = _oa
                    end
                  end
                  if !_o['path'].nil?
                    _oa = _o['path']
                    if(_oa.is_a? Hash)
                      @path = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @path =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @path = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @path.push Fixnum.from_json(_item)
                        else
                          @path.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @path = _oa
                    end
                  end
                  if !_o['precedence'].nil?
                    _oa = _o['precedence']
                    if(_oa.is_a? Hash)
                      @precedence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @precedence =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStampPrecedenceType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @precedence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @precedence.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStampPrecedenceType.from_json(_item)
                        else
                          @precedence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @precedence = _oa
                    end
                  end
                  if !_o['modules'].nil?
                    _oa = _o['modules']
                    if(_oa.is_a? Hash)
                      @modules = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @modules =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @modules = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @modules.push Fixnum.from_json(_item)
                        else
                          @modules.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @modules = _oa
                    end
                  end
                  if !_o['allowedStates'].nil?
                    _oa = _o['allowedStates']
                    if(_oa.is_a? Hash)
                      @allowedStates = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @allowedStates =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStateType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @allowedStates = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @allowedStates.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStateType.from_json(_item)
                        else
                          @allowedStates.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @allowedStates = _oa
                    end
                  end
                end

                # constructs a RestStampCoordinate from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            # (no documentation provided)
            class RestId

              # The id value
              attr_accessor :value
              # The id type
              attr_accessor :idType

              # the json hash for this RestId
              def to_jaxb_json_hash
                _h = {}
                _h['value'] = value.to_jaxb_json_hash unless value.nil?
                _h['idType'] = idType.to_jaxb_json_hash unless idType.nil?
                return _h
              end

              # the json (string form) for this RestId
              def to_json
                to_jaxb_json_hash.to_json
              end

              #initializes this RestId with a json hash
              def init_jaxb_json_hash(_o)
                if !_o['value'].nil?
                  _oa = _o['value']
                  if(_oa.is_a? Hash)
                    @value = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @value =  String.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @value = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @value.push String.from_json(_item)
                      else
                        @value.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @value = _oa
                  end
                end
                if !_o['idType'].nil?
                  _oa = _o['idType']
                  if(_oa.is_a? Hash)
                    @idType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @idType =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSupportedIdType.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @idType = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @idType.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSupportedIdType.from_json(_item)
                      else
                        @idType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @idType = _oa
                  end
                end
              end

              # constructs a RestId from a (parsed) JSON hash
              def self.from_json(o)
                if o.nil?
                  return nil
                else
                  inst = new
                  inst.init_jaxb_json_hash o
                  return inst
                end
              end
            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestDynamicSememeData

                # The 0 indexed column number for this data.  Will not be populated for nested RestDynamicSememeData objects where the &#39;data&#39; field
                # is of type RestDynamicSememeArray
                attr_accessor :columnNumber
                # The data for a column within a RestDynamicSememeVersion instance
                attr_accessor :data

                # the json hash for this RestDynamicSememeData
                def to_jaxb_json_hash
                  _h = {}
                  _h['columnNumber'] = columnNumber.to_jaxb_json_hash unless columnNumber.nil?
                  _h['data'] = data.to_jaxb_json_hash unless data.nil?
                  return _h
                end

                # the json (string form) for this RestDynamicSememeData
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestDynamicSememeData with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['columnNumber'].nil?
                    _oa = _o['columnNumber']
                    if(_oa.is_a? Hash)
                      @columnNumber = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @columnNumber =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @columnNumber = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @columnNumber.push Fixnum.from_json(_item)
                        else
                          @columnNumber.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @columnNumber = _oa
                    end
                  end
                  if !_o['data'].nil?
                    _oa = _o['data']
                    if(_oa.is_a? Hash)
                      @data = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @data =  Object.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @data = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @data.push Object.from_json(_item)
                        else
                          @data.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @data = _oa
                    end
                  end
                end

                # constructs a RestDynamicSememeData from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Workflow

              # (no documentation provided)
              class RestWorkflowProcessComponentSpecificationData

                # The process id of the process to advance
                attr_accessor :processId
                # The specified component int NID
                attr_accessor :componentNid

                # the json hash for this RestWorkflowProcessComponentSpecificationData
                def to_jaxb_json_hash
                  _h = {}
                  _h['processId'] = processId.to_jaxb_json_hash unless processId.nil?
                  _h['componentNid'] = componentNid.to_jaxb_json_hash unless componentNid.nil?
                  return _h
                end

                # the json (string form) for this RestWorkflowProcessComponentSpecificationData
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestWorkflowProcessComponentSpecificationData with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['processId'].nil?
                    _oa = _o['processId']
                    if(_oa.is_a? Hash)
                      @processId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @processId =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @processId = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @processId.push String.from_json(_item)
                        else
                          @processId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @processId = _oa
                    end
                  end
                  if !_o['componentNid'].nil?
                    _oa = _o['componentNid']
                    if(_oa.is_a? Hash)
                      @componentNid = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @componentNid =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @componentNid = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @componentNid.push Fixnum.from_json(_item)
                        else
                          @componentNid.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @componentNid = _oa
                    end
                  end
                end

                # constructs a RestWorkflowProcessComponentSpecificationData from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Systeminfo

              # (no documentation provided)
              class RestDependencyInfo

                # Maven Dependency Group ID
                attr_accessor :groupId
                # Maven Dependency Artifact ID
                attr_accessor :artifactId
                # Maven Dependency Version
                attr_accessor :version
                # Maven Dependency Classifier
                attr_accessor :classifier
                # Maven Dependency Type
                attr_accessor :type

                # the json hash for this RestDependencyInfo
                def to_jaxb_json_hash
                  _h = {}
                  _h['groupId'] = groupId.to_jaxb_json_hash unless groupId.nil?
                  _h['artifactId'] = artifactId.to_jaxb_json_hash unless artifactId.nil?
                  _h['version'] = version.to_jaxb_json_hash unless version.nil?
                  _h['classifier'] = classifier.to_jaxb_json_hash unless classifier.nil?
                  _h['type'] = type.to_jaxb_json_hash unless type.nil?
                  return _h
                end

                # the json (string form) for this RestDependencyInfo
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestDependencyInfo with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['groupId'].nil?
                    _oa = _o['groupId']
                    if(_oa.is_a? Hash)
                      @groupId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @groupId =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @groupId = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @groupId.push String.from_json(_item)
                        else
                          @groupId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @groupId = _oa
                    end
                  end
                  if !_o['artifactId'].nil?
                    _oa = _o['artifactId']
                    if(_oa.is_a? Hash)
                      @artifactId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @artifactId =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @artifactId = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @artifactId.push String.from_json(_item)
                        else
                          @artifactId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @artifactId = _oa
                    end
                  end
                  if !_o['version'].nil?
                    _oa = _o['version']
                    if(_oa.is_a? Hash)
                      @version = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @version =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @version = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @version.push String.from_json(_item)
                        else
                          @version.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @version = _oa
                    end
                  end
                  if !_o['classifier'].nil?
                    _oa = _o['classifier']
                    if(_oa.is_a? Hash)
                      @classifier = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @classifier =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @classifier = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @classifier.push String.from_json(_item)
                        else
                          @classifier.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @classifier = _oa
                    end
                  end
                  if !_o['type'].nil?
                    _oa = _o['type']
                    if(_oa.is_a? Hash)
                      @type = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @type =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @type = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @type.push String.from_json(_item)
                        else
                          @type.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @type = _oa
                    end
                  end
                end

                # constructs a RestDependencyInfo from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Systeminfo

              # (no documentation provided)
              class RestLicenseInfo

                # Name of the license
                attr_accessor :name
                # URL to the license text
                attr_accessor :url
                # Comments related to the license
                attr_accessor :comments

                # the json hash for this RestLicenseInfo
                def to_jaxb_json_hash
                  _h = {}
                  _h['name'] = name.to_jaxb_json_hash unless name.nil?
                  _h['url'] = url.to_jaxb_json_hash unless url.nil?
                  _h['comments'] = comments.to_jaxb_json_hash unless comments.nil?
                  return _h
                end

                # the json (string form) for this RestLicenseInfo
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestLicenseInfo with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['name'].nil?
                    _oa = _o['name']
                    if(_oa.is_a? Hash)
                      @name = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @name =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @name = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @name.push String.from_json(_item)
                        else
                          @name.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @name = _oa
                    end
                  end
                  if !_o['url'].nil?
                    _oa = _o['url']
                    if(_oa.is_a? Hash)
                      @url = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @url =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @url = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @url.push String.from_json(_item)
                        else
                          @url.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @url = _oa
                    end
                  end
                  if !_o['comments'].nil?
                    _oa = _o['comments']
                    if(_oa.is_a? Hash)
                      @comments = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @comments =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @comments = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @comments.push String.from_json(_item)
                        else
                          @comments.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @comments = _oa
                    end
                  end
                end

                # constructs a RestLicenseInfo from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Coordinate

              # (no documentation provided)
              class RestLanguageCoordinate

                # Sequence number of the language concept associated with the language coordinate.
                # The language will be something like
                # english, spanish, french, danish, polish, dutch,
                # lithuanian, chinese, japanese, or swedish.
                attr_accessor :language
                # Ordered list of dialect assemblage sequence numbers. Order determines preference.
                # A dialect assemblage will be something like US (US Dialect) or GB (Great Britain Dialect).
                attr_accessor :dialectAssemblagePreferences
                # Ordered list of description type sequence numbers. Order determines preference.
                # A description type will be something like FSN (Fully Specified Name), Synonym or Definition.
                attr_accessor :descriptionTypePreferences

                # the json hash for this RestLanguageCoordinate
                def to_jaxb_json_hash
                  _h = {}
                  _h['language'] = language.to_jaxb_json_hash unless language.nil?
                  if !dialectAssemblagePreferences.nil?
                    _ha = Array.new
                    dialectAssemblagePreferences.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['dialectAssemblagePreferences'] = _ha
                  end
                  if !descriptionTypePreferences.nil?
                    _ha = Array.new
                    descriptionTypePreferences.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['descriptionTypePreferences'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestLanguageCoordinate
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestLanguageCoordinate with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['language'].nil?
                    _oa = _o['language']
                    if(_oa.is_a? Hash)
                      @language = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @language =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @language = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @language.push Fixnum.from_json(_item)
                        else
                          @language.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @language = _oa
                    end
                  end
                  if !_o['dialectAssemblagePreferences'].nil?
                    _oa = _o['dialectAssemblagePreferences']
                    if(_oa.is_a? Hash)
                      @dialectAssemblagePreferences = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @dialectAssemblagePreferences =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @dialectAssemblagePreferences = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @dialectAssemblagePreferences.push Fixnum.from_json(_item)
                        else
                          @dialectAssemblagePreferences.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @dialectAssemblagePreferences = _oa
                    end
                  end
                  if !_o['descriptionTypePreferences'].nil?
                    _oa = _o['descriptionTypePreferences']
                    if(_oa.is_a? Hash)
                      @descriptionTypePreferences = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @descriptionTypePreferences =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @descriptionTypePreferences = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @descriptionTypePreferences.push Fixnum.from_json(_item)
                        else
                          @descriptionTypePreferences.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @descriptionTypePreferences = _oa
                    end
                  end
                end

                # constructs a RestLanguageCoordinate from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Systeminfo

              # (no documentation provided)
              class RestIdentifiedObjectsResult

                # Zero or one concept chronology
                attr_accessor :concept
                # Zero or one sememe chronology
                attr_accessor :sememe

                # the json hash for this RestIdentifiedObjectsResult
                def to_jaxb_json_hash
                  _h = {}
                  _h['concept'] = concept.to_jaxb_json_hash unless concept.nil?
                  _h['sememe'] = sememe.to_jaxb_json_hash unless sememe.nil?
                  return _h
                end

                # the json (string form) for this RestIdentifiedObjectsResult
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestIdentifiedObjectsResult with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['concept'].nil?
                    _oa = _o['concept']
                    if(_oa.is_a? Hash)
                      @concept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @concept =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @concept = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @concept.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_item)
                        else
                          @concept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @concept = _oa
                    end
                  end
                  if !_o['sememe'].nil?
                    _oa = _o['sememe']
                    if(_oa.is_a? Hash)
                      @sememe = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @sememe =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeChronology.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @sememe = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @sememe.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeChronology.from_json(_item)
                        else
                          @sememe.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @sememe = _oa
                    end
                  end
                end

                # constructs a RestIdentifiedObjectsResult from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Workflow

              # (no documentation provided)
              class RestWorkflowProcessHistories

                # The contained results
                attr_accessor :results

                # the json hash for this RestWorkflowProcessHistories
                def to_jaxb_json_hash
                  _h = {}
                  if !results.nil?
                    _ha = Array.new
                    results.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['results'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestWorkflowProcessHistories
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestWorkflowProcessHistories with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['results'].nil?
                    _oa = _o['results']
                    if(_oa.is_a? Hash)
                      @results = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @results =  Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowProcessHistory.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @results = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @results.push Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowProcessHistory.from_json(_item)
                        else
                          @results.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @results = _oa
                    end
                  end
                end

                # constructs a RestWorkflowProcessHistories from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            # (no documentation provided)
            class RestStampedVersion

              # The stamp sequence of this version
              attr_accessor :stampSequence
              # The State of this version (active, inactive, primordial or cancelled)
              attr_accessor :state
              # The time stamp of this version (in standard java form)
              attr_accessor :time
              # The concept sequence of the concept that identifies the author of this version
              attr_accessor :authorSequence
              # The concept sequence of the module that this version is in
              attr_accessor :moduleSequence
              # The concept sequence of the path that this version is in
              attr_accessor :pathSequence

              # the json hash for this RestStampedVersion
              def to_jaxb_json_hash
                _h = {}
                _h['stampSequence'] = stampSequence.to_jaxb_json_hash unless stampSequence.nil?
                _h['state'] = state.to_jaxb_json_hash unless state.nil?
                _h['time'] = time.to_jaxb_json_hash unless time.nil?
                _h['authorSequence'] = authorSequence.to_jaxb_json_hash unless authorSequence.nil?
                _h['moduleSequence'] = moduleSequence.to_jaxb_json_hash unless moduleSequence.nil?
                _h['pathSequence'] = pathSequence.to_jaxb_json_hash unless pathSequence.nil?
                return _h
              end

              # the json (string form) for this RestStampedVersion
              def to_json
                to_jaxb_json_hash.to_json
              end

              #initializes this RestStampedVersion with a json hash
              def init_jaxb_json_hash(_o)
                if !_o['stampSequence'].nil?
                  _oa = _o['stampSequence']
                  if(_oa.is_a? Hash)
                    @stampSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @stampSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @stampSequence = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @stampSequence.push Fixnum.from_json(_item)
                      else
                        @stampSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @stampSequence = _oa
                  end
                end
                if !_o['state'].nil?
                  _oa = _o['state']
                  if(_oa.is_a? Hash)
                    @state = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @state =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStateType.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @state = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @state.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStateType.from_json(_item)
                      else
                        @state.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @state = _oa
                  end
                end
                if !_o['time'].nil?
                  _oa = _o['time']
                  if(_oa.is_a? Hash)
                    @time = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @time =  Bignum.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @time = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @time.push Bignum.from_json(_item)
                      else
                        @time.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @time = _oa
                  end
                end
                if !_o['authorSequence'].nil?
                  _oa = _o['authorSequence']
                  if(_oa.is_a? Hash)
                    @authorSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @authorSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @authorSequence = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @authorSequence.push Fixnum.from_json(_item)
                      else
                        @authorSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @authorSequence = _oa
                  end
                end
                if !_o['moduleSequence'].nil?
                  _oa = _o['moduleSequence']
                  if(_oa.is_a? Hash)
                    @moduleSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @moduleSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @moduleSequence = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @moduleSequence.push Fixnum.from_json(_item)
                      else
                        @moduleSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @moduleSequence = _oa
                  end
                end
                if !_o['pathSequence'].nil?
                  _oa = _o['pathSequence']
                  if(_oa.is_a? Hash)
                    @pathSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @pathSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @pathSequence = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @pathSequence.push Fixnum.from_json(_item)
                      else
                        @pathSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @pathSequence = _oa
                  end
                end
              end

              # constructs a RestStampedVersion from a (parsed) JSON hash
              def self.from_json(o)
                if o.nil?
                  return nil
                else
                  inst = new
                  inst.init_jaxb_json_hash o
                  return inst
                end
              end
            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Comment

              # (no documentation provided)
              class RestCommentVersions

                # The list of RestCommentVersion objects
                attr_accessor :commentVersions

                # the json hash for this RestCommentVersions
                def to_jaxb_json_hash
                  _h = {}
                  if !commentVersions.nil?
                    _ha = Array.new
                    commentVersions.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['commentVersions'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestCommentVersions
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestCommentVersions with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['commentVersions'].nil?
                    _oa = _o['commentVersions']
                    if(_oa.is_a? Hash)
                      @commentVersions = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @commentVersions =  Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @commentVersions = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @commentVersions.push Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersion.from_json(_item)
                        else
                          @commentVersions.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @commentVersions = _oa
                    end
                  end
                end

                # constructs a RestCommentVersions from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api

          module Data

            # (no documentation provided)
            class Expandables

              # The list of data types that were not expanded on this request that could be expanded directly, or can
              # be expanded with a second trip by calling the provided URL
              attr_accessor :items

              # the json hash for this Expandables
              def to_jaxb_json_hash
                _h = {}
                if !items.nil?
                  _ha = Array.new
                  items.each { | _item | _ha.push _item.to_jaxb_json_hash }
                  _h['items'] = _ha
                end
                return _h
              end

              # the json (string form) for this Expandables
              def to_json
                to_jaxb_json_hash.to_json
              end

              #initializes this Expandables with a json hash
              def init_jaxb_json_hash(_o)
                if !_o['items'].nil?
                  _oa = _o['items']
                  if(_oa.is_a? Hash)
                    @items = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @items =  Gov::Vha::Isaac::Rest::Api::Data::Expandable.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @items = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @items.push Gov::Vha::Isaac::Rest::Api::Data::Expandable.from_json(_item)
                      else
                        @items.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @items = _oa
                  end
                end
              end

              # constructs a Expandables from a (parsed) JSON hash
              def self.from_json(o)
                if o.nil?
                  return nil
                else
                  inst = new
                  inst.init_jaxb_json_hash o
                  return inst
                end
              end
            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            # (no documentation provided)
            class RestIdentifiedObject

              # The globally unique, fixed, stable set of identifiers for the object
              attr_accessor :uuids

              # the json hash for this RestIdentifiedObject
              def to_jaxb_json_hash
                _h = {}
                if !uuids.nil?
                  _ha = Array.new
                  uuids.each { | _item | _ha.push _item.to_jaxb_json_hash }
                  _h['uuids'] = _ha
                end
                return _h
              end

              # the json (string form) for this RestIdentifiedObject
              def to_json
                to_jaxb_json_hash.to_json
              end

              #initializes this RestIdentifiedObject with a json hash
              def init_jaxb_json_hash(_o)
                if !_o['uuids'].nil?
                  _oa = _o['uuids']
                  if(_oa.is_a? Hash)
                    @uuids = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                    @uuids =  String.from_json(_oa) unless _oa['@class']
                  elsif (_oa.is_a? Array)
                    #an array(of hashes hopefully) or scalar
                    @uuids = Array.new
                    _oa.each { | _item |
                      if ((_item.nil? || _item['@class'].nil?)rescue true)
                        @uuids.push String.from_json(_item)
                      else
                        @uuids.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                      end
                    }
                  else
                    @uuids = _oa
                  end
                end
              end

              # constructs a RestIdentifiedObject from a (parsed) JSON hash
              def self.from_json(o)
                if o.nil?
                  return nil
                else
                  inst = new
                  inst.init_jaxb_json_hash o
                  return inst
                end
              end
            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestSememeDescriptionVersions

                # The contained results
                attr_accessor :results

                # the json hash for this RestSememeDescriptionVersions
                def to_jaxb_json_hash
                  _h = {}
                  if !results.nil?
                    _ha = Array.new
                    results.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['results'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestSememeDescriptionVersions
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestSememeDescriptionVersions with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['results'].nil?
                    _oa = _o['results']
                    if(_oa.is_a? Hash)
                      @results = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @results =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeDescriptionVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @results = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @results.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeDescriptionVersion.from_json(_item)
                        else
                          @results.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @results = _oa
                    end
                  end
                end

                # constructs a RestSememeDescriptionVersions from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Workflow

              # (no documentation provided)
              class RestWorkflowAvailableActions

                # The contained results
                attr_accessor :results

                # the json hash for this RestWorkflowAvailableActions
                def to_jaxb_json_hash
                  _h = {}
                  if !results.nil?
                    _ha = Array.new
                    results.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['results'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestWorkflowAvailableActions
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestWorkflowAvailableActions with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['results'].nil?
                    _oa = _o['results']
                    if(_oa.is_a? Hash)
                      @results = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @results =  Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowAvailableAction.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @results = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @results.push Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowAvailableAction.from_json(_item)
                        else
                          @results.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @results = _oa
                    end
                  end
                end

                # constructs a RestWorkflowAvailableActions from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api

          module Data

            module Wrappers

              # (no documentation provided)
              class RestUUID

                # The Integer value
                attr_accessor :value

                # the json hash for this RestUUID
                def to_jaxb_json_hash
                  _h = {}
                  _h['value'] = value.to_jaxb_json_hash unless value.nil?
                  return _h
                end

                # the json (string form) for this RestUUID
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestUUID with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['value'].nil?
                    _oa = _o['value']
                    if(_oa.is_a? Hash)
                      @value = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @value =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @value = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @value.push String.from_json(_item)
                        else
                          @value.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @value = _oa
                    end
                  end
                end

                # constructs a RestUUID from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Mapping

              # (no documentation provided)
              class RestMappingSetVersionBase

                # The primary name of this map set.
                attr_accessor :name
                # The (optional) inverse name of this map set.  Used when a map set is of the pattern:
                # ingredient-of &lt;--&gt; has-ingredient
                attr_accessor :inverseName
                # The description of this map set
                attr_accessor :description
                # The (optional) purpose of this map set - or extended description of this map set.
                attr_accessor :purpose

                # the json hash for this RestMappingSetVersionBase
                def to_jaxb_json_hash
                  _h = {}
                  _h['name'] = name.to_jaxb_json_hash unless name.nil?
                  _h['inverseName'] = inverseName.to_jaxb_json_hash unless inverseName.nil?
                  _h['description'] = description.to_jaxb_json_hash unless description.nil?
                  _h['purpose'] = purpose.to_jaxb_json_hash unless purpose.nil?
                  return _h
                end

                # the json (string form) for this RestMappingSetVersionBase
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestMappingSetVersionBase with a json hash
                def init_jaxb_json_hash(_o)
                  if !_o['name'].nil?
                    _oa = _o['name']
                    if(_oa.is_a? Hash)
                      @name = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @name =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @name = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @name.push String.from_json(_item)
                        else
                          @name.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @name = _oa
                    end
                  end
                  if !_o['inverseName'].nil?
                    _oa = _o['inverseName']
                    if(_oa.is_a? Hash)
                      @inverseName = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @inverseName =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @inverseName = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @inverseName.push String.from_json(_item)
                        else
                          @inverseName.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @inverseName = _oa
                    end
                  end
                  if !_o['description'].nil?
                    _oa = _o['description']
                    if(_oa.is_a? Hash)
                      @description = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @description =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @description = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @description.push String.from_json(_item)
                        else
                          @description.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @description = _oa
                    end
                  end
                  if !_o['purpose'].nil?
                    _oa = _o['purpose']
                    if(_oa.is_a? Hash)
                      @purpose = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @purpose =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @purpose = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @purpose.push String.from_json(_item)
                        else
                          @purpose.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @purpose = _oa
                    end
                  end
                end

                # constructs a RestMappingSetVersionBase from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              module DataTypes

                # (no documentation provided)
                class RestDynamicSememeByteArray < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData


                  # the json hash for this RestDynamicSememeByteArray
                  def to_jaxb_json_hash
                    _h = super
                    return _h
                  end

                  #initializes this RestDynamicSememeByteArray with a json hash
                  def init_jaxb_json_hash(_o)
                    super _o
                  end

                  # constructs a RestDynamicSememeByteArray from a (parsed) JSON hash
                  def self.from_json(o)
                    if o.nil?
                      return nil
                    else
                      inst = new
                      inst.init_jaxb_json_hash o
                      return inst
                    end
                  end
                end

              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestExternalizableObjectType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestExternalizableObjectType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestExternalizableObjectType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    _oa = _o['all']
                    if(_oa.is_a? Hash)
                      @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestExternalizableObjectType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @all = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestExternalizableObjectType.from_json(_item)
                        else
                          @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @all = _oa
                    end
                  end
                end

                # constructs a RestExternalizableObjectType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              module DataTypes

                # (no documentation provided)
                class RestDynamicSememeString < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData


                  # the json hash for this RestDynamicSememeString
                  def to_jaxb_json_hash
                    _h = super
                    return _h
                  end

                  #initializes this RestDynamicSememeString with a json hash
                  def init_jaxb_json_hash(_o)
                    super _o
                  end

                  # constructs a RestDynamicSememeString from a (parsed) JSON hash
                  def self.from_json(o)
                    if o.nil?
                      return nil
                    else
                      inst = new
                      inst.init_jaxb_json_hash o
                      return inst
                    end
                  end
                end

              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Mapping

              # (no documentation provided)
              class RestMappingSetVersion < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetVersionBase

                # The data that was not expanded as part of this call (but can be)
                # TODO populate expandables
                attr_accessor :expandables
                # The concept sequence of the concept that represents this mapping set
                attr_accessor :conceptSequence
                # The identifier data of the concept that represents this mapping set
                attr_accessor :identifiers
                # The StampedVersion details for this map set definition
                attr_accessor :mappingSetStamp
                # The (optional) extended fields which carry additional information about this map set definition.
                attr_accessor :mapSetExtendedFields
                # The fields that are declared for each map item instance that is created using this map set definition.
                attr_accessor :mapItemFieldsDefinition
                # The (optionally) populated comments attached to this map set.  This field is only populated when requested via an &#39;expand&#39; parameter.
                attr_accessor :comments

                # the json hash for this RestMappingSetVersion
                def to_jaxb_json_hash
                  _h = super
                  _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
                  _h['conceptSequence'] = conceptSequence.to_jaxb_json_hash unless conceptSequence.nil?
                  _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
                  _h['mappingSetStamp'] = mappingSetStamp.to_jaxb_json_hash unless mappingSetStamp.nil?
                  if !mapSetExtendedFields.nil?
                    _ha = Array.new
                    mapSetExtendedFields.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['mapSetExtendedFields'] = _ha
                  end
                  if !mapItemFieldsDefinition.nil?
                    _ha = Array.new
                    mapItemFieldsDefinition.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['mapItemFieldsDefinition'] = _ha
                  end
                  if !comments.nil?
                    _ha = Array.new
                    comments.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['comments'] = _ha
                  end
                  return _h
                end

                #initializes this RestMappingSetVersion with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['expandables'].nil?
                    _oa = _o['expandables']
                    if(_oa.is_a? Hash)
                      @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @expandables = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                        else
                          @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @expandables = _oa
                    end
                  end
                  if !_o['conceptSequence'].nil?
                    _oa = _o['conceptSequence']
                    if(_oa.is_a? Hash)
                      @conceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @conceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @conceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @conceptSequence.push Fixnum.from_json(_item)
                        else
                          @conceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @conceptSequence = _oa
                    end
                  end
                  if !_o['identifiers'].nil?
                    _oa = _o['identifiers']
                    if(_oa.is_a? Hash)
                      @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @identifiers = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                        else
                          @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @identifiers = _oa
                    end
                  end
                  if !_o['mappingSetStamp'].nil?
                    _oa = _o['mappingSetStamp']
                    if(_oa.is_a? Hash)
                      @mappingSetStamp = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @mappingSetStamp =  Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @mappingSetStamp = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @mappingSetStamp.push Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_item)
                        else
                          @mappingSetStamp.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @mappingSetStamp = _oa
                    end
                  end
                  if !_o['mapSetExtendedFields'].nil?
                    _oa = _o['mapSetExtendedFields']
                    if(_oa.is_a? Hash)
                      @mapSetExtendedFields = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @mapSetExtendedFields =  Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValue.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @mapSetExtendedFields = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @mapSetExtendedFields.push Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValue.from_json(_item)
                        else
                          @mapSetExtendedFields.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @mapSetExtendedFields = _oa
                    end
                  end
                  if !_o['mapItemFieldsDefinition'].nil?
                    _oa = _o['mapItemFieldsDefinition']
                    if(_oa.is_a? Hash)
                      @mapItemFieldsDefinition = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @mapItemFieldsDefinition =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfo.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @mapItemFieldsDefinition = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @mapItemFieldsDefinition.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfo.from_json(_item)
                        else
                          @mapItemFieldsDefinition.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @mapItemFieldsDefinition = _oa
                    end
                  end
                  if !_o['comments'].nil?
                    _oa = _o['comments']
                    if(_oa.is_a? Hash)
                      @comments = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @comments =  Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @comments = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @comments.push Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersion.from_json(_item)
                        else
                          @comments.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @comments = _oa
                    end
                  end
                end

                # constructs a RestMappingSetVersion from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestTypedConnectorNode < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode

                # RestTypedConnectorNode contains an int connectorTypeConceptSequence identifying a connector type concept
                attr_accessor :connectorTypeConceptSequence
                # Optionally-populated connectorTypeConceptVersion
                attr_accessor :connectorTypeConceptVersion
                # RestTypedConnectorNode contains a String connectorTypeConceptDescription describing a connector type concept
                attr_accessor :connectorTypeConceptDescription

                # the json hash for this RestTypedConnectorNode
                def to_jaxb_json_hash
                  _h = super
                  _h['connectorTypeConceptSequence'] = connectorTypeConceptSequence.to_jaxb_json_hash unless connectorTypeConceptSequence.nil?
                  _h['connectorTypeConceptVersion'] = connectorTypeConceptVersion.to_jaxb_json_hash unless connectorTypeConceptVersion.nil?
                  _h['connectorTypeConceptDescription'] = connectorTypeConceptDescription.to_jaxb_json_hash unless connectorTypeConceptDescription.nil?
                  return _h
                end

                #initializes this RestTypedConnectorNode with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['connectorTypeConceptSequence'].nil?
                    _oa = _o['connectorTypeConceptSequence']
                    if(_oa.is_a? Hash)
                      @connectorTypeConceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @connectorTypeConceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @connectorTypeConceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @connectorTypeConceptSequence.push Fixnum.from_json(_item)
                        else
                          @connectorTypeConceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @connectorTypeConceptSequence = _oa
                    end
                  end
                  if !_o['connectorTypeConceptVersion'].nil?
                    _oa = _o['connectorTypeConceptVersion']
                    if(_oa.is_a? Hash)
                      @connectorTypeConceptVersion = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @connectorTypeConceptVersion =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @connectorTypeConceptVersion = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @connectorTypeConceptVersion.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_item)
                        else
                          @connectorTypeConceptVersion.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @connectorTypeConceptVersion = _oa
                    end
                  end
                  if !_o['connectorTypeConceptDescription'].nil?
                    _oa = _o['connectorTypeConceptDescription']
                    if(_oa.is_a? Hash)
                      @connectorTypeConceptDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @connectorTypeConceptDescription =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @connectorTypeConceptDescription = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @connectorTypeConceptDescription.push String.from_json(_item)
                        else
                          @connectorTypeConceptDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @connectorTypeConceptDescription = _oa
                    end
                  end
                end

                # constructs a RestTypedConnectorNode from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestObjectChronologyType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestObjectChronologyType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestObjectChronologyType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    _oa = _o['all']
                    if(_oa.is_a? Hash)
                      @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @all = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_item)
                        else
                          @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @all = _oa
                    end
                  end
                end

                # constructs a RestObjectChronologyType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestConcreteDomainOperatorsType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestConcreteDomainOperatorsType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestConcreteDomainOperatorsType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    _oa = _o['all']
                    if(_oa.is_a? Hash)
                      @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestConcreteDomainOperatorsType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @all = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestConcreteDomainOperatorsType.from_json(_item)
                        else
                          @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @all = _oa
                    end
                  end
                end

                # constructs a RestConcreteDomainOperatorsType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestLiteralNodeInstant < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode

                # RestLiteralNodeInstant contains a literal Instant value, literalValue
                attr_accessor :literalValue

                # the json hash for this RestLiteralNodeInstant
                def to_jaxb_json_hash
                  _h = super
                  _h['literalValue'] = literalValue.to_jaxb_json_hash unless literalValue.nil?
                  return _h
                end

                #initializes this RestLiteralNodeInstant with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['literalValue'].nil?
                    _oa = _o['literalValue']
                    if(_oa.is_a? Hash)
                      @literalValue = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @literalValue =  java.time::Instant.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @literalValue = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @literalValue.push java.time::Instant.from_json(_item)
                        else
                          @literalValue.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @literalValue = _oa
                    end
                  end
                end

                # constructs a RestLiteralNodeInstant from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              module DataTypes

                # (no documentation provided)
                class RestDynamicSememeInteger < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData


                  # the json hash for this RestDynamicSememeInteger
                  def to_jaxb_json_hash
                    _h = super
                    return _h
                  end

                  #initializes this RestDynamicSememeInteger with a json hash
                  def init_jaxb_json_hash(_o)
                    super _o
                  end

                  # constructs a RestDynamicSememeInteger from a (parsed) JSON hash
                  def self.from_json(o)
                    if o.nil?
                      return nil
                    else
                      inst = new
                      inst.init_jaxb_json_hash o
                      return inst
                    end
                  end
                end

              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestStampPrecedenceType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestStampPrecedenceType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestStampPrecedenceType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    _oa = _o['all']
                    if(_oa.is_a? Hash)
                      @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStampPrecedenceType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @all = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStampPrecedenceType.from_json(_item)
                        else
                          @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @all = _oa
                    end
                  end
                end

                # constructs a RestStampPrecedenceType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestStateType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestStateType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestStateType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    _oa = _o['all']
                    if(_oa.is_a? Hash)
                      @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStateType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @all = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestStateType.from_json(_item)
                        else
                          @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @all = _oa
                    end
                  end
                end

                # constructs a RestStateType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Comment

              # (no documentation provided)
              class RestCommentVersionBaseCreate < Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersionBase

                # The identifier of the component that is being commented on.  Could be a concept or a sememe
                attr_accessor :commentedItem

                # the json hash for this RestCommentVersionBaseCreate
                def to_jaxb_json_hash
                  _h = super
                  _h['commentedItem'] = commentedItem.to_jaxb_json_hash unless commentedItem.nil?
                  return _h
                end

                #initializes this RestCommentVersionBaseCreate with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['commentedItem'].nil?
                    _oa = _o['commentedItem']
                    if(_oa.is_a? Hash)
                      @commentedItem = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @commentedItem =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @commentedItem = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @commentedItem.push Fixnum.from_json(_item)
                        else
                          @commentedItem.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @commentedItem = _oa
                    end
                  end
                end

                # constructs a RestCommentVersionBaseCreate from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestWorkflowProcessStatusType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # Displayable text
                attr_accessor :text
                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestWorkflowProcessStatusType
                def to_jaxb_json_hash
                  _h = super
                  _h['text'] = text.to_jaxb_json_hash unless text.nil?
                  if !all.nil?
                    _ha = Array.new
                    all.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestWorkflowProcessStatusType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['text'].nil?
                    _oa = _o['text']
                    if(_oa.is_a? Hash)
                      @text = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @text =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @text = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @text.push String.from_json(_item)
                        else
                          @text.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @text = _oa
                    end
                  end
                  if !_o['all'].nil?
                    _oa = _o['all']
                    if(_oa.is_a? Hash)
                      @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestWorkflowProcessStatusType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @all = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestWorkflowProcessStatusType.from_json(_item)
                        else
                          @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @all = _oa
                    end
                  end
                end

                # constructs a RestWorkflowProcessStatusType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Mapping

              # (no documentation provided)
              class RestMappingSetVersionBaseCreate < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetVersionBase

                # The (optional) extended fields which carry additional information about this map set definition.
                attr_accessor :mapSetExtendedFields
                # The (optional) extended fields that are declared for each map item instance that is created using this map set definition.
                attr_accessor :mapItemExtendedFieldsDefinition

                # the json hash for this RestMappingSetVersionBaseCreate
                def to_jaxb_json_hash
                  _h = super
                  if !mapSetExtendedFields.nil?
                    _ha = Array.new
                    mapSetExtendedFields.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['mapSetExtendedFields'] = _ha
                  end
                  if !mapItemExtendedFieldsDefinition.nil?
                    _ha = Array.new
                    mapItemExtendedFieldsDefinition.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['mapItemExtendedFieldsDefinition'] = _ha
                  end
                  return _h
                end

                #initializes this RestMappingSetVersionBaseCreate with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['mapSetExtendedFields'].nil?
                    _oa = _o['mapSetExtendedFields']
                    if(_oa.is_a? Hash)
                      @mapSetExtendedFields = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @mapSetExtendedFields =  Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValueBaseCreate.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @mapSetExtendedFields = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @mapSetExtendedFields.push Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValueBaseCreate.from_json(_item)
                        else
                          @mapSetExtendedFields.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @mapSetExtendedFields = _oa
                    end
                  end
                  if !_o['mapItemExtendedFieldsDefinition'].nil?
                    _oa = _o['mapItemExtendedFieldsDefinition']
                    if(_oa.is_a? Hash)
                      @mapItemExtendedFieldsDefinition = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @mapItemExtendedFieldsDefinition =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfoCreate.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @mapItemExtendedFieldsDefinition = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @mapItemExtendedFieldsDefinition.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfoCreate.from_json(_item)
                        else
                          @mapItemExtendedFieldsDefinition.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @mapItemExtendedFieldsDefinition = _oa
                    end
                  end
                end

                # constructs a RestMappingSetVersionBaseCreate from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Workflow

              # (no documentation provided)
              class RestWorkflowProcess < Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowProcessBaseCreate

                # The workflow process identifier
                attr_accessor :id
                # The time workflow process created
                attr_accessor :timeCreated
                # The time workflow process launched
                attr_accessor :timeLaunched
                # The time workflow process cancelled or concluded
                attr_accessor :timeCancelledOrConcluded
                # The defining workflow process status
                attr_accessor :processStatus
                # The stamp sequences by component nid associated with the workflow process
                attr_accessor :componentNidToStampsMap

                # the json hash for this RestWorkflowProcess
                def to_jaxb_json_hash
                  _h = super
                  _h['id'] = id.to_jaxb_json_hash unless id.nil?
                  _h['timeCreated'] = timeCreated.to_jaxb_json_hash unless timeCreated.nil?
                  _h['timeLaunched'] = timeLaunched.to_jaxb_json_hash unless timeLaunched.nil?
                  _h['timeCancelledOrConcluded'] = timeCancelledOrConcluded.to_jaxb_json_hash unless timeCancelledOrConcluded.nil?
                  _h['processStatus'] = processStatus.to_jaxb_json_hash unless processStatus.nil?
                  if !componentNidToStampsMap.nil?
                    _ha = Array.new
                    componentNidToStampsMap.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['componentNidToStampsMap'] = _ha
                  end
                  return _h
                end

                #initializes this RestWorkflowProcess with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['id'].nil?
                    _oa = _o['id']
                    if(_oa.is_a? Hash)
                      @id = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @id =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @id = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @id.push String.from_json(_item)
                        else
                          @id.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @id = _oa
                    end
                  end
                  if !_o['timeCreated'].nil?
                    _oa = _o['timeCreated']
                    if(_oa.is_a? Hash)
                      @timeCreated = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @timeCreated =  Bignum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @timeCreated = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @timeCreated.push Bignum.from_json(_item)
                        else
                          @timeCreated.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @timeCreated = _oa
                    end
                  end
                  if !_o['timeLaunched'].nil?
                    _oa = _o['timeLaunched']
                    if(_oa.is_a? Hash)
                      @timeLaunched = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @timeLaunched =  Bignum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @timeLaunched = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @timeLaunched.push Bignum.from_json(_item)
                        else
                          @timeLaunched.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @timeLaunched = _oa
                    end
                  end
                  if !_o['timeCancelledOrConcluded'].nil?
                    _oa = _o['timeCancelledOrConcluded']
                    if(_oa.is_a? Hash)
                      @timeCancelledOrConcluded = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @timeCancelledOrConcluded =  Bignum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @timeCancelledOrConcluded = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @timeCancelledOrConcluded.push Bignum.from_json(_item)
                        else
                          @timeCancelledOrConcluded.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @timeCancelledOrConcluded = _oa
                    end
                  end
                  if !_o['processStatus'].nil?
                    _oa = _o['processStatus']
                    if(_oa.is_a? Hash)
                      @processStatus = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @processStatus =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestWorkflowProcessStatusType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @processStatus = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @processStatus.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestWorkflowProcessStatusType.from_json(_item)
                        else
                          @processStatus.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @processStatus = _oa
                    end
                  end
                  if !_o['componentNidToStampsMap'].nil?
                    _oa = _o['componentNidToStampsMap']
                    if(_oa.is_a? Hash)
                      @componentNidToStampsMap = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @componentNidToStampsMap =  Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowComponentNidToStampsMapEntry.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @componentNidToStampsMap = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @componentNidToStampsMap.push Gov::Vha::Isaac::Rest::Api1::Data::Workflow::RestWorkflowComponentNidToStampsMapEntry.from_json(_item)
                        else
                          @componentNidToStampsMap.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @componentNidToStampsMap = _oa
                    end
                  end
                end

                # constructs a RestWorkflowProcess from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestLiteralNodeFloat < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode

                # RestLiteralNodeFloat contains a literal float value, literalValue
                attr_accessor :literalValue

                # the json hash for this RestLiteralNodeFloat
                def to_jaxb_json_hash
                  _h = super
                  _h['literalValue'] = literalValue.to_jaxb_json_hash unless literalValue.nil?
                  return _h
                end

                #initializes this RestLiteralNodeFloat with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['literalValue'].nil?
                    _oa = _o['literalValue']
                    if(_oa.is_a? Hash)
                      @literalValue = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @literalValue =  Float.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @literalValue = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @literalValue.push Float.from_json(_item)
                        else
                          @literalValue.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @literalValue = _oa
                    end
                  end
                end

                # constructs a RestLiteralNodeFloat from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestSememeType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestSememeType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestSememeType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    _oa = _o['all']
                    if(_oa.is_a? Hash)
                      @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSememeType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @all = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSememeType.from_json(_item)
                        else
                          @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @all = _oa
                    end
                  end
                end

                # constructs a RestSememeType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestLiteralNodeBoolean < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode

                # RestLiteralNodeBoolean contains a literal boolean value, literalValue
                attr_accessor :literalValue

                # the json hash for this RestLiteralNodeBoolean
                def to_jaxb_json_hash
                  _h = super
                  _h['literalValue'] = literalValue.to_jaxb_json_hash unless literalValue.nil?
                  return _h
                end

                #initializes this RestLiteralNodeBoolean with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['literalValue'].nil?
                    _oa = _o['literalValue']
                    if(_oa.is_a? Hash)
                      @literalValue = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @literalValue =  Boolean.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @literalValue = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @literalValue.push Boolean.from_json(_item)
                        else
                          @literalValue.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @literalValue = _oa
                    end
                  end
                end

                # constructs a RestLiteralNodeBoolean from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              module DataTypes

                # (no documentation provided)
                class RestDynamicSememeArray < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData


                  # the json hash for this RestDynamicSememeArray
                  def to_jaxb_json_hash
                    _h = super
                    return _h
                  end

                  #initializes this RestDynamicSememeArray with a json hash
                  def init_jaxb_json_hash(_o)
                    super _o
                  end

                  # constructs a RestDynamicSememeArray from a (parsed) JSON hash
                  def self.from_json(o)
                    if o.nil?
                      return nil
                    else
                      inst = new
                      inst.init_jaxb_json_hash o
                      return inst
                    end
                  end
                end

              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestNodeSemanticType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestNodeSemanticType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestNodeSemanticType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    _oa = _o['all']
                    if(_oa.is_a? Hash)
                      @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestNodeSemanticType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @all = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestNodeSemanticType.from_json(_item)
                        else
                          @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @all = _oa
                    end
                  end
                end

                # constructs a RestNodeSemanticType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestConceptNode < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode

                # The int sequence of the concept referred to by this REST logic graph node
                attr_accessor :conceptSequence
                # Optionally-expandable RestConceptVersion corresponding to RestConceptNode concept
                attr_accessor :conceptVersion
                # A boolean indicating whether the concept referred to by this RestConceptVersion is defined rather than primitive
                attr_accessor :isConceptDefined
                # The String text description of the concept referred to by this REST logic graph node. It is included as a convenience, as it may be retrieved based on the concept sequence.
                attr_accessor :conceptDescription

                # the json hash for this RestConceptNode
                def to_jaxb_json_hash
                  _h = super
                  _h['conceptSequence'] = conceptSequence.to_jaxb_json_hash unless conceptSequence.nil?
                  _h['conceptVersion'] = conceptVersion.to_jaxb_json_hash unless conceptVersion.nil?
                  _h['isConceptDefined'] = isConceptDefined.to_jaxb_json_hash unless isConceptDefined.nil?
                  _h['conceptDescription'] = conceptDescription.to_jaxb_json_hash unless conceptDescription.nil?
                  return _h
                end

                #initializes this RestConceptNode with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['conceptSequence'].nil?
                    _oa = _o['conceptSequence']
                    if(_oa.is_a? Hash)
                      @conceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @conceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @conceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @conceptSequence.push Fixnum.from_json(_item)
                        else
                          @conceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @conceptSequence = _oa
                    end
                  end
                  if !_o['conceptVersion'].nil?
                    _oa = _o['conceptVersion']
                    if(_oa.is_a? Hash)
                      @conceptVersion = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @conceptVersion =  Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @conceptVersion = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @conceptVersion.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_item)
                        else
                          @conceptVersion.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @conceptVersion = _oa
                    end
                  end
                  if !_o['isConceptDefined'].nil?
                    _oa = _o['isConceptDefined']
                    if(_oa.is_a? Hash)
                      @isConceptDefined = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @isConceptDefined =  Boolean.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @isConceptDefined = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @isConceptDefined.push Boolean.from_json(_item)
                        else
                          @isConceptDefined.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @isConceptDefined = _oa
                    end
                  end
                  if !_o['conceptDescription'].nil?
                    _oa = _o['conceptDescription']
                    if(_oa.is_a? Hash)
                      @conceptDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @conceptDescription =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @conceptDescription = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @conceptDescription.push String.from_json(_item)
                        else
                          @conceptDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @conceptDescription = _oa
                    end
                  end
                end

                # constructs a RestConceptNode from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestDynamicSememeTypedData < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData

                # The type of the object that is referenced by the data.  This would tell you if the (nid, sequence or UUID) represents a concept or a sememe (or unknown).
                # Especially in the case of a RestDynamicSememeSequence, the value may come back as unknown - the caller will have to refer to the documentation of the sememe
                # to determine the actual type of the data stored here in those cases.
                attr_accessor :dataObjectType
                # If the dataObjectType represents is a concept, then this carries the &quot;best&quot; description for that concept.  This is selected based on the
                # attributes within the session for  stamp and language coordinates - or - if none present - the server default.  This is not populated if the
                # dataObjectType is not a concept type.
                # Only populated when the expand parameter &#39;referencedDetails&#39; is passed.
                attr_accessor :conceptDescription

                # the json hash for this RestDynamicSememeTypedData
                def to_jaxb_json_hash
                  _h = super
                  _h['dataObjectType'] = dataObjectType.to_jaxb_json_hash unless dataObjectType.nil?
                  _h['conceptDescription'] = conceptDescription.to_jaxb_json_hash unless conceptDescription.nil?
                  return _h
                end

                #initializes this RestDynamicSememeTypedData with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['dataObjectType'].nil?
                    _oa = _o['dataObjectType']
                    if(_oa.is_a? Hash)
                      @dataObjectType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @dataObjectType =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @dataObjectType = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @dataObjectType.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_item)
                        else
                          @dataObjectType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @dataObjectType = _oa
                    end
                  end
                  if !_o['conceptDescription'].nil?
                    _oa = _o['conceptDescription']
                    if(_oa.is_a? Hash)
                      @conceptDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @conceptDescription =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @conceptDescription = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @conceptDescription.push String.from_json(_item)
                        else
                          @conceptDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @conceptDescription = _oa
                    end
                  end
                end

                # constructs a RestDynamicSememeTypedData from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestLiteralNodeInteger < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode

                # RestLiteralNodeInteger contains a literal int value, literalValue
                attr_accessor :literalValue

                # the json hash for this RestLiteralNodeInteger
                def to_jaxb_json_hash
                  _h = super
                  _h['literalValue'] = literalValue.to_jaxb_json_hash unless literalValue.nil?
                  return _h
                end

                #initializes this RestLiteralNodeInteger with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['literalValue'].nil?
                    _oa = _o['literalValue']
                    if(_oa.is_a? Hash)
                      @literalValue = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @literalValue =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @literalValue = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @literalValue.push Fixnum.from_json(_item)
                        else
                          @literalValue.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @literalValue = _oa
                    end
                  end
                end

                # constructs a RestLiteralNodeInteger from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestSememeLogicGraphVersion < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion

                # The String text of the description of the associated concept
                attr_accessor :referencedConceptDescription
                # A boolean indicating whether the concept referred to by this
                # RestSememeLogicGraphVersion is defined rather than primitive
                attr_accessor :isReferencedConceptDefined
                # The root node of the logical expression tree associated with the concept
                attr_accessor :rootLogicNode

                # the json hash for this RestSememeLogicGraphVersion
                def to_jaxb_json_hash
                  _h = super
                  _h['referencedConceptDescription'] = referencedConceptDescription.to_jaxb_json_hash unless referencedConceptDescription.nil?
                  _h['isReferencedConceptDefined'] = isReferencedConceptDefined.to_jaxb_json_hash unless isReferencedConceptDefined.nil?
                  _h['rootLogicNode'] = rootLogicNode.to_jaxb_json_hash unless rootLogicNode.nil?
                  return _h
                end

                #initializes this RestSememeLogicGraphVersion with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['referencedConceptDescription'].nil?
                    _oa = _o['referencedConceptDescription']
                    if(_oa.is_a? Hash)
                      @referencedConceptDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @referencedConceptDescription =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @referencedConceptDescription = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @referencedConceptDescription.push String.from_json(_item)
                        else
                          @referencedConceptDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @referencedConceptDescription = _oa
                    end
                  end
                  if !_o['isReferencedConceptDefined'].nil?
                    _oa = _o['isReferencedConceptDefined']
                    if(_oa.is_a? Hash)
                      @isReferencedConceptDefined = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @isReferencedConceptDefined =  Boolean.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @isReferencedConceptDefined = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @isReferencedConceptDefined.push Boolean.from_json(_item)
                        else
                          @isReferencedConceptDefined.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @isReferencedConceptDefined = _oa
                    end
                  end
                  if !_o['rootLogicNode'].nil?
                    _oa = _o['rootLogicNode']
                    if(_oa.is_a? Hash)
                      @rootLogicNode = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @rootLogicNode =  Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @rootLogicNode = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @rootLogicNode.push Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode.from_json(_item)
                        else
                          @rootLogicNode.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @rootLogicNode = _oa
                    end
                  end
                end

                # constructs a RestSememeLogicGraphVersion from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              module DataTypes

                # (no documentation provided)
                class RestDynamicSememeBoolean < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData


                  # the json hash for this RestDynamicSememeBoolean
                  def to_jaxb_json_hash
                    _h = super
                    return _h
                  end

                  #initializes this RestDynamicSememeBoolean with a json hash
                  def init_jaxb_json_hash(_o)
                    super _o
                  end

                  # constructs a RestDynamicSememeBoolean from a (parsed) JSON hash
                  def self.from_json(o)
                    if o.nil?
                      return nil
                    else
                      inst = new
                      inst.init_jaxb_json_hash o
                      return inst
                    end
                  end
                end

              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestSupportedIdType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestSupportedIdType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestSupportedIdType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    _oa = _o['all']
                    if(_oa.is_a? Hash)
                      @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSupportedIdType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @all = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSupportedIdType.from_json(_item)
                        else
                          @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @all = _oa
                    end
                  end
                end

                # constructs a RestSupportedIdType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestSememeDescriptionVersion < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion

                # The concept sequence of the concept that represents the case significance flag on the description .
                # This should be description case sensitive, description not case sensitive or description initial character sensitive
                attr_accessor :caseSignificanceConceptSequence
                # The concept sequence of the concept that represents the language of the description (note, this is NOT
                # the dialect)
                attr_accessor :languageConceptSequence
                # The text of the description
                attr_accessor :text
                # The concept sequence of the concept that represents the type of the description.
                # This should be FSN, Synonym, or Definition.
                attr_accessor :descriptionTypeConceptSequence
                # The optional concept sequence of the concept that represents the extended type of the description.
                # This should be a MetaData.DYNAMIC_SEMEME_EXTENDED_DESCRIPTION_TYPE.
                attr_accessor :descriptionExtendedTypeConceptSequence
                # The dialects attached to this sememe.  Not populated by default, include expand=nestedSememes to expand this.
                attr_accessor :dialects

                # the json hash for this RestSememeDescriptionVersion
                def to_jaxb_json_hash
                  _h = super
                  _h['caseSignificanceConceptSequence'] = caseSignificanceConceptSequence.to_jaxb_json_hash unless caseSignificanceConceptSequence.nil?
                  _h['languageConceptSequence'] = languageConceptSequence.to_jaxb_json_hash unless languageConceptSequence.nil?
                  _h['text'] = text.to_jaxb_json_hash unless text.nil?
                  _h['descriptionTypeConceptSequence'] = descriptionTypeConceptSequence.to_jaxb_json_hash unless descriptionTypeConceptSequence.nil?
                  _h['descriptionExtendedTypeConceptSequence'] = descriptionExtendedTypeConceptSequence.to_jaxb_json_hash unless descriptionExtendedTypeConceptSequence.nil?
                  if !dialects.nil?
                    _ha = Array.new
                    dialects.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['dialects'] = _ha
                  end
                  return _h
                end

                #initializes this RestSememeDescriptionVersion with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['caseSignificanceConceptSequence'].nil?
                    _oa = _o['caseSignificanceConceptSequence']
                    if(_oa.is_a? Hash)
                      @caseSignificanceConceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @caseSignificanceConceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @caseSignificanceConceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @caseSignificanceConceptSequence.push Fixnum.from_json(_item)
                        else
                          @caseSignificanceConceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @caseSignificanceConceptSequence = _oa
                    end
                  end
                  if !_o['languageConceptSequence'].nil?
                    _oa = _o['languageConceptSequence']
                    if(_oa.is_a? Hash)
                      @languageConceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @languageConceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @languageConceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @languageConceptSequence.push Fixnum.from_json(_item)
                        else
                          @languageConceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @languageConceptSequence = _oa
                    end
                  end
                  if !_o['text'].nil?
                    _oa = _o['text']
                    if(_oa.is_a? Hash)
                      @text = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @text =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @text = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @text.push String.from_json(_item)
                        else
                          @text.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @text = _oa
                    end
                  end
                  if !_o['descriptionTypeConceptSequence'].nil?
                    _oa = _o['descriptionTypeConceptSequence']
                    if(_oa.is_a? Hash)
                      @descriptionTypeConceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @descriptionTypeConceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @descriptionTypeConceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @descriptionTypeConceptSequence.push Fixnum.from_json(_item)
                        else
                          @descriptionTypeConceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @descriptionTypeConceptSequence = _oa
                    end
                  end
                  if !_o['descriptionExtendedTypeConceptSequence'].nil?
                    _oa = _o['descriptionExtendedTypeConceptSequence']
                    if(_oa.is_a? Hash)
                      @descriptionExtendedTypeConceptSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @descriptionExtendedTypeConceptSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @descriptionExtendedTypeConceptSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @descriptionExtendedTypeConceptSequence.push Fixnum.from_json(_item)
                        else
                          @descriptionExtendedTypeConceptSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @descriptionExtendedTypeConceptSequence = _oa
                    end
                  end
                  if !_o['dialects'].nil?
                    _oa = _o['dialects']
                    if(_oa.is_a? Hash)
                      @dialects = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @dialects =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @dialects = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @dialects.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeVersion.from_json(_item)
                        else
                          @dialects.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @dialects = _oa
                    end
                  end
                end

                # constructs a RestSememeDescriptionVersion from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              module DataTypes

                # (no documentation provided)
                class RestDynamicSememeLong < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData


                  # the json hash for this RestDynamicSememeLong
                  def to_jaxb_json_hash
                    _h = super
                    return _h
                  end

                  #initializes this RestDynamicSememeLong with a json hash
                  def init_jaxb_json_hash(_o)
                    super _o
                  end

                  # constructs a RestDynamicSememeLong from a (parsed) JSON hash
                  def self.from_json(o)
                    if o.nil?
                      return nil
                    else
                      inst = new
                      inst.init_jaxb_json_hash o
                      return inst
                    end
                  end
                end

              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestUntypedConnectorNode < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode


                # the json hash for this RestUntypedConnectorNode
                def to_jaxb_json_hash
                  _h = super
                  return _h
                end

                #initializes this RestUntypedConnectorNode with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                end

                # constructs a RestUntypedConnectorNode from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              module DataTypes

                # (no documentation provided)
                class RestDynamicSememeDouble < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData


                  # the json hash for this RestDynamicSememeDouble
                  def to_jaxb_json_hash
                    _h = super
                    return _h
                  end

                  #initializes this RestDynamicSememeDouble with a json hash
                  def init_jaxb_json_hash(_o)
                    super _o
                  end

                  # constructs a RestDynamicSememeDouble from a (parsed) JSON hash
                  def self.from_json(o)
                    if o.nil?
                      return nil
                    else
                      inst = new
                      inst.init_jaxb_json_hash o
                      return inst
                    end
                  end
                end

              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Mapping

              # (no documentation provided)
              class RestMappingSetExtensionValueBaseCreate < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValueBase

                # The concept that describes the purpose of this extended field on a map set definition.  The descriptions from this concept
                # will be used as the label of the extension.  On create, this accepts a nid or a sequence.  On read, it returns a concept sequence.
                attr_accessor :extensionNameConcept

                # the json hash for this RestMappingSetExtensionValueBaseCreate
                def to_jaxb_json_hash
                  _h = super
                  _h['extensionNameConcept'] = extensionNameConcept.to_jaxb_json_hash unless extensionNameConcept.nil?
                  return _h
                end

                #initializes this RestMappingSetExtensionValueBaseCreate with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['extensionNameConcept'].nil?
                    _oa = _o['extensionNameConcept']
                    if(_oa.is_a? Hash)
                      @extensionNameConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @extensionNameConcept =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @extensionNameConcept = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @extensionNameConcept.push Fixnum.from_json(_item)
                        else
                          @extensionNameConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @extensionNameConcept = _oa
                    end
                  end
                end

                # constructs a RestMappingSetExtensionValueBaseCreate from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Mapping

              # (no documentation provided)
              class RestMappingItemVersionBaseCreate < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingItemVersionBase

                # The concept sequence that identifies the map set that this entry belongs to
                attr_accessor :mapSetConcept
                # The source concept sequence being mapped by this map item
                attr_accessor :sourceConcept

                # the json hash for this RestMappingItemVersionBaseCreate
                def to_jaxb_json_hash
                  _h = super
                  _h['mapSetConcept'] = mapSetConcept.to_jaxb_json_hash unless mapSetConcept.nil?
                  _h['sourceConcept'] = sourceConcept.to_jaxb_json_hash unless sourceConcept.nil?
                  return _h
                end

                #initializes this RestMappingItemVersionBaseCreate with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['mapSetConcept'].nil?
                    _oa = _o['mapSetConcept']
                    if(_oa.is_a? Hash)
                      @mapSetConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @mapSetConcept =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @mapSetConcept = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @mapSetConcept.push Fixnum.from_json(_item)
                        else
                          @mapSetConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @mapSetConcept = _oa
                    end
                  end
                  if !_o['sourceConcept'].nil?
                    _oa = _o['sourceConcept']
                    if(_oa.is_a? Hash)
                      @sourceConcept = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @sourceConcept =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @sourceConcept = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @sourceConcept.push Fixnum.from_json(_item)
                        else
                          @sourceConcept.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @sourceConcept = _oa
                    end
                  end
                end

                # constructs a RestMappingItemVersionBaseCreate from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestLiteralNodeString < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode

                # RestLiteralNodeString contains a literal String value, literalValue
                attr_accessor :literalValue

                # the json hash for this RestLiteralNodeString
                def to_jaxb_json_hash
                  _h = super
                  _h['literalValue'] = literalValue.to_jaxb_json_hash unless literalValue.nil?
                  return _h
                end

                #initializes this RestLiteralNodeString with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['literalValue'].nil?
                    _oa = _o['literalValue']
                    if(_oa.is_a? Hash)
                      @literalValue = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @literalValue =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @literalValue = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @literalValue.push String.from_json(_item)
                        else
                          @literalValue.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @literalValue = _oa
                    end
                  end
                end

                # constructs a RestLiteralNodeString from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              module DataTypes

                # (no documentation provided)
                class RestDynamicSememeFloat < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData


                  # the json hash for this RestDynamicSememeFloat
                  def to_jaxb_json_hash
                    _h = super
                    return _h
                  end

                  #initializes this RestDynamicSememeFloat with a json hash
                  def init_jaxb_json_hash(_o)
                    super _o
                  end

                  # constructs a RestDynamicSememeFloat from a (parsed) JSON hash
                  def self.from_json(o)
                    if o.nil?
                      return nil
                    else
                      inst = new
                      inst.init_jaxb_json_hash o
                      return inst
                    end
                  end
                end

              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestDynamicSememeVersion < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion

                # The data attached to this sememe instance (if any).  The &#39;sememe/sememeDefinition/{id}&#39;
                # can be read to determine the potential types and descriptions of these columns.
                attr_accessor :dataColumns

                # the json hash for this RestDynamicSememeVersion
                def to_jaxb_json_hash
                  _h = super
                  if !dataColumns.nil?
                    _ha = Array.new
                    dataColumns.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['dataColumns'] = _ha
                  end
                  return _h
                end

                #initializes this RestDynamicSememeVersion with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['dataColumns'].nil?
                    _oa = _o['dataColumns']
                    if(_oa.is_a? Hash)
                      @dataColumns = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @dataColumns =  Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @dataColumns = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @dataColumns.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item)
                        else
                          @dataColumns.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @dataColumns = _oa
                    end
                  end
                end

                # constructs a RestDynamicSememeVersion from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestTaxonomyType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestTaxonomyType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestTaxonomyType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    _oa = _o['all']
                    if(_oa.is_a? Hash)
                      @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestTaxonomyType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @all = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestTaxonomyType.from_json(_item)
                        else
                          @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @all = _oa
                    end
                  end
                end

                # constructs a RestTaxonomyType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestDynamicSememeDataType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestDynamicSememeDataType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestDynamicSememeDataType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    _oa = _o['all']
                    if(_oa.is_a? Hash)
                      @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeDataType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @all = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeDataType.from_json(_item)
                        else
                          @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @all = _oa
                    end
                  end
                end

                # constructs a RestDynamicSememeDataType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestDynamicSememeValidatorType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestDynamicSememeValidatorType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestDynamicSememeValidatorType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    _oa = _o['all']
                    if(_oa.is_a? Hash)
                      @all = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @all =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeValidatorType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @all = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeValidatorType.from_json(_item)
                        else
                          @all.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @all = _oa
                    end
                  end
                end

                # constructs a RestDynamicSememeValidatorType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              module DataTypes

                # (no documentation provided)
                class RestDynamicSememeUUID < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeTypedData


                  # the json hash for this RestDynamicSememeUUID
                  def to_jaxb_json_hash
                    _h = super
                    return _h
                  end

                  #initializes this RestDynamicSememeUUID with a json hash
                  def init_jaxb_json_hash(_o)
                    super _o
                  end

                  # constructs a RestDynamicSememeUUID from a (parsed) JSON hash
                  def self.from_json(o)
                    if o.nil?
                      return nil
                    else
                      inst = new
                      inst.init_jaxb_json_hash o
                      return inst
                    end
                  end
                end

              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              module DataTypes

                # (no documentation provided)
                class RestDynamicSememeSequence < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeTypedData


                  # the json hash for this RestDynamicSememeSequence
                  def to_jaxb_json_hash
                    _h = super
                    return _h
                  end

                  #initializes this RestDynamicSememeSequence with a json hash
                  def init_jaxb_json_hash(_o)
                    super _o
                  end

                  # constructs a RestDynamicSememeSequence from a (parsed) JSON hash
                  def self.from_json(o)
                    if o.nil?
                      return nil
                    else
                      inst = new
                      inst.init_jaxb_json_hash o
                      return inst
                    end
                  end
                end

              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestFeatureNode < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestTypedConnectorNode

                # RestFeatureNode contains a RestConcreteDomainOperatorsType/ConcreteDomainOperators instance,
                # which is an enumeration specifying a type of comparison
                #
                # RestFeatureNode must have exactly 1 child node.
                #
                # Available RestConcreteDomainOperatorsType/ConcreteDomainOperator values include
                # EQUALS,
                # LESS_THAN,
                # LESS_THAN_EQUALS,
                # GREATER_THAN,
                # GREATER_THAN_EQUALS
                attr_accessor :operator

                # the json hash for this RestFeatureNode
                def to_jaxb_json_hash
                  _h = super
                  _h['operator'] = operator.to_jaxb_json_hash unless operator.nil?
                  return _h
                end

                #initializes this RestFeatureNode with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['operator'].nil?
                    _oa = _o['operator']
                    if(_oa.is_a? Hash)
                      @operator = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @operator =  Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestConcreteDomainOperatorsType.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @operator = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @operator.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestConcreteDomainOperatorsType.from_json(_item)
                        else
                          @operator.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @operator = _oa
                    end
                  end
                end

                # constructs a RestFeatureNode from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestRoleNode < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestTypedConnectorNode


                # the json hash for this RestRoleNode
                def to_jaxb_json_hash
                  _h = super
                  return _h
                end

                #initializes this RestRoleNode with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                end

                # constructs a RestRoleNode from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              module DataTypes

                # (no documentation provided)
                class RestDynamicSememeNid < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeTypedData


                  # the json hash for this RestDynamicSememeNid
                  def to_jaxb_json_hash
                    _h = super
                    return _h
                  end

                  #initializes this RestDynamicSememeNid with a json hash
                  def init_jaxb_json_hash(_o)
                    super _o
                  end

                  # constructs a RestDynamicSememeNid from a (parsed) JSON hash
                  def self.from_json(o)
                    if o.nil?
                      return nil
                    else
                      inst = new
                      inst.init_jaxb_json_hash o
                      return inst
                    end
                  end
                end

              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Comment

              # (no documentation provided)
              class RestCommentVersion < Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersionBaseCreate

                # The identifier data for the object
                attr_accessor :identifiers
                # The StampedVersion details for this comment
                attr_accessor :commentStamp

                # the json hash for this RestCommentVersion
                def to_jaxb_json_hash
                  _h = super
                  _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
                  _h['commentStamp'] = commentStamp.to_jaxb_json_hash unless commentStamp.nil?
                  return _h
                end

                #initializes this RestCommentVersion with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['identifiers'].nil?
                    _oa = _o['identifiers']
                    if(_oa.is_a? Hash)
                      @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @identifiers = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                        else
                          @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @identifiers = _oa
                    end
                  end
                  if !_o['commentStamp'].nil?
                    _oa = _o['commentStamp']
                    if(_oa.is_a? Hash)
                      @commentStamp = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @commentStamp =  Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @commentStamp = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @commentStamp.push Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_item)
                        else
                          @commentStamp.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @commentStamp = _oa
                    end
                  end
                end

                # constructs a RestCommentVersion from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Mapping

              # (no documentation provided)
              class RestMappingSetExtensionValue < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingSetExtensionValueBaseCreate

                # The selected description of the extensionNameConcept that describes the purpose of this extended field on a map set definition.
                # This is provided as a convenience on read.
                attr_accessor :extensionNameConceptDescription
                # The UUID(s) of the concept that describes the purpose of this extended field on a map set definition.  The descriptions from this concept
                # will be used as the label of the extension.
                attr_accessor :extensionNameConceptIdentifiers

                # the json hash for this RestMappingSetExtensionValue
                def to_jaxb_json_hash
                  _h = super
                  _h['extensionNameConceptDescription'] = extensionNameConceptDescription.to_jaxb_json_hash unless extensionNameConceptDescription.nil?
                  _h['extensionNameConceptIdentifiers'] = extensionNameConceptIdentifiers.to_jaxb_json_hash unless extensionNameConceptIdentifiers.nil?
                  return _h
                end

                #initializes this RestMappingSetExtensionValue with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['extensionNameConceptDescription'].nil?
                    _oa = _o['extensionNameConceptDescription']
                    if(_oa.is_a? Hash)
                      @extensionNameConceptDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @extensionNameConceptDescription =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @extensionNameConceptDescription = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @extensionNameConceptDescription.push String.from_json(_item)
                        else
                          @extensionNameConceptDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @extensionNameConceptDescription = _oa
                    end
                  end
                  if !_o['extensionNameConceptIdentifiers'].nil?
                    _oa = _o['extensionNameConceptIdentifiers']
                    if(_oa.is_a? Hash)
                      @extensionNameConceptIdentifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @extensionNameConceptIdentifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @extensionNameConceptIdentifiers = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @extensionNameConceptIdentifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                        else
                          @extensionNameConceptIdentifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @extensionNameConceptIdentifiers = _oa
                    end
                  end
                end

                # constructs a RestMappingSetExtensionValue from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Mapping

              # (no documentation provided)
              class RestMappingItemVersion < Gov::Vha::Isaac::Rest::Api1::Data::Mapping::RestMappingItemVersionBaseCreate

                # The data that was not expanded as part of this call (but can be)
                attr_accessor :expandables
                # The sememe sequence of the sememe that represents this mapping item
                attr_accessor :sememeSequence
                # The identifier data for the object
                attr_accessor :identifiers
                # The StampedVersion details for this mapping entry
                attr_accessor :mappingItemStamp
                # An (optional) description of the #sourceConcept - only populated when requested via the expandable &#39;referencedDetails&#39;
                attr_accessor :sourceDescription
                # An (optional) description of the #targetConcept - only populated when requested via the expandable &#39;referencedDetails&#39;
                attr_accessor :targetDescription
                # An (optional) description of the #qualifierConcept - only populated when requested via the expandable &#39;referencedDetails&#39;
                attr_accessor :qualifierDescription
                # The (optionally) populated comments attached to this map set.  This field is only populated when requested via an &#39;expand&#39; parameter.
                attr_accessor :comments

                # the json hash for this RestMappingItemVersion
                def to_jaxb_json_hash
                  _h = super
                  _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
                  _h['sememeSequence'] = sememeSequence.to_jaxb_json_hash unless sememeSequence.nil?
                  _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
                  _h['mappingItemStamp'] = mappingItemStamp.to_jaxb_json_hash unless mappingItemStamp.nil?
                  _h['sourceDescription'] = sourceDescription.to_jaxb_json_hash unless sourceDescription.nil?
                  _h['targetDescription'] = targetDescription.to_jaxb_json_hash unless targetDescription.nil?
                  _h['qualifierDescription'] = qualifierDescription.to_jaxb_json_hash unless qualifierDescription.nil?
                  if !comments.nil?
                    _ha = Array.new
                    comments.each { | _item | _ha.push _item.to_jaxb_json_hash }
                    _h['comments'] = _ha
                  end
                  return _h
                end

                #initializes this RestMappingItemVersion with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['expandables'].nil?
                    _oa = _o['expandables']
                    if(_oa.is_a? Hash)
                      @expandables = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @expandables =  Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @expandables = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @expandables.push Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_item)
                        else
                          @expandables.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @expandables = _oa
                    end
                  end
                  if !_o['sememeSequence'].nil?
                    _oa = _o['sememeSequence']
                    if(_oa.is_a? Hash)
                      @sememeSequence = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @sememeSequence =  Fixnum.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @sememeSequence = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @sememeSequence.push Fixnum.from_json(_item)
                        else
                          @sememeSequence.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @sememeSequence = _oa
                    end
                  end
                  if !_o['identifiers'].nil?
                    _oa = _o['identifiers']
                    if(_oa.is_a? Hash)
                      @identifiers = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @identifiers =  Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @identifiers = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @identifiers.push Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_item)
                        else
                          @identifiers.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @identifiers = _oa
                    end
                  end
                  if !_o['mappingItemStamp'].nil?
                    _oa = _o['mappingItemStamp']
                    if(_oa.is_a? Hash)
                      @mappingItemStamp = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @mappingItemStamp =  Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @mappingItemStamp = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @mappingItemStamp.push Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_item)
                        else
                          @mappingItemStamp.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @mappingItemStamp = _oa
                    end
                  end
                  if !_o['sourceDescription'].nil?
                    _oa = _o['sourceDescription']
                    if(_oa.is_a? Hash)
                      @sourceDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @sourceDescription =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @sourceDescription = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @sourceDescription.push String.from_json(_item)
                        else
                          @sourceDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @sourceDescription = _oa
                    end
                  end
                  if !_o['targetDescription'].nil?
                    _oa = _o['targetDescription']
                    if(_oa.is_a? Hash)
                      @targetDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @targetDescription =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @targetDescription = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @targetDescription.push String.from_json(_item)
                        else
                          @targetDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @targetDescription = _oa
                    end
                  end
                  if !_o['qualifierDescription'].nil?
                    _oa = _o['qualifierDescription']
                    if(_oa.is_a? Hash)
                      @qualifierDescription = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @qualifierDescription =  String.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @qualifierDescription = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @qualifierDescription.push String.from_json(_item)
                        else
                          @qualifierDescription.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @qualifierDescription = _oa
                    end
                  end
                  if !_o['comments'].nil?
                    _oa = _o['comments']
                    if(_oa.is_a? Hash)
                      @comments = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
                      @comments =  Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersion.from_json(_oa) unless _oa['@class']
                    elsif (_oa.is_a? Array)
                      #an array(of hashes hopefully) or scalar
                      @comments = Array.new
                      _oa.each { | _item |
                        if ((_item.nil? || _item['@class'].nil?)rescue true)
                          @comments.push Gov::Vha::Isaac::Rest::Api1::Data::Comment::RestCommentVersion.from_json(_item)
                        else
                          @comments.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                        end
                      }
                    else
                      @comments = _oa
                    end
                  end
                end

                # constructs a RestMappingItemVersion from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end