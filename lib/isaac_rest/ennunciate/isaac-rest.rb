#
# 
#
# Generated by <a href="http://enunciate.webcohesion.com">Enunciate</a>.
#
require 'json'

# adding necessary json serialization methods to standard classes.
class Object
  def to_jaxb_json_hash
    return self
  end

  def self.from_json o
    return o
  end
end

class String
  def self.from_json o
    return o
  end
end

class Boolean
  def self.from_json o
    return o
  end
end

class Numeric
  def self.from_json o
    return o
  end
end

class Time
  #json time is represented as number of milliseconds since epoch
  def to_jaxb_json_hash
    return (to_i * 1000) + (usec / 1000)
  end

  def self.from_json o
    if o.nil?
      return nil
    else
      return Time.at(o / 1000, (o % 1000) * 1000)
    end
  end
end

class Array
  def to_jaxb_json_hash
    a = Array.new
    each { |_item| a.push _item.to_jaxb_json_hash }
    return a
  end
end

class Hash
  def to_jaxb_json_hash
    h = Hash.new
    each { |_key, _value| h[_key.to_jaxb_json_hash] = _value.to_jaxb_json_hash }
    return h
  end
end


module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            # (no documentation provided)
            class RestId

              # The id value
              attr_accessor :value
              # The id type
              attr_accessor :idType

              # the json hash for this RestId
              def to_jaxb_json_hash
                _h = {}
                _h['value'] = value.to_jaxb_json_hash unless value.nil?
                _h['idType'] = idType.to_jaxb_json_hash unless idType.nil?
                return _h
              end

              # the json (string form) for this RestId
              def to_json
                to_jaxb_json_hash.to_json
              end

              #initializes this RestId with a json hash
              def init_jaxb_json_hash(_o)
                @value = String.from_json(_o['value']) unless _o['value'].nil?
                @idType = Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSupportedIdType.from_json(_o['idType']) unless _o['idType'].nil?
              end

              # constructs a RestId from a (parsed) JSON hash
              def self.from_json(o)
                if o.nil?
                  return nil
                else
                  inst = new
                  inst.init_jaxb_json_hash o
                  return inst
                end
              end
            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestDynamicSememeColumnInfo

                # The concept sequence number of the concept that represents the column within the dynamic sememe.
                attr_accessor :columnConceptSequence
                # The user-friendly name to display for this column.
                attr_accessor :columnName
                # The user friendly description for this column.  Suitable for things like tooltip descriptions.
                attr_accessor :columnDescription
                # The 0 indexed order of this column within the dynamic sememe.
                attr_accessor :columnOrder
                # The type of data that will be found in this column.  String, Integer, etc.  See
                # rest/1/enumeration/restDynamicSememeDataType for a list of all of the possible data types.
                attr_accessor :columnDataType
                # The default value to use for this column when creating a new sememe (if no user value is specified).
                # This field is optional and may be null.
                attr_accessor :columnDefaultData
                # Does the user have to provide a value for this column in order to create an instance of this sememe.
                attr_accessor :columnRequired
                # The validators types that are attached to this sememe (if any).  Interval, &lt;, etc.  See
                # rest/1/enumeration/restDynamicSememeValidatorType for a list of all possible validator types.
                attr_accessor :columnValidatorTypes
                # The data required to execute the validator type specified in columnValidatorTypes.  The format and type of this field
                # will depend on the columnValidatorTypes field.  The positions within this array will match with the columnValidatorTypes
                # array.
                attr_accessor :columnValidatorData

                # the json hash for this RestDynamicSememeColumnInfo
                def to_jaxb_json_hash
                  _h = {}
                  _h['columnConceptSequence'] = columnConceptSequence.to_jaxb_json_hash unless columnConceptSequence.nil?
                  _h['columnName'] = columnName.to_jaxb_json_hash unless columnName.nil?
                  _h['columnDescription'] = columnDescription.to_jaxb_json_hash unless columnDescription.nil?
                  _h['columnOrder'] = columnOrder.to_jaxb_json_hash unless columnOrder.nil?
                  _h['columnDataType'] = columnDataType.to_jaxb_json_hash unless columnDataType.nil?
                  _h['columnDefaultData'] = columnDefaultData.to_jaxb_json_hash unless columnDefaultData.nil?
                  _h['columnRequired'] = columnRequired.to_jaxb_json_hash unless columnRequired.nil?
                  if !columnValidatorTypes.nil?
                    _ha = Array.new
                    columnValidatorTypes.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['columnValidatorTypes'] = _ha
                  end
                  if !columnValidatorData.nil?
                    _ha = Array.new
                    columnValidatorData.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['columnValidatorData'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestDynamicSememeColumnInfo
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestDynamicSememeColumnInfo with a json hash
                def init_jaxb_json_hash(_o)
                  @columnConceptSequence = Fixnum.from_json(_o['columnConceptSequence']) unless _o['columnConceptSequence'].nil?
                  @columnName = String.from_json(_o['columnName']) unless _o['columnName'].nil?
                  @columnDescription = String.from_json(_o['columnDescription']) unless _o['columnDescription'].nil?
                  @columnOrder = Fixnum.from_json(_o['columnOrder']) unless _o['columnOrder'].nil?
                  @columnDataType = Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeDataType.from_json(_o['columnDataType']) unless _o['columnDataType'].nil?
                  @columnDefaultData = Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_o['columnDefaultData']) unless _o['columnDefaultData'].nil?
                  @columnRequired = Boolean.from_json(_o['columnRequired']) unless _o['columnRequired'].nil?
                  if !_o['columnValidatorTypes'].nil?
                    @columnValidatorTypes = Array.new
                    _oa = _o['columnValidatorTypes']
                    _oa.each { |_item| @columnValidatorTypes.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeValidatorType.from_json(_item) }
                  end
                  if !_o['columnValidatorData'].nil?
                    @columnValidatorData = Array.new
                    _oa = _o['columnValidatorData']
                    _oa.each { |_item| @columnValidatorData.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item) }
                  end
                end

                # constructs a RestDynamicSememeColumnInfo from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Concept

              # (no documentation provided)
              class RestConceptVersion

                # The data that was not expanded as part of this call (but can be)
                attr_accessor :expandables
                # The concept chronology for this concept.  Depending on the expand parameter, may be empty.
                attr_accessor :conChronology
                # The StampedVersion details for this version of this concept.
                attr_accessor :conVersion
                # The parent concepts(s) of the concept at this point in time (is a relationships).  Depending on the expand parameter, this may not be returned.
                attr_accessor :parents
                # The child concepts(s) of the concept at this point in time (is a relationships).  Depending on the expand parameter, this may not be returned.
                attr_accessor :children

                # the json hash for this RestConceptVersion
                def to_jaxb_json_hash
                  _h = {}
                  _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
                  _h['conChronology'] = conChronology.to_jaxb_json_hash unless conChronology.nil?
                  _h['conVersion'] = conVersion.to_jaxb_json_hash unless conVersion.nil?
                  if !parents.nil?
                    _ha = Array.new
                    parents.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['parents'] = _ha
                  end
                  if !children.nil?
                    _ha = Array.new
                    children.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['children'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestConceptVersion
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestConceptVersion with a json hash
                def init_jaxb_json_hash(_o)
                  @expandables = Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_o['expandables']) unless _o['expandables'].nil?
                  @conChronology = Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptChronology.from_json(_o['conChronology']) unless _o['conChronology'].nil?
                  @conVersion = Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_o['conVersion']) unless _o['conVersion'].nil?
                  if !_o['parents'].nil?
                    @parents = Array.new
                    _oa = _o['parents']
                    _oa.each { |_item| @parents.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_item) }
                  end
                  if !_o['children'].nil?
                    @children = Array.new
                    _oa = _o['children']
                    _oa.each { |_item| @children.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_item) }
                  end
                end

                # constructs a RestConceptVersion from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class Enumeration

                # The name of this enumeration type
                attr_accessor :name
                # The identifier of this enumeration.  This would be passed back to a call that requested an enum type.
                attr_accessor :enumId

                # the json hash for this Enumeration
                def to_jaxb_json_hash
                  _h = {}
                  _h['name'] = name.to_jaxb_json_hash unless name.nil?
                  _h['enumId'] = enumId.to_jaxb_json_hash unless enumId.nil?
                  return _h
                end

                # the json (string form) for this Enumeration
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this Enumeration with a json hash
                def init_jaxb_json_hash(_o)
                  @name = String.from_json(_o['name']) unless _o['name'].nil?
                  @enumId = Fixnum.from_json(_o['enumId']) unless _o['enumId'].nil?
                end

                # constructs a Enumeration from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Search

              # (no documentation provided)
              class RestSearchResult

                # The internal identifier of the sememe that matched the query
                attr_accessor :matchNid
                # The text of the description that matched the query (may be blank, if the description is not available/active on the path used to populate this)
                attr_accessor :matchText
                # The Lucene Score for this result.  This value is only useful for ranking search results relative to other search results within the SAME QUERY
                # execution.  It may not be used to rank one query against another.
                attr_accessor :score

                # the json hash for this RestSearchResult
                def to_jaxb_json_hash
                  _h = {}
                  _h['matchNid'] = matchNid.to_jaxb_json_hash unless matchNid.nil?
                  _h['matchText'] = matchText.to_jaxb_json_hash unless matchText.nil?
                  _h['score'] = score.to_jaxb_json_hash unless score.nil?
                  return _h
                end

                # the json (string form) for this RestSearchResult
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestSearchResult with a json hash
                def init_jaxb_json_hash(_o)
                  @matchNid = Fixnum.from_json(_o['matchNid']) unless _o['matchNid'].nil?
                  @matchText = String.from_json(_o['matchText']) unless _o['matchText'].nil?
                  @score = Float.from_json(_o['score']) unless _o['score'].nil?
                end

                # constructs a RestSearchResult from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api

          module Data

            # (no documentation provided)
            class Expandables

              # The list of data types that were not expanded on this request that could be expanded directly, or can
              # be expanded with a second trip by calling the provided URL
              attr_accessor :items

              # the json hash for this Expandables
              def to_jaxb_json_hash
                _h = {}
                if !items.nil?
                  _ha = Array.new
                  items.each { |_item| _ha.push _item.to_jaxb_json_hash }
                  _h['items'] = _ha
                end
                return _h
              end

              # the json (string form) for this Expandables
              def to_json
                to_jaxb_json_hash.to_json
              end

              #initializes this Expandables with a json hash
              def init_jaxb_json_hash(_o)
                if !_o['items'].nil?
                  @items = Array.new
                  _oa = _o['items']
                  _oa.each { |_item| @items.push Gov::Vha::Isaac::Rest::Api::Data::Expandable.from_json(_item) }
                end
              end

              # constructs a Expandables from a (parsed) JSON hash
              def self.from_json(o)
                if o.nil?
                  return nil
                else
                  inst = new
                  inst.init_jaxb_json_hash o
                  return inst
                end
              end
            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Concept

              # (no documentation provided)
              class RestConceptChronology

                # The &quot;best&quot; description for this concept.  This is selected based on the attributes within the session for
                # stamp and language coordinates - or - if none present - the server default.
                attr_accessor :description
                # The data that was not expanded as part of this call (but can be)
                attr_accessor :expandables
                # The identifier data for the object
                attr_accessor :identifiers
                # The list of concept versions.  Depending on the expand parameter, may be empty, the latest only, or all versions.
                attr_accessor :versions

                # the json hash for this RestConceptChronology
                def to_jaxb_json_hash
                  _h = {}
                  _h['description'] = description.to_jaxb_json_hash unless description.nil?
                  _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
                  _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
                  if !versions.nil?
                    _ha = Array.new
                    versions.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['versions'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestConceptChronology
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestConceptChronology with a json hash
                def init_jaxb_json_hash(_o)
                  @description = String.from_json(_o['description']) unless _o['description'].nil?
                  @expandables = Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_o['expandables']) unless _o['expandables'].nil?
                  @identifiers = Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_o['identifiers']) unless _o['identifiers'].nil?
                  if !_o['versions'].nil?
                    @versions = Array.new
                    _oa = _o['versions']
                    _oa.each { |_item| @versions.push Gov::Vha::Isaac::Rest::Api1::Data::Concept::RestConceptVersion.from_json(_item) }
                  end
                end

                # constructs a RestConceptChronology from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            # (no documentation provided)
            class RestStampedVersion

              # The stamp sequence of this version
              attr_accessor :stampSequence
              # The State of this version (active, inactive, primordial or cancelled)
              attr_accessor :state
              # The time stamp of this version (in standard java form)
              attr_accessor :time
              # The concept sequence of the concept that identifies the author of this version
              attr_accessor :authorSequence
              # The concept sequence of the module that this version is in
              attr_accessor :moduleSequence
              # The concept sequence of the path that this version is in
              attr_accessor :pathSequence

              # the json hash for this RestStampedVersion
              def to_jaxb_json_hash
                _h = {}
                _h['stampSequence'] = stampSequence.to_jaxb_json_hash unless stampSequence.nil?
                _h['state'] = state.to_jaxb_json_hash unless state.nil?
                _h['time'] = time.to_jaxb_json_hash unless time.nil?
                _h['authorSequence'] = authorSequence.to_jaxb_json_hash unless authorSequence.nil?
                _h['moduleSequence'] = moduleSequence.to_jaxb_json_hash unless moduleSequence.nil?
                _h['pathSequence'] = pathSequence.to_jaxb_json_hash unless pathSequence.nil?
                return _h
              end

              # the json (string form) for this RestStampedVersion
              def to_json
                to_jaxb_json_hash.to_json
              end

              #initializes this RestStampedVersion with a json hash
              def init_jaxb_json_hash(_o)
                @stampSequence = Fixnum.from_json(_o['stampSequence']) unless _o['stampSequence'].nil?
                @state = String.from_json(_o['state']) unless _o['state'].nil?
                @time = Bignum.from_json(_o['time']) unless _o['time'].nil?
                @authorSequence = Fixnum.from_json(_o['authorSequence']) unless _o['authorSequence'].nil?
                @moduleSequence = Fixnum.from_json(_o['moduleSequence']) unless _o['moduleSequence'].nil?
                @pathSequence = Fixnum.from_json(_o['pathSequence']) unless _o['pathSequence'].nil?
              end

              # constructs a RestStampedVersion from a (parsed) JSON hash
              def self.from_json(o)
                if o.nil?
                  return nil
                else
                  inst = new
                  inst.init_jaxb_json_hash o
                  return inst
                end
              end
            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestDynamicSememeDefinition

                # The concept sequence of the concept that is used as an assemblage.  The rest of the descriptive details of the
                # sememe assemblage (returned in this object) are read from this concept.
                attr_accessor :assemblageConceptId
                # the user-friendly description of the overall purpose of this sememe
                attr_accessor :sememeUsageDescription
                # the column information that describes the data that may be returned as part of a sememe instance.
                attr_accessor :columnInfo
                # Return the RestObjectChronologyType of the restriction on referenced components for this sememe (if any - may return null)
                #
                # If there is a restriction, the nid set for the referenced component in an instance of this sememe must be of the type listed here.
                #
                # See rest/1/enumeration/restObjectChronologyType for a list of potential object types returned.
                attr_accessor :referencedComponentTypeRestriction
                # Return the RestSememeType of the sub restriction on referenced components for this DynamicSememe (if any - may return null)
                #
                # If there is a restriction, the nid set for the referenced component in an instance of this sememe must be of the type listed here.
                #
                # This is only applicable when #referencedComponentTypeRestriction returns RestObjectChronologyType#SEMEME
                #
                # See rest/1/enumeration/restSememeType for a list of potential object types returned.
                attr_accessor :referencedComponentTypeSubRestriction

                # the json hash for this RestDynamicSememeDefinition
                def to_jaxb_json_hash
                  _h = {}
                  _h['assemblageConceptId'] = assemblageConceptId.to_jaxb_json_hash unless assemblageConceptId.nil?
                  _h['sememeUsageDescription'] = sememeUsageDescription.to_jaxb_json_hash unless sememeUsageDescription.nil?
                  if !columnInfo.nil?
                    _ha = Array.new
                    columnInfo.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['columnInfo'] = _ha
                  end
                  _h['referencedComponentTypeRestriction'] = referencedComponentTypeRestriction.to_jaxb_json_hash unless referencedComponentTypeRestriction.nil?
                  _h['referencedComponentTypeSubRestriction'] = referencedComponentTypeSubRestriction.to_jaxb_json_hash unless referencedComponentTypeSubRestriction.nil?
                  return _h
                end

                # the json (string form) for this RestDynamicSememeDefinition
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestDynamicSememeDefinition with a json hash
                def init_jaxb_json_hash(_o)
                  @assemblageConceptId = Fixnum.from_json(_o['assemblageConceptId']) unless _o['assemblageConceptId'].nil?
                  @sememeUsageDescription = String.from_json(_o['sememeUsageDescription']) unless _o['sememeUsageDescription'].nil?
                  if !_o['columnInfo'].nil?
                    @columnInfo = Array.new
                    _oa = _o['columnInfo']
                    _oa.each { |_item| @columnInfo.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeColumnInfo.from_json(_item) }
                  end
                  @referencedComponentTypeRestriction = Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_o['referencedComponentTypeRestriction']) unless _o['referencedComponentTypeRestriction'].nil?
                  @referencedComponentTypeSubRestriction = Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSememeType.from_json(_o['referencedComponentTypeSubRestriction']) unless _o['referencedComponentTypeSubRestriction'].nil?
                end

                # constructs a RestDynamicSememeDefinition from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestDynamicSememeData

                # The 0 indexed column number for this data.  Will not be populated for nested RestDynamicSememeData objects where the &#39;data&#39; field
                # is of type RestDynamicSememeArray
                attr_accessor :columnNumber
                # The data for a column within a RestDynamicSememeVersion instance
                attr_accessor :data

                # the json hash for this RestDynamicSememeData
                def to_jaxb_json_hash
                  _h = {}
                  _h['columnNumber'] = columnNumber.to_jaxb_json_hash unless columnNumber.nil?
                  _h['data'] = data.to_jaxb_json_hash unless data.nil?
                  return _h
                end

                # the json (string form) for this RestDynamicSememeData
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestDynamicSememeData with a json hash
                def init_jaxb_json_hash(_o)
                  @columnNumber = Fixnum.from_json(_o['columnNumber']) unless _o['columnNumber'].nil?
                  @data = Object.from_json(_o['data']) unless _o['data'].nil?
                end

                # constructs a RestDynamicSememeData from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestSememeChronology

                # The data that was not expanded as part of this call (but can be)
                attr_accessor :expandables
                # The sememe sequence identifier of this sememe instance
                attr_accessor :sememeSequence
                # The concept sequence identifier of the concept that represents the type of this sememe
                attr_accessor :assemblageSequence
                # The NID identifier of the object that is referenced by this sememe instance.  This could represent a concept or a sememe.
                attr_accessor :referencedComponentNid
                # The permanent identifier object(s) attached to this sememe instance
                attr_accessor :identifiers
                # The list of sememe versions.  Depending on the expand parameter, may be empty, the latest only, or all versions.
                attr_accessor :versions

                # the json hash for this RestSememeChronology
                def to_jaxb_json_hash
                  _h = {}
                  _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
                  _h['sememeSequence'] = sememeSequence.to_jaxb_json_hash unless sememeSequence.nil?
                  _h['assemblageSequence'] = assemblageSequence.to_jaxb_json_hash unless assemblageSequence.nil?
                  _h['referencedComponentNid'] = referencedComponentNid.to_jaxb_json_hash unless referencedComponentNid.nil?
                  _h['identifiers'] = identifiers.to_jaxb_json_hash unless identifiers.nil?
                  if !versions.nil?
                    _ha = Array.new
                    versions.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['versions'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestSememeChronology
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestSememeChronology with a json hash
                def init_jaxb_json_hash(_o)
                  @expandables = Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_o['expandables']) unless _o['expandables'].nil?
                  @sememeSequence = Fixnum.from_json(_o['sememeSequence']) unless _o['sememeSequence'].nil?
                  @assemblageSequence = Fixnum.from_json(_o['assemblageSequence']) unless _o['assemblageSequence'].nil?
                  @referencedComponentNid = Fixnum.from_json(_o['referencedComponentNid']) unless _o['referencedComponentNid'].nil?
                  @identifiers = Gov::Vha::Isaac::Rest::Api1::Data::RestIdentifiedObject.from_json(_o['identifiers']) unless _o['identifiers'].nil?
                  if !_o['versions'].nil?
                    @versions = Array.new
                    _oa = _o['versions']
                    _oa.each { |_item| @versions.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion.from_json(_item) }
                  end
                end

                # constructs a RestSememeChronology from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            # (no documentation provided)
            class RestIdentifiedObject

              # The globally unique, fixed, stable set of identifiers for the object
              attr_accessor :uuids

              # the json hash for this RestIdentifiedObject
              def to_jaxb_json_hash
                _h = {}
                if !uuids.nil?
                  _ha = Array.new
                  uuids.each { |_item| _ha.push _item.to_jaxb_json_hash }
                  _h['uuids'] = _ha
                end
                return _h
              end

              # the json (string form) for this RestIdentifiedObject
              def to_json
                to_jaxb_json_hash.to_json
              end

              #initializes this RestIdentifiedObject with a json hash
              def init_jaxb_json_hash(_o)
                if !_o['uuids'].nil?
                  @uuids = Array.new
                  _oa = _o['uuids']
                  _oa.each { |_item| @uuids.push String.from_json(_item) }
                end
              end

              # constructs a RestIdentifiedObject from a (parsed) JSON hash
              def self.from_json(o)
                if o.nil?
                  return nil
                else
                  inst = new
                  inst.init_jaxb_json_hash o
                  return inst
                end
              end
            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestSememeVersion

                # The data that was not expanded as part of this call (but can be)
                attr_accessor :expandables
                # The sememe chronology for this concept.  Depending on the expand parameter, may be empty.
                attr_accessor :sememeChronology
                # The StampedVersion details for this version of this sememe.
                attr_accessor :sememeVersion
                # The nested sememes attached to this sememe.  Not populated by default, include expand=nested to expand these.
                attr_accessor :nestedSememes

                # the json hash for this RestSememeVersion
                def to_jaxb_json_hash
                  _h = {}
                  _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
                  _h['sememeChronology'] = sememeChronology.to_jaxb_json_hash unless sememeChronology.nil?
                  _h['sememeVersion'] = sememeVersion.to_jaxb_json_hash unless sememeVersion.nil?
                  if !nestedSememes.nil?
                    _ha = Array.new
                    nestedSememes.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['nestedSememes'] = _ha
                  end
                  return _h
                end

                # the json (string form) for this RestSememeVersion
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestSememeVersion with a json hash
                def init_jaxb_json_hash(_o)
                  @expandables = Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_o['expandables']) unless _o['expandables'].nil?
                  @sememeChronology = Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeChronology.from_json(_o['sememeChronology']) unless _o['sememeChronology'].nil?
                  @sememeVersion = Gov::Vha::Isaac::Rest::Api1::Data::RestStampedVersion.from_json(_o['sememeVersion']) unless _o['sememeVersion'].nil?
                  if !_o['nestedSememes'].nil?
                    @nestedSememes = Array.new
                    _oa = _o['nestedSememes']
                    _oa.each { |_item| @nestedSememes.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeVersion.from_json(_item) }
                  end
                end

                # constructs a RestSememeVersion from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestLogicNode

                # The data that was not expanded as part of this call (but can be)
                attr_accessor :expandables
                # The UUID of the logic node itself (not of any referenced or associated component or concept)
                attr_accessor :nodeUuid
                # The list of child RestLogicNode instances contained within this RestLogicNode.
                # A RestTypedConnctorNode may have exactly one child node
                # A literal node may not have any child nodes at all
                # Others may have one or more child nodes
                attr_accessor :children
                # The RestNodeSemantic type of this node corresponding to the NodeSemantic enum
                attr_accessor :nodeSemantic

                # the json hash for this RestLogicNode
                def to_jaxb_json_hash
                  _h = {}
                  _h['expandables'] = expandables.to_jaxb_json_hash unless expandables.nil?
                  _h['nodeUuid'] = nodeUuid.to_jaxb_json_hash unless nodeUuid.nil?
                  if !children.nil?
                    _ha = Array.new
                    children.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['children'] = _ha
                  end
                  _h['nodeSemantic'] = nodeSemantic.to_jaxb_json_hash unless nodeSemantic.nil?
                  return _h
                end

                # the json (string form) for this RestLogicNode
                def to_json
                  to_jaxb_json_hash.to_json
                end

                #initializes this RestLogicNode with a json hash
                def init_jaxb_json_hash(_o)
                  @expandables = Gov::Vha::Isaac::Rest::Api::Data::Expandables.from_json(_o['expandables']) unless _o['expandables'].nil?
                  @nodeUuid = String.from_json(_o['nodeUuid']) unless _o['nodeUuid'].nil?
                  if !_o['children'].nil?
                    @children = Array.new
                    _oa = _o['children']
                    _oa.each { |_item| @children.push Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode.from_json(_item) }
                  end
                  @nodeSemantic = Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestNodeSemantic.from_json(_o['nodeSemantic']) unless _o['nodeSemantic'].nil?
                end

                # constructs a RestLogicNode from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api

          module Data

            # (no documentation provided)
            class Expandable

              # The name of the item that is expandable (pass this to have this value expanded directly by the call that produced this)
              attr_accessor :name
              # The url to call to get the expanded item separately
              attr_accessor :url

              # the json hash for this Expandable
              def to_jaxb_json_hash
                _h = {}
                _h['name'] = name.to_jaxb_json_hash unless name.nil?
                _h['url'] = url.to_jaxb_json_hash unless url.nil?
                return _h
              end

              # the json (string form) for this Expandable
              def to_json
                to_jaxb_json_hash.to_json
              end

              #initializes this Expandable with a json hash
              def init_jaxb_json_hash(_o)
                @name = String.from_json(_o['name']) unless _o['name'].nil?
                @url = String.from_json(_o['url']) unless _o['url'].nil?
              end

              # constructs a Expandable from a (parsed) JSON hash
              def self.from_json(o)
                if o.nil?
                  return nil
                else
                  inst = new
                  inst.init_jaxb_json_hash o
                  return inst
                end
              end
            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestDynamicSememeVersion < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion

                # The data attached to this sememe instance (if any).  The &#39;sememe/sememeDefinition/{id}&#39;
                # can be read to determine the potential types and descriptions of these columns.
                attr_accessor :dataColumns

                # the json hash for this RestDynamicSememeVersion
                def to_jaxb_json_hash
                  _h = super
                  if !dataColumns.nil?
                    _ha = Array.new
                    dataColumns.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['dataColumns'] = _ha
                  end
                  return _h
                end

                #initializes this RestDynamicSememeVersion with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['dataColumns'].nil?
                    @dataColumns = Array.new
                    _oa = _o['dataColumns']
                    _oa.each { |_item| @dataColumns.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeData.from_json(_item) }
                  end
                end

                # constructs a RestDynamicSememeVersion from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestObjectChronologyType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestObjectChronologyType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestObjectChronologyType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    @all = Array.new
                    _oa = _o['all']
                    _oa.each { |_item| @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestObjectChronologyType.from_json(_item) }
                  end
                end

                # constructs a RestObjectChronologyType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Ochre

        module Api

          # (no documentation provided)
          class State

            #
            INACTIVE = "INACTIVE"

            #
            ACTIVE = "ACTIVE"

            #
            PRIMORDIAL = "PRIMORDIAL"

            #
            CANCELED = "CANCELED"
          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestSememeType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestSememeType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestSememeType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    @all = Array.new
                    _oa = _o['all']
                    _oa.each { |_item| @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSememeType.from_json(_item) }
                  end
                end

                # constructs a RestSememeType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestDynamicSememeDataType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestDynamicSememeDataType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestDynamicSememeDataType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    @all = Array.new
                    _oa = _o['all']
                    _oa.each { |_item| @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeDataType.from_json(_item) }
                  end
                end

                # constructs a RestDynamicSememeDataType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestSememeDescriptionVersion < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion

                # The concept sequence of the concept that represents the case significance flag on the description .
                # This should be description case sensitive, description not case sensitive or description initial character sensitive
                attr_accessor :caseSignificanceConceptSequence
                # The concept sequence of the concept that represents the language of the description (note, this is NOT
                # the dialect)
                attr_accessor :languageConceptSequence
                # The text of the description
                attr_accessor :text
                # The concept sequence of the concept that represents the type of the description.
                # This should be FSN, Synonym, or Definition.
                attr_accessor :descriptionTypeConceptSequence
                # The dialects attached to this sememe.  Not populated by default, include expand=nestedSememes to expand this.
                attr_accessor :dialects

                # the json hash for this RestSememeDescriptionVersion
                def to_jaxb_json_hash
                  _h = super
                  _h['caseSignificanceConceptSequence'] = caseSignificanceConceptSequence.to_jaxb_json_hash unless caseSignificanceConceptSequence.nil?
                  _h['languageConceptSequence'] = languageConceptSequence.to_jaxb_json_hash unless languageConceptSequence.nil?
                  _h['text'] = text.to_jaxb_json_hash unless text.nil?
                  _h['descriptionTypeConceptSequence'] = descriptionTypeConceptSequence.to_jaxb_json_hash unless descriptionTypeConceptSequence.nil?
                  if !dialects.nil?
                    _ha = Array.new
                    dialects.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['dialects'] = _ha
                  end
                  return _h
                end

                #initializes this RestSememeDescriptionVersion with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  @caseSignificanceConceptSequence = Fixnum.from_json(_o['caseSignificanceConceptSequence']) unless _o['caseSignificanceConceptSequence'].nil?
                  @languageConceptSequence = Fixnum.from_json(_o['languageConceptSequence']) unless _o['languageConceptSequence'].nil?
                  @text = String.from_json(_o['text']) unless _o['text'].nil?
                  @descriptionTypeConceptSequence = Fixnum.from_json(_o['descriptionTypeConceptSequence']) unless _o['descriptionTypeConceptSequence'].nil?
                  if !_o['dialects'].nil?
                    @dialects = Array.new
                    _oa = _o['dialects']
                    _oa.each { |_item| @dialects.push Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestDynamicSememeVersion.from_json(_item) }
                  end
                end

                # constructs a RestSememeDescriptionVersion from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestDynamicSememeValidatorType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestDynamicSememeValidatorType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestDynamicSememeValidatorType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    @all = Array.new
                    _oa = _o['all']
                    _oa.each { |_item| @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestDynamicSememeValidatorType.from_json(_item) }
                  end
                end

                # constructs a RestDynamicSememeValidatorType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Sememe

              # (no documentation provided)
              class RestSememeLogicGraphVersion < Gov::Vha::Isaac::Rest::Api1::Data::Sememe::RestSememeVersion

                # The String text of the description of the associated concept
                attr_accessor :referencedConceptDescription
                # The root node of the logical expression tree associated with the concept
                attr_accessor :rootLogicNode

                # the json hash for this RestSememeLogicGraphVersion
                def to_jaxb_json_hash
                  _h = super
                  _h['referencedConceptDescription'] = referencedConceptDescription.to_jaxb_json_hash unless referencedConceptDescription.nil?
                  _h['rootLogicNode'] = rootLogicNode.to_jaxb_json_hash unless rootLogicNode.nil?
                  return _h
                end

                #initializes this RestSememeLogicGraphVersion with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  @referencedConceptDescription = String.from_json(_o['referencedConceptDescription']) unless _o['referencedConceptDescription'].nil?
                  @rootLogicNode = Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestUntypedConnectorNode.from_json(_o['rootLogicNode']) unless _o['rootLogicNode'].nil?
                end

                # constructs a RestSememeLogicGraphVersion from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestNodeSemantic < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestNodeSemantic
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestNodeSemantic with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    @all = Array.new
                    _oa = _o['all']
                    _oa.each { |_item| @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestNodeSemantic.from_json(_item) }
                  end
                end

                # constructs a RestNodeSemantic from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestConnectorNode < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestLogicNode


                # the json hash for this RestConnectorNode
                def to_jaxb_json_hash
                  _h = super
                  return _h
                end

                #initializes this RestConnectorNode with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                end

                # constructs a RestConnectorNode from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Enumerations

              # (no documentation provided)
              class RestSupportedIdType < Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::Enumeration

                # (no documentation provided)
                attr_accessor :all

                # the json hash for this RestSupportedIdType
                def to_jaxb_json_hash
                  _h = super
                  if !all.nil?
                    _ha = Array.new
                    all.each { |_item| _ha.push _item.to_jaxb_json_hash }
                    _h['all'] = _ha
                  end
                  return _h
                end

                #initializes this RestSupportedIdType with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                  if !_o['all'].nil?
                    @all = Array.new
                    _oa = _o['all']
                    _oa.each { |_item| @all.push Gov::Vha::Isaac::Rest::Api1::Data::Enumerations::RestSupportedIdType.from_json(_item) }
                  end
                end

                # constructs a RestSupportedIdType from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end

module Gov

  module Vha

    module Isaac

      module Rest

        module Api1

          module Data

            module Logic

              # (no documentation provided)
              class RestUntypedConnectorNode < Gov::Vha::Isaac::Rest::Api1::Data::Logic::RestConnectorNode


                # the json hash for this RestUntypedConnectorNode
                def to_jaxb_json_hash
                  _h = super
                  return _h
                end

                #initializes this RestUntypedConnectorNode with a json hash
                def init_jaxb_json_hash(_o)
                  super _o
                end

                # constructs a RestUntypedConnectorNode from a (parsed) JSON hash
                def self.from_json(o)
                  if o.nil?
                    return nil
                  else
                    inst = new
                    inst.init_jaxb_json_hash o
                    return inst
                  end
                end
              end

            end

          end

        end

      end

    end

  end

end
