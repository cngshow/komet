var ConceptsModule = (function () {

  var currentConceptID;
  var panelStates = {};

  function togglePanelDetails(panel_id, callback, preserveState) {

    // get the panel's expander icon, or all expander icons if this is the top level expander
    var expander = $("#" + panel_id + " .glyphicon-plus-sign, #" + panel_id + " .glyphicon-minus-sign");
    var drawer = $("#" + panel_id + " .komet-concept-section-panel-details");
    var topLevelExpander = expander.parent().hasClass('komet-concept-body-tools');

    // if the user clicked on the top level concept expander, change the associated text label
    if (topLevelExpander) {

      var item_text = expander[0].nextElementSibling;

      if (item_text.innerHTML == "Expand All") {

        item_text.innerHTML = "Collapse All";
        open = true;

      } else {

        item_text.innerHTML = "Expand All";
        open = false;
      }
    } else {
      open = expander.hasClass("glyphicon-plus-sign");
    }

    // change the displayed expander icon and drawer visibility
    if (open) {

      expander.removeClass("glyphicon-plus-sign");
      expander.addClass("glyphicon-minus-sign");
      drawer.show();

    } else {

      expander.removeClass("glyphicon-minus-sign");
      expander.addClass("glyphicon-plus-sign");
      drawer.hide();
    }

    // save state if needed, and if there is a callback run it, passing the panel ID and open state.
    if(topLevelExpander){

      // if this is the top level loop through all saved panel states and run the callback if it has one
      for (var key in panelStates) {

        panelStates[key][0] = open;

        if (panelStates[key].length > 1 && panelStates[key][1]){
          panelStates[key][1](key, open);
        }
      }
    } else {

      // if we are preserving state set the current state of the panel into the ConceptsModule object.
      if (preserveState) {
        ConceptsModule.setPanelState(panel_id, open, callback);
      }

      //r un the callback
      if (panelStates[panel_id].length > 1 && panelStates[panel_id][1]) {
        panelStates[panel_id][1](panel_id, open);
      }
    }
  }

  function setPanelState(panelID, state, callback) {

    if (panelStates[panelID] === undefined) {
      panelStates[panelID] = [];
    }

    if (state !== null) {
      panelStates[panelID][0] = state;
    }

    if (callback){
      panelStates[panelID][1] = callback;
    }
  }

  function getPanelState(panelID) {

    if(!panelStates[panelID]) {
      return false;
    }

    return panelStates[panelID][0];
  }

  function restorePanelStates() {

    for (var key in panelStates) {

      var state = panelStates[key][0];
      var callback = panelStates[key][1];
      console.log("restore state: " + key + " - state: " + state);

      if (state) {
        ConceptsModule.togglePanelDetails(key, callback);
      }
    }
  }

  function loadLineageTrees(){

    var stated = $("#komet_concept_stated_inferred")[0].value

    TaxonomyModule.buildTaxonomyTree("concept_lineage_parents_tree", stated, true, TaxonomyModule.selectedTreeNode);
    TaxonomyModule.buildTaxonomyTree("concept_lineage_children_tree", stated, false, TaxonomyModule.selectedTreeNode);

    TaxonomyModule.concept_lineage_parents_tree.bind('ready.jstree', function (event, data) {

      if (data.instance._cnt == 0) {

        TaxonomyModule.concept_lineage_parents_tree.html("<div class='komet-reverse-tree-node'>No Parents</div>");
        $("#concept_lineage_header_text").html("No Parent");
      } else{
        $("#concept_lineage_header_text").html(data.instance.get_node('ul > li:first').text);
      }
    });

    TaxonomyModule.concept_lineage_children_tree.bind('ready.jstree', function (event, data) {

      if (data.instance._cnt == 0) {
        TaxonomyModule.concept_lineage_children_tree.html("No Children");
      }
    });

    // publish an event that passes the id of the concept selected to listeners
    function onChanged(event, selectedObject) {

      var conceptId = selectedObject.node.id;
      $.publish(KometChannels.Taxonomy.taxonomyTreeNodeSelectedChannel, conceptId);
    }

    TaxonomyModule.concept_lineage_parents_tree.on('changed.jstree', onChanged);
    TaxonomyModule.concept_lineage_children_tree.on('changed.jstree', onChanged);
  }

  function subscribeToTaxonomyTree() {

    // listen for the onChange event broadcast by any of the taxonomy trees.
    $.subscribe(KometChannels.Taxonomy.taxonomyTreeNodeSelectedChannel, function (e, conceptID) {

      currentConceptID = conceptID;

      loadConceptTabs()
    });
  }

  function subscribeToSearch() {

    // listen for the onChange event broadcast by selecting a search result.
    $.subscribe(KometChannels.Taxonomy.taxonomySearchResultSelectedChannel, function (e, conceptID) {

      currentConceptID = conceptID;
      TaxonomyModule.selectedTreeNode = currentConceptID;

      loadConceptTabs();
    });
  }

  function loadConceptTabs() {

    // the path to a javascript partial file that will re-render all the appropriate partials once the ajax call returns
    var partial = 'komet_dashboard/concept_detail/load_tabs';

    // make an ajax call to get the concept for the current concept and pass it the currently selected concept id and the name of a partial file to render
    $.get(gon.routes.taxonomy_get_concept_information_path, {concept_id: currentConceptID, partial: partial}, function (data) {
    });
  }

  function getCurrentConceptId() {
    return currentConceptID;
  }

  function init() {
    subscribeToTaxonomyTree();
    subscribeToSearch();
  }

  return {
    initialize: init,
    loadLineageTrees: loadLineageTrees,
    getCurrentConceptId: getCurrentConceptId,
    setPanelState : setPanelState,
    getPanelState : getPanelState,
    restorePanelStates : restorePanelStates,
    togglePanelDetails: togglePanelDetails
  };

})();
