var ConceptsModule = (function () {

  var currentConceptID;
  var panelStates = {};
  var trees = [];
  const PARENTS_TREE = "concept_lineage_parents_tree";
  const CHILDREN_TREE = "concept_lineage_children_tree";

  function togglePanelDetails(panel_id, callback, preserveState) {

    // get the panel's expander icon, or all expander icons if this is the top level expander
    var expander = $("#" + panel_id + " .glyphicon-plus-sign, #" + panel_id + " .glyphicon-minus-sign");
    var drawer = $("#" + panel_id + " .komet-concept-section-panel-details");
    var topLevelExpander = expander.parent().hasClass('komet-concept-body-tools');

    // if the user clicked on the top level concept expander, change the associated text label
    if (topLevelExpander) {

      var item_text = expander[0].nextElementSibling;

      if (item_text.innerHTML == "Expand All") {

        item_text.innerHTML = "Collapse All";
        open = true;

      } else {

        item_text.innerHTML = "Expand All";
        open = false;
      }
    } else {
      open = expander.hasClass("glyphicon-plus-sign");
    }

    // change the displayed expander icon and drawer visibility
    if (open) {

      expander.removeClass("glyphicon-plus-sign");
      expander.addClass("glyphicon-minus-sign");
      drawer.show();

    } else {

      expander.removeClass("glyphicon-minus-sign");
      expander.addClass("glyphicon-plus-sign");
      drawer.hide();
    }

    // save state if needed, and if there is a callback run it, passing the panel ID and open state.
    if(topLevelExpander){

      // if this is the top level loop through all saved panel states and run the callback if it has one
      for (var key in panelStates) {

        panelStates[key][0] = open;

        if (panelStates[key].length > 1 && panelStates[key][1]){
          panelStates[key][1](key, open);
        }
      }
    } else {

      // if we are preserving state set the current state of the panel into the ConceptsModule object.
      if (preserveState) {
        ConceptsModule.setPanelState(panel_id, open, callback);
      }

      //r un the callback
      if (panelStates[panel_id].length > 1 && panelStates[panel_id][1]) {
        panelStates[panel_id][1](panel_id, open);
      }
    }
  }

  function setPanelState(panelID, state, callback) {

    if (panelStates[panelID] === undefined) {
      panelStates[panelID] = [];
    }

    if (state !== null) {
      panelStates[panelID][0] = state;
    }

    if (callback){
      panelStates[panelID][1] = callback;
    }
  }

  function getPanelState(panelID) {

    if(!panelStates[panelID]) {
      return false;
    }

    return panelStates[panelID][0];
  }

  function restorePanelStates() {

    for (var key in panelStates) {

      var state = panelStates[key][0];
      var callback = panelStates[key][1];

      if (state) {
        ConceptsModule.togglePanelDetails(key, callback);
      }
    }
  }

  function loadLineageTrees(){

    var stated = $("#komet_concept_stated_inferred")[0].value

    trees[PARENTS_TREE] = new KometTaxonomyTree(PARENTS_TREE, stated, true, currentConceptID);
    trees[CHILDREN_TREE] = new KometTaxonomyTree(CHILDREN_TREE, stated, false, currentConceptID);

    trees[PARENTS_TREE].tree.bind('ready.jstree', function (event, data) {

      // should use data.instance._cnt, but never has count anymore
      if (data.instance._model.data["#"].children.length == 0) {

        trees[PARENTS_TREE].tree.html("<div class='komet-reverse-tree-node'>No Parents</div>");
        $("#concept_lineage_header_text").html("No Parent");
      } else{
        $("#concept_lineage_header_text").html(data.instance.get_node('ul > li:first').text);
      }
    });

    trees[CHILDREN_TREE].tree.bind('ready.jstree', function (event, data) {

      // should use data.instance._cnt, but never has count anymore
      if (data.instance._model.data["#"].children.length == 0) {
        trees[CHILDREN_TREE].tree.html("No Children");
      }
    });
  }

  function subscribeToTaxonomyTree() {

    // listen for the onChange event broadcast by any of the taxonomy trees.
    $.subscribe(KometChannels.Taxonomy.taxonomyTreeNodeSelectedChannel, function (e, treeID, conceptID) {

      currentConceptID = conceptID;
      loadConceptTabs()
    });
  }

  function subscribeToSearch() {

    // listen for the onChange event broadcast by selecting a search result.
    $.subscribe(KometChannels.Taxonomy.taxonomySearchResultSelectedChannel, function (e, conceptID) {

      currentConceptID = conceptID;
      trees[PARENTS_TREE].selectedConceptID = currentConceptID;
      trees[CHILDREN_TREE].selectedConceptID = currentConceptID;
      loadConceptTabs();
    });
  }

  function loadConceptTabs() {

    // the path to a javascript partial file that will re-render all the appropriate partials once the ajax call returns
    var partial = 'komet_dashboard/concept_detail/load_tabs';

    // make an ajax call to get the concept for the current concept and pass it the currently selected concept id and the name of a partial file to render
    $.get(gon.routes.taxonomy_get_concept_information_path, {concept_id: currentConceptID, partial: partial}, function (data) {
    });
  }

  function toggleNestedTableRows(image, id){

    // get reference to the block of nested rows
    var nestedRows = $("#komet_concept_table_nested_row_" + id);

    // change the displayed image and nested rows visibility
    if (image.hasClass("glyphicon-arrow-right")){

      image.removeClass("glyphicon-arrow-right");
      image.addClass("glyphicon-arrow-down");
      nestedRows.show();
      image.parent().addClass("komet-concept-table-nested-indicator-open");

    } else {

      image.removeClass("glyphicon-arrow-down");
      image.addClass("glyphicon-arrow-right");
      nestedRows.hide();
      image.parent().removeClass("komet-concept-table-nested-indicator-open");
    }
  }

  // show this concept in the taxonomy tree
  function linkToTaxonomyTree() {

    TaxonomyModule.tree.findNodeInTree(
        ConceptsModule.getCurrentConceptId(),
        $('#komet_concept_stated_inferred')[0].value,
        function (foundNodeId) {
          console.log('Button returned: ' + foundNodeId);
        },
        true
    );
  }

  function getCurrentConceptId() {
    return currentConceptID;
  }

  function init() {
    subscribeToTaxonomyTree();
    subscribeToSearch();
  }

  return {
    initialize: init,
    loadLineageTrees: loadLineageTrees,
    getCurrentConceptId: getCurrentConceptId,
    setPanelState : setPanelState,
    getPanelState : getPanelState,
    restorePanelStates : restorePanelStates,
    togglePanelDetails: togglePanelDetails,
    toggleNestedTableRows: toggleNestedTableRows,
    linkToTaxonomyTree: linkToTaxonomyTree
  };

})();
